This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: tools, widgets, main_window.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
main_window.py
tools/ai_mcp_manager.py
tools/ai_model_manager.py
tools/atool.py
tools/font_config.py
tools/icons.py
tools/image_color_extractor.py
tools/llm_helper.py
tools/logger.py
tools/remote_file_manage.py
tools/session_manager.py
tools/setting_config.py
tools/ssh.py
tools/transfer_worker.py
tools/valid_ip.py
tools/watching_saved.py
widgets/ai_chat_widget.py
widgets/command_input.py
widgets/disk_usage_item.py
widgets/editor_widget.py
widgets/file_tree_widget.py
widgets/files_widgets.py
widgets/home_interface.py
widgets/network_detaile.py
widgets/network_widget.py
widgets/session_dialog.py
widgets/setting_page.py
widgets/side_panel.py
widgets/ssh_webterm.py
widgets/ssh_widget.py
widgets/sync_widget.py
widgets/system_resources_widget.py
widgets/task_detaile.py
widgets/task_widget.py
widgets/theme_helper.py
widgets/transfer_progress_widget.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tools/ai_mcp_manager.py">
import xml.etree.ElementTree as ET
import json
import re
import inspect
from typing import Optional, Dict, Any, Callable

class AIMCPManager:
    """
    Manages parsing, handling, and execution of AI MCP tool usage requests.
    """
    def __init__(self):
        self.mcp_tool_pattern = re.compile(r'<use_mcp_tool>.*?</use_mcp_tool>', re.DOTALL)
        self.tools: Dict[str, Dict[str, Dict[str, Any]]] = {}

    def _generate_schema_from_signature(self, handler: Callable[..., Any]) -> Dict[str, Any]:
        sig = inspect.signature(handler)
        properties = {}
        required = []
        type_mapping = {
            str: "string",
            int: "integer",
            float: "number",
            bool: "boolean",
            list: "array",
            dict: "object"
        }
        for param in sig.parameters.values():
            param_type = type_mapping.get(param.annotation, "any")
            properties[param.name] = param_type
            if param.default is inspect.Parameter.empty:
                required.append(param.name)
        return {
            "type": "object",
            "properties": properties,
            "required": required
        }

    def register_tool_handler(self, server_name: str, tool_name: str, handler: Callable[..., Any], description: str, schema: Optional[Dict[str, Any]] = None):
        if server_name not in self.tools:
            self.tools[server_name] = {}
        if schema is None:
            schema = self._generate_schema_from_signature(handler)
            schema = schema.get("properties", {})
        self.tools[server_name][tool_name] = {
            "handler": handler,
            "description": description,
            "schema": schema
        }

    def execute_tool(self, server_name: str, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        server = self.tools.get(server_name)
        if not server:
            return {"status": "error", "content": f"Server '{server_name}' is not registered."}
        tool = server.get(tool_name)
        if not tool:
            return {"status": "error", "content": f"Tool '{tool_name}' is not registered for server '{server_name}'."}
        handler = tool.get("handler")
        if not handler:
            return {"status": "error", "content": f"Handler for tool '{tool_name}' is missing."}
        try:
            import inspect
            sig = inspect.signature(handler)
            bound_args = sig.bind(**arguments)
            return handler(*bound_args.args, **bound_args.kwargs)
        except Exception as e:
            return {"status": "error", "content": str(e)}

    def parse_mcp_tool_use(self, message: str) -> Optional[Dict[str, Any]]:
        match = self.mcp_tool_pattern.search(message)
        if not match:
            return None
        xml_content = match.group(0)
        try:
            root = ET.fromstring(xml_content)
            server_name_element = root.find('server_name')
            tool_name_element = root.find('tool_name')
            arguments_element = root.find('arguments')
            if server_name_element is None or tool_name_element is None or arguments_element is None:
                return None
            server_name = server_name_element.text.strip() if server_name_element.text else ""
            tool_name = tool_name_element.text.strip() if tool_name_element.text else ""
            try:
                arguments_text = arguments_element.text.strip() if arguments_element.text else "{}"
                arguments = json.loads(arguments_text)
            except json.JSONDecodeError:
                return None
            return {
                "server_name": server_name,
                "tool_name": tool_name,
                "arguments": arguments
            }
        except ET.ParseError:
            return None
        except Exception:
            return None
</file>

<file path="tools/ai_model_manager.py">
from pathlib import Path
import json
from typing import Dict, Any

class AIModelManager:
    def __init__(self):
        self.config_dir = Path.home() / ".config" / "pyqt-ssh"
        self.models_file = self.config_dir / "ai_models.json"
        self._ensure_config_dir()
        self.models_cache = self.load_models()

    def _ensure_config_dir(self):
        self.config_dir.mkdir(parents=True, exist_ok=True)

    def _get_default_models(self) -> Dict[str, Dict[str, Any]]:
        return { "AuraShellVip": { "api_url": "https://aurashell-aichatapi.esmondelliott9043.workers.dev/v1", "model_name": "AuraShellVip", "key":"68*w&t7457#h8S*LS@*W1q8I%DMXMq!MT8#!" } }

    def _init_models_file(self):
        if not self.models_file.exists():
            self.save_models(self._get_default_models())

    def load_models(self) -> Dict[str, Dict[str, Any]]:
        if not self.models_file.exists():
            default_models = self._get_default_models()
            self.save_models(default_models)
            return default_models
        try:
            with open(self.models_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError) as e:
            print(f"Error loading AI models file: {e}. Reinitializing with defaults.")
            default_models = self._get_default_models()
            self.save_models(default_models)
            return default_models

    def save_models(self, models: Dict[str, Dict[str, Any]]):
        with open(self.models_file, 'w', encoding='utf-8') as f:
            json.dump(models, f, ensure_ascii=False, indent=2)
        self.models_cache = models

    def get_model_names(self) -> list[str]:
        return [model['name'] for model in self.models_cache.values()]

    def get_model_by_id(self, model_id: str) -> Dict[str, Any]:
        return self.models_cache.get(model_id)
</file>

<file path="tools/atool.py">
import sys
import os


def resource_path(relative_path):
    if hasattr(sys, "_MEIPASS"):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)
</file>

<file path="tools/font_config.py">
# font_config.py

import json
from pathlib import Path
from PyQt5.QtGui import QFont, QFontDatabase
import sys


class font_config:
    def __init__(self):
        self.config_path = Path.home() / ".config" / "font-config.json"
        if not self.config_path.exists():
            self.init_config()

    def init_config(self):
        config_dict = {
            'family': 'Courier New',
            'size': 12,
            'bg_color_light': "#888888",
            'bg_color_dark': "#252525"
        }
        with open(self.config_path, mode="w", encoding="utf-8") as f:
            json.dump(config_dict, f, ensure_ascii=False, indent=2)

    def write_font(self, font_path=None, font_size=None):
        try:
            with open(self.config_path, mode="r", encoding="utf-8") as f:
                config_dict = json.load(f)

            # Unspecified and not the default font
            if font_path is None and config_dict["family"] != "Courier New":
                pass
            elif font_path is not None:
                config_dict["family"] = font_path
            else:
                config_dict["family"] = "Courier New"
            # config_dict["family"] = font_path if font_path is not None else "Courier New"
            if font_size is None and config_dict["size"] != 12:
                pass
            elif font_size is not None:
                config_dict["size"] = font_size
            else:
                config_dict["size"] = 12
            # config_dict["size"] = font_size if font_size is not None else 12

            with open(self.config_path, mode="w", encoding="utf-8") as f:
                json.dump(config_dict, f, ensure_ascii=False, indent=2)

        except Exception as e:
            print(f"Error write font config: {e}")

    def read_font(self):
        try:
            with open(self.config_path, mode="r", encoding="utf-8") as f:
                config_dict = json.load(f)
            return (config_dict["family"], config_dict["size"])
        except Exception as e:
            print(f"Error reading font config: {e}")

    def get_font(self) -> QFont:
        path, size = self.read_font()

        if path:
            import os
            if os.path.isfile(path):
                font_id = QFontDatabase.addApplicationFont(path)
                if font_id != -1:
                    families = QFontDatabase.applicationFontFamilies(font_id)
                    if families:
                        return QFont(families[0], size)
            else:
                return QFont(path, size)

        return QFont("monospace", size)
</file>

<file path="tools/icons.py">
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QPixmap

import sys
import os


def resource_path(relative_path):
    if hasattr(sys, "_MEIPASS"):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)


Folder_Path = resource_path(os.path.join("resource", "icons", "folder.png"))
File_Path = resource_path(os.path.join(
    "resource", "icons", "default_file_icon.png"))


class My_Icons:
    Folder_Icon = None
    File_Icon = None

    def __init__(self):
        print(f"Folder_Path: {Folder_Path}\nFile_Path: {File_Path}")
        self.Folder_Icon = QPixmap(Folder_Path).scaled(
            64, 64, Qt.KeepAspectRatio, Qt.SmoothTransformation
        )
        self.File_Icon = QPixmap(File_Path).scaled(
            64, 64, Qt.KeepAspectRatio, Qt.SmoothTransformation
        )
</file>

<file path="tools/image_color_extractor.py">
# coding:utf-8
"""
图片主题色提取工具
使用 K-means 聚类算法提取图片的主要颜色
"""
from typing import List, Tuple, Optional
import os


class ImageColorExtractor:
    """图片颜色提取器"""
    
    def __init__(self):
        """初始化颜色提取器"""
        self.dominant_colors = []
        self.rgb_colors = []
        self.hex_colors = []
    
    def extract_colors(self, image_path: str, num_colors: int = 5, resize_width: int = 150) -> List[Tuple[int, int, int]]:
        """
        从图片中提取主要颜色
        
        Args:
            image_path: 图片路径
            num_colors: 要提取的颜色数量，默认5个
            resize_width: 为了提高性能，先将图片缩放到此宽度，默认150px
            
        Returns:
            List[Tuple[int, int, int]]: RGB颜色列表
        """
        try:
            from PIL import Image
            import numpy as np
            from sklearn.cluster import KMeans
        except ImportError as e:
            print(f"缺少必要的库: {e}")
            print("请安装: pip install Pillow scikit-learn numpy")
            return []
        
        if not os.path.exists(image_path):
            print(f"图片文件不存在: {image_path}")
            return []
        
        try:
            # 加载并缩放图片以提高性能
            img = Image.open(image_path)
            
            # 转换为RGB模式（去除透明通道）
            if img.mode != 'RGB':
                img = img.convert('RGB')
            
            # 缩放图片以提高处理速度
            ratio = resize_width / img.width
            new_height = int(img.height * ratio)
            img = img.resize((resize_width, new_height), Image.Resampling.LANCZOS)
            
            # 将图片转换为numpy数组
            img_array = np.array(img)
            
            # 将图片重塑为二维数组 (像素数, 3)
            pixels = img_array.reshape(-1, 3)
            
            # 使用K-means聚类找到主要颜色
            kmeans = KMeans(n_clusters=num_colors, random_state=42, n_init=10)
            kmeans.fit(pixels)
            
            # 获取聚类中心（主要颜色）
            colors = kmeans.cluster_centers_.astype(int)
            
            # 计算每个聚类的样本数量，用于排序
            labels = kmeans.labels_
            label_counts = np.bincount(labels)
            
            # 按出现频率排序
            sorted_indices = np.argsort(label_counts)[::-1]
            sorted_colors = colors[sorted_indices]
            
            # 转换为元组列表
            self.rgb_colors = [tuple(color) for color in sorted_colors]
            self.hex_colors = [self.rgb_to_hex(color) for color in self.rgb_colors]
            self.dominant_colors = list(zip(self.rgb_colors, self.hex_colors))
            
            return self.rgb_colors
            
        except Exception as e:
            print(f"提取颜色时出错: {e}")
            import traceback
            traceback.print_exc()
            return []
    
    def get_dominant_color(self, image_path: str) -> Optional[Tuple[int, int, int]]:
        """
        获取图片的主要颜色（出现最多的颜色）
        
        Args:
            image_path: 图片路径
            
        Returns:
            Tuple[int, int, int]: RGB颜色值，如果失败返回None
        """
        colors = self.extract_colors(image_path, num_colors=1)
        return colors[0] if colors else None
    
    def get_color_palette(self, image_path: str, num_colors: int = 5) -> List[str]:
        """
        获取图片的调色板（十六进制颜色列表）
        
        Args:
            image_path: 图片路径
            num_colors: 要提取的颜色数量
            
        Returns:
            List[str]: 十六进制颜色列表
        """
        self.extract_colors(image_path, num_colors=num_colors)
        return self.hex_colors
    
    @staticmethod
    def rgb_to_hex(rgb: Tuple[int, int, int]) -> str:
        """
        将RGB颜色转换为十六进制
        
        Args:
            rgb: (R, G, B) 元组
            
        Returns:
            str: 十六进制颜色字符串，如 "#FF5733"
        """
        return '#{:02x}{:02x}{:02x}'.format(rgb[0], rgb[1], rgb[2])
    
    @staticmethod
    def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]:
        """
        将十六进制颜色转换为RGB
        
        Args:
            hex_color: 十六进制颜色字符串，如 "#FF5733" 或 "FF5733"
            
        Returns:
            Tuple[int, int, int]: (R, G, B) 元组
        """
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    
    @staticmethod
    def is_dark_color(rgb: Tuple[int, int, int]) -> bool:
        """
        判断颜色是否为深色（用于决定前景文字颜色）
        使用相对亮度公式
        
        Args:
            rgb: (R, G, B) 元组
            
        Returns:
            bool: True表示深色，False表示浅色
        """
        # 计算相对亮度 (根据 ITU-R BT.709 标准)
        r, g, b = rgb
        luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255
        return luminance < 0.5
    
    def get_complementary_color(self, rgb: Tuple[int, int, int]) -> Tuple[int, int, int]:
        """
        获取补色
        
        Args:
            rgb: (R, G, B) 元组
            
        Returns:
            Tuple[int, int, int]: 补色的RGB值
        """
        return (255 - rgb[0], 255 - rgb[1], 255 - rgb[2])
    
    def get_color_info(self, image_path: str, num_colors: int = 5) -> dict:
        """
        获取图片颜色的完整信息
        
        Args:
            image_path: 图片路径
            num_colors: 要提取的颜色数量
            
        Returns:
            dict: 包含颜色信息的字典
        """
        colors = self.extract_colors(image_path, num_colors=num_colors)
        
        if not colors:
            return {}
        
        dominant = colors[0]
        
        return {
            'dominant_color': {
                'rgb': dominant,
                'hex': self.rgb_to_hex(dominant),
                'is_dark': self.is_dark_color(dominant)
            },
            'palette': [
                {
                    'rgb': color,
                    'hex': self.rgb_to_hex(color),
                    'is_dark': self.is_dark_color(color)
                }
                for color in colors
            ],
            'total_colors': len(colors)
        }
</file>

<file path="tools/logger.py">
# global_logger.py
import logging
from pathlib import Path
from datetime import datetime


def setup_global_logging():
    log_dir = Path.home() / ".config" / "pyqt-ssh" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)

    log_file = log_dir / f"app_{datetime.now().strftime('%Y%m%d')}.log"

    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG)

    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)

    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.ERROR)

    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)

    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)

    root_logger.info("Global log system initialization completed")
    root_logger.info("Log files: %s", log_file)


def get_logger(name):
    return logging.getLogger(name)


main_logger = logging.getLogger("main")
gui_logger = logging.getLogger("setting")
session_logger = logging.getLogger("session")
</file>

<file path="tools/session_manager.py">
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List


class Session:
    def __init__(self, session_data: Dict[str, Any] = None):
        default_values = {
            'id': f"session_{datetime.now().timestamp()}",
            'name': 'New Session',
            'host': 'localhost',
            'username': 'user',
            'port': 22,
            'auth_type': 'password',
            'password': '',
            'key_path': '',
            'status': 'disconnected',
            'created_at': datetime.now().isoformat(),
            'history': [],
            'console_content': '',
            'host_key': '',
            'processes_md5': ''
        }
        if session_data:
            for key, default_value in default_values.items():
                setattr(self, key, session_data.get(key, default_value))
        else:
            for key, value in default_values.items():
                setattr(self, key, value)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'name': self.name,
            'host': self.host,
            'username': self.username,
            'port': self.port,
            'auth_type': self.auth_type,
            'password': self.password,
            'key_path': self.key_path,
            'status': self.status,
            'created_at': self.created_at,
            'history': self.history,
            'console_content': self.console_content,
            'host_key': self.host_key,
            'processes_md5': self.processes_md5
        }

    def add_command(self, command: str):
        if command.strip() and command not in self.history:
            self.history.append(command)
            if len(self.history) > 30:
                self.history.pop(0)

    def update_console(self, content: str):
        self.console_content = content

    def set_host_key(self, host_key: str, session_manager):
        self.host_key = host_key

    def set_processes_md5(self, md5: str, session_manager):
        self.processes_md5 = md5
        session_manager.save_sessions(session_manager.sessions_cache)


class SessionManager:
    def __init__(self):
        self.config_dir = Path.home() / ".config" / "pyqt-ssh"
        self.sessions_file = self.config_dir / "sessions.json"
        self._ensure_config_dir()
        self._init_sessions_file()
        self.sessions_cache = self.load_sessions()

    def load_sessions(self) -> List[Session]:
        try:
            with open(self.sessions_file, 'r', encoding='utf-8') as f:
                sessions_data = json.load(f)
                migrated_sessions = []
                for session_data in sessions_data:
                    migrated_session_data = self._migrate_session_data(
                        session_data)
                    migrated_sessions.append(Session(migrated_session_data))
                return migrated_sessions
        except Exception as e:
            print(f"加载会话文件时出错: {e}")
            return [Session()]

    def _migrate_session_data(self, session_data: Dict[str, Any]) -> Dict[str, Any]:
        current_fields = {
            'id': f"session_{datetime.now().timestamp()}",
            'name': 'Migrated Session',
            'host': 'localhost',
            'username': 'user',
            'port': 22,
            'auth_type': 'password',
            'password': '',
            'key_path': '',
            'status': 'disconnected',
            'created_at': datetime.now().isoformat(),
            'history': [],
            'console_content': '',
            'host_key': '',
            'processes_md5': ''
        }
        migrated_data = session_data.copy()
        for field, default_value in current_fields.items():
            if field not in migrated_data:
                migrated_data[field] = default_value
        return migrated_data

    def save_sessions(self, sessions: List[Session]):
        sessions_data = [session.to_dict() for session in sessions]
        with open(self.sessions_file, 'w', encoding='utf-8') as f:
            json.dump(sessions_data, f, ensure_ascii=False, indent=2)
        self.sessions_cache = sessions

    def create_session(self, name: str, host: str, username: str, port: int,
                       auth_type: str, password: str = '', key_path: str = '',
                       host_key: str = '', processes_md5: str = '') -> Session:
        existing_names = [s.name for s in self.sessions_cache]
        if name in existing_names:
            raise ValueError(
                f"A session with the name '{name}' already exists")
        new_session = Session({
            'id': f"session_{datetime.now().timestamp()}",
            'name': name,
            'host': host,
            'username': username,
            'port': port,
            'auth_type': auth_type,
            'password': password,
            'key_path': key_path,
            'status': 'disconnected',
            'created_at': datetime.now().isoformat(),
            'history': [],
            'console_content': f'Welcome to SSH Session: {name}\n{username}@{host}:~$ ',
            'host_key': host_key,
            'processes_md5': processes_md5
        })
        sessions = self.sessions_cache.copy()
        sessions.append(new_session)
        self.save_sessions(sessions)
        return new_session

    def delete_session(self, session_id: str):
        sessions = [s for s in self.sessions_cache if s.id != session_id]
        self.save_sessions(sessions)

    def get_session(self, session_id: str) -> Session:
        for session in self.sessions_cache:
            if session.id == session_id:
                return session

        self.sessions_cache = self.load_sessions()

        for session in self.sessions_cache:
            if session.id == session_id:
                return session

        return None

    def session_name_exists(self, name: str) -> bool:
        return any(s.name == name for s in self.sessions_cache)

    def _ensure_config_dir(self):
        self.config_dir.mkdir(parents=True, exist_ok=True)

    def _init_sessions_file(self):
        if not self.sessions_file.exists():
            default_session = Session({
                'name': 'Default Session',
                'console_content': 'Welcome to SSH\nuser@host:~$ '
            })
            self.save_sessions([default_session])
        else:
            try:
                sessions = self.load_sessions()
                self.save_sessions(sessions)
            except Exception as e:
                print(f"迁移会话数据时出错: {e}")

    def get_session_by_name(self, name: str) -> Session:
        for session in self.sessions_cache:
            if session.name == name:
                return session

        self.sessions_cache = self.load_sessions()

        for session in self.sessions_cache:
            if session.name == name:
                return session

        return None

    def add_command_to_session(self, name: str, command: str):
        session = self.get_session_by_name(name)
        if session:
            session.add_command(command)
            self.save_sessions(self.sessions_cache)

    def clear_history(self, name: str):
        session = self.get_session_by_name(name)
        if session:
            session.history.clear()
            self.save_sessions(self.sessions_cache)

    def update_session_host_key(self, session_name: str, host_key: str):
        session = self.get_session_by_name(session_name)
        if session:
            session.host_key = host_key
            self.save_sessions(self.sessions_cache)

    def update_session_processes_md5(self, session_name: str, md5: str):
        session = self.get_session_by_name(session_name)
        if session:
            session.processes_md5 = md5
            self.save_sessions(self.sessions_cache)

    def check_and_migrate_all_sessions(self):
        sessions = self.load_sessions()
        self.save_sessions(sessions)
</file>

<file path="tools/valid_ip.py">
import ipaddress
import re
from typing import Union


def is_valid_address(addr: str) -> Union[bool, str]:
    """
    Automatically determine and strictly validate whether an IPv4, IPv6 address or domain name is valid.

    Args:
        addr: The address string to validate

    Returns:
        Union[bool, str]: Returns the type string ("IPv4"/"IPv6"/"Domain") if the address is valid, otherwise returns False
    """
    if not isinstance(addr, str):
        return False

    addr = addr.strip()
    if not addr:
        return False

    # Remove possible port number (optional)
    if ':' in addr and ']' not in addr:  # Not an IPv6 address
        if addr.count(':') == 1:  # Could be IPv4:port or hostname:port
            host, port = addr.rsplit(':', 1)
            if port.isdigit() and 0 <= int(port) <= 65535:
                addr = host  # Only validate the host part

    # First try IPv4 (strict check)
    if _is_valid_ipv4(addr):
        return True

    # Then try IPv6
    if _is_valid_ipv6(addr):
        return True

    # Finally, validate domain name
    if _is_valid_domain(addr):
        return True

    return False


def _is_valid_ipv4(addr: str) -> bool:
    """Strictly validate IPv4 address"""
    # Basic format check
    if addr.count('.') != 3:
        return False

    parts = addr.split('.')
    if len(parts) != 4:
        return False

    for part in parts:
        # Check if it's a number
        if not part.isdigit():
            return False

        # Check for leading zeros (except single 0)
        if len(part) > 1 and part[0] == '0':
            return False

        # Check numeric range
        try:
            num = int(part)
            if not 0 <= num <= 255:
                return False
        except ValueError:
            return False

    return True


def _is_valid_ipv6(addr: str) -> bool:
    """Strictly validate IPv6 address"""
    try:
        # Use ipaddress module for strict validation
        ip = ipaddress.IPv6Address(addr)

        # Optional: exclude some special addresses
        if ip.is_unspecified or ip.is_loopback:
            return False

        return True

    except (ipaddress.AddressValueError, ValueError):
        return False


def _is_valid_domain(addr: str) -> bool:
    """Strictly validate domain name"""
    # Length check
    if len(addr) > 253:
        return False

    # Cannot start or end with a dot
    if addr.startswith('.') or addr.endswith('.'):
        return False

    # Split labels
    labels = addr.split('.')
    if len(labels) < 2:  # Must have at least second-level domain and TLD
        return False

    # Check each label
    for label in labels:
        # Label cannot be empty
        if not label:
            return False

        # Label length limit
        if len(label) > 63:
            return False

        # Label format check (letters, digits, hyphen)
        if not re.match(r'^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$', label):
            return False

        # Cannot start or end with hyphen
        if label.startswith('-') or label.endswith('-'):
            return False

    # Top-level domain check (at least 2 characters and must contain letters)
    tld = labels[-1]
    if len(tld) < 2 or not any(c.isalpha() for c in tld):
        return False

    # Check common invalid patterns
    if re.search(r'\.\.', addr):  # Consecutive dots
        return False

    return True


# Test function
def test_address_validation():
    """Test the address validation function"""
    test_cases = [
        # Valid IPv4
        ("192.168.1.1", "IPv4"),
        ("8.8.8.8", "IPv4"),
        ("255.255.255.255", "IPv4"),
        ("0.0.0.0", "IPv4"),

        # Invalid IPv4
        ("192.168.01.1", False),
        ("256.0.0.1", False),
        ("1234.132.1", False),
        ("192.168.1", False),

        # Valid IPv6
        ("2001:0db8:85a3:0000:0000:8a2e:0370:7334", "IPv6"),
        ("2001::1", "IPv6"),
        ("::1", "IPv6"),

        # Invalid IPv6
        ("2001::1::1", False),
        (":::", False),

        # Valid domain
        ("example.com", "Domain"),
        ("sub-domain.example.com", "Domain"),
        ("google.com", "Domain"),

        # Invalid domain
        ("-bad.example.com", False),
        ("bad-.example.com", False),
        ("too..many.dots.com", False),
        ("test.c", False),

        # Additional test cases
        ("1234.132.1", False),
        ("192.168.01.1", False),
        ("256.0.0.1", False),
        ("2001:0db8:85a3:0000:0000:8a2e:0370:7334", "IPv6"),
        ("2001::1", "IPv6"),
        ("example.com", "Domain"),
        ("sub-domain.example.com", "Domain"),
        ("-bad.example.com", False),
        ("too..many..dots", False),
        ("123.456.78.90", False)
    ]

    print("Test Results:")
    print("=" * 60)
    all_passed = True

    for addr, expected in test_cases:
        result = is_valid_address(addr)
        status = "✓" if result == expected else "✗"
        if result != expected:
            all_passed = False

        print(f"{status} {addr:<45} -> Expected: {expected:<8} Actual: {result}")

    print("\n" + "=" * 60)
    if all_passed:
        print("✓ All test cases passed!")
    else:
        print("✗ Some test cases failed!")

    return all_passed


if __name__ == "__main__":
    test_address_validation()
</file>

<file path="tools/watching_saved.py">
from PyQt5.QtCore import QThread, pyqtSignal
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import os
import time


class FileWatchThread(QThread):
    file_saved = pyqtSignal(str)

    def __init__(self, file_path, timeout_hours=1):
        """
        :param file_path: 要监控的文件
        :param timeout_hours: 超时时间（小时），如果这么久没变化就结束线程
        """
        super().__init__()
        self.file_path = os.path.abspath(file_path)
        self._running = True
        self.timeout_hours = timeout_hours
        self._last_event_time = time.time()  # 初始化为当前时间

    def run(self):
        class Handler(FileSystemEventHandler):
            def __init__(self, outer):
                self.outer = outer
                self._last_emit_time = 0

            def on_modified(self, event):
                if os.path.abspath(event.src_path) != self.outer.file_path:
                    return

                now = time.time()
                if now - self._last_emit_time < 1.0:  # 1秒内只触发一次
                    return

                self.outer._last_event_time = now
                self._last_emit_time = now
                self.outer.file_saved.emit(self.outer.file_path)

        event_handler = Handler(self)
        observer = Observer()
        observer.schedule(event_handler, path=os.path.dirname(
            self.file_path), recursive=False)
        observer.start()

        try:
            while self._running:
                if time.time() - self._last_event_time > self.timeout_hours * 3600:
                    print(f"[FileWatchThread] {self.file_path} 超时未修改，自动退出线程")
                    break
                time.sleep(0.5)
        finally:
            observer.stop()
            observer.join()

    def stop(self):
        """终止线程"""
        self._running = False
        self.wait()

# --------------------------
# 使用示例（放在主线程/GUI中）：

# file_thread = FileWatchThread("example.txt")
# file_thread.file_saved.connect(lambda path: print(f"{path} was saved!"))
# file_thread.start()
#
# # 停止线程：
# file_thread.stop()
</file>

<file path="widgets/ai_chat_widget.py">
from PyQt5.QtWidgets import QWidget, QVBoxLayout
from PyQt5.QtWebEngineWidgets import QWebEngineView, QWebEngineSettings
import os
from PyQt5.QtCore import QUrl, Qt, QObject, pyqtSlot, QEventLoop, QTimer
from PyQt5.QtWebChannel import QWebChannel
from PyQt5.QtGui import QKeyEvent, QDesktopServices
from tools.setting_config import SCM
from tools.ai_model_manager import AIModelManager
from tools.ai_mcp_manager import AIMCPManager
import json
import typing

if typing.TYPE_CHECKING:
    from main_window import Window
    from widgets.ssh_widget import SSHWidget

CONFIGER = SCM()

class AIBridge(QObject):
    def __init__(self, parent=None, main_window: 'Window' = None):
        super().__init__(parent)
        self.main_window = main_window
        self.model_manager = AIModelManager()
        self.mcp_manager = AIMCPManager()
        self._register_tool_handlers()

    def _register_tool_handlers(self):
        def Linux终端():
            def exe_shell(shell: str):
                command = shell
                if not command:
                    return json.dumps({"status": "error", "content": "No command provided."})
                if not self.main_window:
                    return json.dumps({"status": "error", "content": "Main window not available."})
                active_widget = self.main_window.get_active_ssh_widget()
                if not active_widget:
                    return json.dumps({"status": "error", "content": "No active SSH session found."})
                worker = None
                if hasattr(active_widget, 'ssh_widget') and hasattr(active_widget.ssh_widget, 'bridge'):
                    worker = active_widget.ssh_widget.bridge.worker
                if not worker:
                    return json.dumps({"status": "error", "content": "Could not find the SSH worker for the active session."})
                output = []
                exit_code = [-1]
                loop = QEventLoop()
                def on_output_ready(result_str, code):
                    output.append(result_str)
                    exit_code[0] = code
                    if loop.isRunning():
                        loop.quit()
                timeout_timer = QTimer()
                timeout_timer.setSingleShot(True)
                timeout_timer.timeout.connect(loop.quit)
                worker.command_output_ready.connect(on_output_ready)
                active_widget.execute_command_and_capture(command)
                timeout_timer.start(30000)
                loop.exec_()
                timeout_timer.stop()
                try:
                    worker.command_output_ready.disconnect(on_output_ready)
                except TypeError:
                    pass
                if not output:
                    return json.dumps({"status": "error", "content": "Command timed out or produced no output."})
                return json.dumps({
                    "status": "success",
                    "exit_code": exit_code[0],
                    "output": ''.join(output)
                })
            self.mcp_manager.register_tool_handler(
                server_name="Linux终端",
                tool_name="exe_shell",
                handler=exe_shell,
                description="在当前终端执行shell命令"
            )
        Linux终端()

    @pyqtSlot(str, result=str)
    def processMessage(self, message):
        mcp_tool_call = self.mcp_manager.parse_mcp_tool_use(message)
        if mcp_tool_call:
            return json.dumps(mcp_tool_call)
        return ""

    @pyqtSlot(str, str, str, result=str)
    def executeMcpTool(self, server_name, tool_name, arguments_json):
        try:
            arguments = json.loads(arguments_json)
            result = self.mcp_manager.execute_tool(server_name, tool_name, arguments)
            return str(result)
        except json.JSONDecodeError as e:
            return json.dumps({"status": "error", "content": f"Invalid arguments format: {e}"})

    @pyqtSlot(result=str)
    def getModels(self):
        return json.dumps(self.model_manager.load_models())

    @pyqtSlot(str)
    def saveModels(self, models_json):
        try:
            models_data = json.loads(models_json)
            self.model_manager.save_models(models_data)
        except Exception as e:
            print(f"Error saving AI models: {e}")

    @pyqtSlot(str, result=str)
    def getSetting(self, key):
        config = CONFIGER.read_config()
        return config.get(key, "")

    @pyqtSlot(str, str)
    def saveSetting(self, key, value):
        CONFIGER.revise_config(key, value)

    @pyqtSlot(result=str)
    def getSystemPrompt(self):
        try:
            current_dir = os.path.dirname(os.path.abspath(__file__))
            prompt_path = os.path.join(current_dir, '..', 'resource', 'widget', 'ai_chat', 'system.md')
            with open(prompt_path, 'r', encoding='utf-8') as f:
                prompt = f.read()

            prompt += "\n\n# 已连接的MCP服务器\n"
            prompt += "当服务器已连接时,你可以通过`use_mcp_tool`工具使用该服务器的工具.\n"

            for server_name, tools in self.mcp_manager.tools.items():
                prompt += f"\n## {server_name}\n"
                prompt += "### 可用工具\n"
                for tool_name, tool_info in tools.items():
                    prompt += f"- {tool_name}\n"
                    prompt += f"      {tool_info['description']}\n\n"
                    prompt += "      输入模式:\n"
                    schema_str = json.dumps(tool_info['schema'], indent=2, ensure_ascii=False)
                    prompt += f"```json\n{schema_str}\n```\n"
            return prompt
        except Exception as e:
            print(f"Error generating system prompt: {e}")
            return ""


class AiChatWidget(QWidget):
    def __init__(self, parent=None, main_window: 'Window' = None):
        super().__init__(parent)
        self.tab_id = None
        self._side_panel = None
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(self.layout)

        self.channel = QWebChannel()
        self.bridge = AIBridge(self, main_window=main_window)
        self.channel.registerObject('backend', self.bridge)

        self.browser = QWebEngineView()
        self.browser.page().setWebChannel(self.channel)
        self.browser.settings().setAttribute(QWebEngineSettings.LocalContentCanAccessRemoteUrls, True)
        self.browser.settings().setAttribute(QWebEngineSettings.LocalContentCanAccessFileUrls, True)
        self.browser.setContextMenuPolicy(Qt.NoContextMenu)
        self.layout.addWidget(self.browser)

        project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
        index_html_path = os.path.join(project_root, 'resource', 'widget', 'ai_chat', 'index.html')
        self.browser.setUrl(QUrl.fromLocalFile(index_html_path))

    def keyPressEvent(self, event: QKeyEvent):
        if event.key() == Qt.Key_F5:
            self.browser.reload()
        elif event.key() == Qt.Key_F12:
            if os.environ.get('QTWEBENGINE_REMOTE_DEBUGGING'):
                QDesktopServices.openUrl(QUrl("http://localhost:" + str(os.environ['QTWEBENGINE_REMOTE_DEBUGGING'])))
        else:
            super().keyPressEvent(event)
            
    def set_tab_id(self, tab_id):
        self.tab_id = tab_id

    def _find_side_panel(self):
        if self._side_panel:
            return self._side_panel
        parent = self.parent()
        while parent is not None:
            if parent.metaObject().className() == "SidePanelWidget":
                self._side_panel = parent
                return self._side_panel
            parent = parent.parent()
        return None

    def get_tab_data(self):
        side_panel = self._find_side_panel()
        if side_panel:
            tab_data = side_panel.get_tab_data_by_uuid(self.tab_id)
            return tab_data
        return None
</file>

<file path="widgets/disk_usage_item.py">
#!/usr/bin/env python3
# disk_monitor_demo.py
# Demo: Disk monitor widget (PyQt5 + qfluentwidgets)
# - Cards auto-resize to scroll viewport width
# - No "occupying stretch" that blocks expansion
# - APIs: add_disk_item, update_disk_item, remove_disk_item
# - Simple demo random updates

from qfluentwidgets import FluentIcon as FIF, IconWidget, ToolButton
from PyQt5.QtWidgets import QFrame, QWidget, QHBoxLayout, QVBoxLayout, QLabel, QPushButton, QSizePolicy
from PyQt5.QtGui import QColor, QFontMetrics
from PyQt5.QtCore import Qt, pyqtSignal
from qfluentwidgets import FluentIcon as FIF, IconWidget, ToolButton, ScrollArea as QS_SCROLL
import sys
import random
from functools import partial
from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QRectF, QEvent
from PyQt5.QtGui import QColor, QPainter, QPen, QBrush, QLinearGradient, QFont
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame,
    QApplication, QPushButton, QSizePolicy
)
from tools.font_config import font_config
_FONT = font_config().get_font()

# fallback font_config.get_font


class GradientFillBackgroundMixin:
    @staticmethod
    def _choose_colors(percent: int):
        if percent < 60:
            return "#27ae60", "#2ecc71"
        elif percent < 85:
            return "#f39c12", "#f1c40f"
        else:
            return "#e74c3c", "#c0392b"

    @staticmethod
    def _fg_text_color_for_percent(percent: int):
        return "#FFFFFF"


class FillDiskCard(QFrame):

    def __init__(self, disk_id: str, data: dict, parent=None, open_callback=None):
        super().__init__(parent)
        self.disk_id = disk_id
        self.open_callback = open_callback

        self.setFixedHeight(64)
        self.setMinimumHeight(56)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.setAttribute(Qt.WA_StyledBackground, True)

        self._percent = 0

        self.setStyleSheet("""
            QFrame { border-radius: 8px; margin:0px; padding:0px; }
            QLabel, QPushButton { background: transparent; }
        """)

        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 6, 8, 6)
        layout.setSpacing(8)

        left_v = QVBoxLayout()
        left_v.setContentsMargins(0, 0, 0, 0)
        left_v.setSpacing(2)

        top_row = QHBoxLayout()
        top_row.setContentsMargins(0, 0, 0, 0)
        top_row.setSpacing(6)

        self.icon = IconWidget(FIF.DEVELOPER_TOOLS, self)
        self.icon.setFixedSize(14, 14)

        self.device_label = QLabel(data.get("device", "unknown"))
        dev_font = QFont()
        dev_font.setPointSize(9)
        dev_font.setBold(True)
        self.device_label.setFont(dev_font)
        self.device_label.setStyleSheet("color: #FFFFFF;")

        top_row.addWidget(self.icon, 0, Qt.AlignVCenter)
        top_row.addWidget(self.device_label, 0, Qt.AlignVCenter)
        top_row.addStretch(1)

        self.mount_label = QLabel(data.get("mount", ""))
        mount_font = QFont()
        mount_font.setPointSize(8)
        self.mount_label.setFont(mount_font)
        self.mount_label.setWordWrap(False)
        self.mount_label.setStyleSheet("color: rgba(255,255,255,200);")
        self.mount_label.setToolTip(data.get("mount", ""))

        left_v.addLayout(top_row)
        left_v.addWidget(self.mount_label)

        center = QHBoxLayout()
        center.setContentsMargins(0, 0, 0, 0)
        center.setSpacing(8)

        self.size_info = QLabel("")
        size_font = QFont()
        size_font.setPointSize(9)
        self.size_info.setFont(size_font)
        self.size_info.setStyleSheet("color: rgba(255,255,255,200);")

        self.percent_label = QLabel("0%")
        pct_font = QFont()
        pct_font.setPointSize(10)
        pct_font.setBold(True)
        self.percent_label.setFont(pct_font)
        self.percent_label.setStyleSheet("color: #FFFFFF;")

        center.addWidget(self.size_info, 0, Qt.AlignVCenter | Qt.AlignLeft)
        center.addStretch(1)
        center.addWidget(self.percent_label, 0,
                         Qt.AlignVCenter | Qt.AlignRight)

        right = QVBoxLayout()
        right.setContentsMargins(0, 0, 0, 0)
        right.setSpacing(2)

        self.read_label = QLabel("R: 0 KB/s", self)
        self.write_label = QLabel("W: 0 KB/s", self)
        r_font = QFont()
        r_font.setPointSize(9)
        r_font.setBold(True)
        self.read_label.setFont(r_font)
        w_font = QFont()
        w_font.setPointSize(8)
        w_font.setBold(False)
        self.write_label.setFont(w_font)
        self.read_label.setStyleSheet("color: rgba(255,255,255,240);")
        self.write_label.setStyleSheet("color: rgba(255,255,255,220);")

        right.addWidget(self.read_label, 0, Qt.AlignRight)
        right.addWidget(self.write_label, 0, Qt.AlignRight)

        self.open_btn = ToolButton(FIF.FOLDER, self)
        self.open_btn.setFixedSize(16, 16)
        self.open_btn.setStyleSheet(
            "background: transparent; color: rgba(255,255,255,200);")
        self.open_btn.clicked.connect(self._open_mount)

        right_wrap = QHBoxLayout()
        right_wrap.setContentsMargins(0, 0, 0, 0)
        right_wrap.setSpacing(4)
        right_wrap.addLayout(right)
        right_wrap.addWidget(self.open_btn, 0, Qt.AlignRight)

        # 布局权重（左中右），权重分配使中间尽可能紧凑
        layout.addLayout(left_v, 4)
        layout.addLayout(center, 4)
        layout.addLayout(right_wrap, 2)

        self.setData(data)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        rect = self.rect()
        main_col, mid_col = self._choose_colors(self._percent)
        stop = max(0.0, min(1.0, self._percent / 100.0))

        grad = QLinearGradient(rect.topLeft(), rect.topRight())
        grad.setColorAt(0, QColor(main_col))
        grad.setColorAt(stop, QColor(mid_col))
        grad.setColorAt(min(stop + 0.001, 1.0), QColor(0, 0, 0, 40))
        grad.setColorAt(1, QColor(0, 0, 0, 40))

        painter.setBrush(QBrush(grad))
        painter.setPen(QPen(QColor(255, 255, 255, 18), 1))
        painter.drawRoundedRect(rect.adjusted(1, 1, -1, -1), 8, 8)

        super().paintEvent(event)

    def _choose_colors(self, percent: int):
        if percent < 60:
            return "#27ae60", "#2ecc71"
        elif percent < 85:
            return "#f39c12", "#f1c40f"
        else:
            return "#e74c3c", "#c0392b"

    def _open_mount(self):
        mount = self.mount_label.toolTip() or self.mount_label.text()
        if self.open_callback:
            self.open_callback(mount)

    def setData(self, data: dict):
        device = data.get("device", self.device_label.text())
        mount = data.get("mount", self.mount_label.toolTip()
                         or self.mount_label.text())
        used_percent = data.get("used_percent", None)
        size_kb = data.get("size_kb", None)
        used_kb = data.get("used_kb", None)
        avail_kb = data.get("avail_kb", None)
        r = data.get("read_kbps", 0)
        w = data.get("write_kbps", 0)

        self.device_label.setText(device)

        if mount is None:
            mount = ""
        try:
            avail_width = max(120, int(self.width() * 0.35))
        except Exception:
            avail_width = 140
        fm = QFontMetrics(self.mount_label.font())
        elided = fm.elidedText(mount, Qt.ElideMiddle, avail_width)
        self.mount_label.setText(elided)
        self.mount_label.setToolTip(mount)

        p = 0
        if used_percent is not None:
            try:
                if isinstance(used_percent, str) and used_percent.endswith("%"):
                    p = int(used_percent.rstrip("%"))
                else:
                    p = int(float(used_percent))
            except Exception:
                p = 0
        p = max(0, min(100, p))
        self._percent = p
        self.percent_label.setText(f"{p}%")

        if all(v is not None for v in (size_kb, used_kb, avail_kb)):
            try:
                def hr(kb):
                    if kb >= 1024 * 1024:
                        return f"{kb / 1024 / 1024:.1f}G"
                    if kb >= 1024:
                        return f"{kb / 1024:.1f}M"
                    return f"{kb}K"
                self.size_info.setText(f"{hr(used_kb)}/{hr(size_kb)} used")
            except Exception:
                self.size_info.setText("")
        else:
            self.size_info.setText("")

        try:
            self.read_label.setText(f"R: {float(r):.1f} KB/s")
            self.write_label.setText(f"W: {float(w):.1f} KB/s")
        except Exception:
            self.read_label.setText(f"R: {r} KB/s")
            self.write_label.setText(f"W: {w} KB/s")

        self.update()


class DiskMonitor(QWidget):

    into_driver_path = pyqtSignal(str)  # signal to open mount path

    def __init__(self, parent=None):
        super().__init__(parent)
        self.disk_items = {}
        main = QVBoxLayout(self)
        main.setContentsMargins(8, 8, 8, 8)
        main.setSpacing(8)

        header = QHBoxLayout()
        header.addStretch(1)
        main.addLayout(header)

        # use qfluentwidgets ScrollArea (you used QS_SCROLL)
        from qfluentwidgets import ScrollArea as QS_SCROLL
        self.scroll = QS_SCROLL(self)
        self.scroll.setWidgetResizable(True)
        self.scroll.setFrameShape(QFrame.NoFrame)

        self.container = QWidget()
        self.container_layout = QVBoxLayout(self.container)
        self.container_layout.setContentsMargins(0, 0, 0, 0)
        self.container_layout.setSpacing(10)
        self.container_layout.setAlignment(
            Qt.AlignTop)  # important: top-align children

        self.scroll.setWidget(self.container)
        main.addWidget(self.scroll)

        # optional demo timer left out

    def add_disk_item(self, disk_id: str, data: dict):
        if disk_id in self.disk_items:
            self.update_disk_item(disk_id, data)
            return
        card = FillDiskCard(
            disk_id, data, parent=self.container, open_callback=self._on_open)
        # ensure card objectName is set (FillDiskCard already does it)
        self.container_layout.insertWidget(0, card)
        self.disk_items[disk_id] = card
        # no stretch widget added: cards keep their minimum height

    def update_disk_item(self, disk_id: str, data: dict):
        card = self.disk_items.get(disk_id)
        if not card:
            self.add_disk_item(disk_id, data)
            return
        card.setData(data)

    def remove_disk_item(self, disk_id: str):
        card = self.disk_items.pop(disk_id, None)
        if card:
            card.hide()
            card.deleteLater()

    def _on_open(self, mount: str):
        self.into_driver_path.emit(mount)
</file>

<file path="widgets/home_interface.py">
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QListWidgetItem, QFrame)
from PyQt5.QtCore import Qt, pyqtSignal
from qfluentwidgets import (PrimaryPushButton, ListWidget, TitleLabel,
                            BodyLabel, FluentIcon as FIF, CardWidget, RoundMenu, CaptionLabel, Action, TransparentToolButton, InfoBar, InfoBarPosition)
from PyQt5.QtGui import QFont
# from widgets.session_manager import SessionManager
from widgets.session_dialog import SessionDialog
from tools.font_config import font_config
from tools import valid_ip


class SSH_CARD(CardWidget):

    def __init__(self, title, content, session_id, parent=None):
        super().__init__(parent)
        self.parent_interface = self.parent()
        font = getattr(parent, "fonts", None)
        self.title = title
        self.session_id = session_id
        self.titleLabel = BodyLabel(self.title, self)
        self.contentLabel = CaptionLabel(content, self)

        # Add status indicator

        # self.statusIndicator = QLabel(self)
        # self.statusIndicator.setFixedSize(8, 8)
        # self.statusIndicator.setStyleSheet(
        #     "background-color: gray; border-radius: 4px;")
        # self.set_connect_status(False)
        self.moreButton = TransparentToolButton(FIF.MORE, self)

        self.hBoxLayout = QHBoxLayout(self)
        self.vBoxLayout = QVBoxLayout()

        self.setFixedHeight(73)
        self.contentLabel.setTextColor("#606060", "#d2d2d2")

        self.hBoxLayout.setContentsMargins(20, 11, 11, 11)
        self.hBoxLayout.setSpacing(15)

        self.vBoxLayout.setContentsMargins(0, 0, 0, 0)
        self.vBoxLayout.setSpacing(0)

        self.titleLayout = QHBoxLayout()
        # self.titleLayout.addWidget(self.statusIndicator)
        self.titleLayout.addWidget(self.titleLabel)
        self.titleLayout.setSpacing(5)
        self.titleLayout.setContentsMargins(0, 0, 0, 0)

        self.vBoxLayout.addLayout(self.titleLayout, 0)
        self.vBoxLayout.addWidget(self.contentLabel, 0, Qt.AlignVCenter)
        self.vBoxLayout.setAlignment(Qt.AlignVCenter)
        self.hBoxLayout.addLayout(self.vBoxLayout)

        self.hBoxLayout.addStretch(1)
        self.hBoxLayout.addWidget(self.moreButton, 0, Qt.AlignRight)

        self.moreButton.setFixedSize(32, 32)

        self.menu = RoundMenu(parent=self)

        self.action_open = Action(FIF.FOLDER, self.tr("Open a new session"))
        self.action_edit = Action(FIF.EDIT, self.tr("Edit"))
        self.action_delete = Action(FIF.DELETE, self.tr("Delete"))
        self.close_action = Action(FIF.CLOSE, self.tr('Close all subsessions'))
        self.menu.addActions([self.action_open, self.action_edit,])
        self.menu.addSeparator()
        self.menu.addActions([self.action_delete, self.close_action])

        self.moreButton.clicked.connect(self.showMenu)
        self.close_action.triggered.connect(self._close_sub_interface)
        self.action_open.triggered.connect(lambda: getattr(
            parent, "sessionClicked", None).emit(session_id))
        self.action_edit.triggered.connect(self._edit)
        self.action_delete.triggered.connect(self._on_delete)

        if font:
            for w in [self.titleLabel, self.contentLabel, self.moreButton,
                      self.action_open, self.action_edit, self.action_delete]:
                w.setFont(font)

    def _close_sub_interface(self,):
        parent = self.parent()
        while parent:
            if hasattr(parent, 'remove_sub_interface'):
                parent.remove_sub_interface(
                    self, close_sub_all=True, parent_id=self.title)
                return
            parent = parent.parent()

    # def set_connect_status(self, status: bool):
    #     print(f"连接状态：{status}")
    #     """设置连接状态指示器"""
    #     color = "#00FF00" if status else "#FF0000"  # 绿色表示连接，红色表示断开
    #     self.statusIndicator.setStyleSheet(f"""
    #         background-color: {color};
    #         border-radius: 4px;
    #     """)
    #     # 可选：添加工具提示
    #     self.statusIndicator.setToolTip("已连接" if status else "已断开")

    #     # 强制刷新
    #     self.statusIndicator.style().unpolish(self.statusIndicator)
    #     self.statusIndicator.style().polish(self.statusIndicator)
    #     self.statusIndicator.update()

    # def _open_card(self):
    #     if self.parent_interface and hasattr(self.parent_interface, "sessionClicked"):
    #         self.parent_interface.sessionClicked.emit(session_id)

    def set_card_font(self, font: QFont = None):
        self.titleLabel.setFont(font)
        self.contentLabel.setFont(font)
        self.moreButton.setFont(font)
        self.action_delete.setFont(font)
        self.action_edit.setFont(font)
        self.action_open.setFont(font)
        self.setFont(font)

    def _edit(self):
        if hasattr(self.parent_interface, '_create_edit_new_session'):
            self.parent_interface._create_edit_new_session(
                "edit", self.session_id)

    def _on_delete(self):
        if hasattr(self.parent_interface, 'session_manager'):
            self.parent_interface.session_manager.delete_session(
                self.session_id)
            self.parent_interface.refresh_sessions()  # Refresh list

    def showMenu(self):
        pos = self.moreButton.mapToGlobal(self.moreButton.rect().bottomRight())
        self.menu.exec(pos)


class MainInterface(QWidget):
    sessionClicked = pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        font_ = font_config()
        self.fonts = font_.get_font()
        if parent and hasattr(parent, "sessionmanager"):
            self.session_manager = parent.sessionmanager
        self.setObjectName("MainInterface")
        self._build_ui()
        self._load_sessions()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(30, 20, 30, 20)
        layout.setSpacing(15)

        title_layout = QHBoxLayout()
        self.title_label = TitleLabel(self.tr("SSH session management"))
        self.new_session_btn = PrimaryPushButton(
            self.tr("New Session"), self, FIF.ADD)
        self.new_session_btn.clicked.connect(self._create_edit_new_session)

        title_layout.addWidget(self.title_label)
        title_layout.addStretch()
        title_layout.addWidget(self.new_session_btn)

        layout.addLayout(title_layout)

        separator = QFrame()
        separator.setFrameShape(QFrame.HLine)
        separator.setFrameShadow(QFrame.Sunken)
        # separator.setStyleSheet("background-color: rgba(255, 255, 255, 50);")
        layout.addWidget(separator)

        info_label = BodyLabel(
            self.tr("Select an existing session or create a new SSH connection"))
        info_label.setStyleSheet("color: #888888;")
        layout.addWidget(info_label)

        self.session_list = ListWidget()
        self.session_list.setSpacing(10)
        self.session_list.setStyleSheet("""

        ListWidget {
            background-color: transparent;
            border: 1px solid rgba(255, 255, 255, 30);
            border-radius: 8px;
            outline: none;
            padding: 5px; 
        }

        ListWidget::item {
            background-color: transparent;
            border: none;
            padding: 0px;
        }

        ListWidget::item:focus {
            outline: none;
        }
        """)

        self.session_list.itemDoubleClicked.connect(self._on_session_clicked)
        layout.addWidget(self.session_list)

        self.empty_label = BodyLabel(self.tr(
            "There is no session yet. Click the button in the upper right corner to create a new session."))
        self.empty_label.setAlignment(Qt.AlignCenter)
        self.empty_label.setStyleSheet("color: #666666; padding: 40px;")
        self.empty_label.hide()
        layout.addWidget(self.empty_label)

    def _load_sessions(self):
        self.session_list.clear()
        sessions = self.session_manager.sessions_cache

        if not sessions:
            self.empty_label.show()
            self.session_list.hide()
        else:
            self.empty_label.hide()
            self.session_list.show()

            for session in sessions:
                self._add_session_item(session)

    def _add_session_item(self, session):
        card = SSH_CARD(
            title=session.name,
            content=f"{session.username}@{session.host}:{session.port}",
            session_id=session.id,
            parent=self
        )
        list_item = QListWidgetItem(self.session_list)
        card.setBorderRadius(8)
        list_item.setSizeHint(card.sizeHint())
        # card.set_card_font(self.fonts)
        self.session_list.addItem(list_item)
        list_item.setData(Qt.UserRole, session.id)
        self.session_list.setItemWidget(list_item, card)

    def _on_session_clicked(self, item):
        session_id = item.data(Qt.UserRole)
        self.sessionClicked.emit(session_id)

    def _create_edit_new_session(self, mode: str = "create", session_id: str = None):
        dialog = SessionDialog(self)
        if mode == "create":
            pass
        elif mode == "edit":
            session = next(
                (s for s in self.session_manager.sessions_cache if s.id == session_id), None)

            if not session:
                print(f"Session ID not found: {session_id}")
                return
            print("Edited session ID:", session.id)
            dialog.session_name.setText(session.name)
            dialog.username.setText(session.username)
            dialog.host.setText(session.host)
            dialog.port.setText(str(session.port))
            if session.auth_type == "password":
                dialog._on_auth_changed(0)
                dialog.password.setText(session.password)
            elif session.auth_type == "key":
                dialog.auth_combo.setCurrentIndex(1)
                dialog._on_auth_changed(1)
                dialog.key_path.setText(session.key_path)
        if dialog.exec():
            try:
                port = int(dialog.port.text()
                           ) if dialog.port.text().isdigit() else 22
            except:
                port = 0
            host_ip = dialog.host.text()
            if valid_ip.is_valid_address(host_ip) and 10 < port < 65535:
                session_data = {
                    'name': dialog.session_name.text().strip(),
                    'host': host_ip,
                    'port': port,
                    'username': dialog.username.text().strip(),
                    'auth_type': 'password' if dialog.auth_combo.currentIndex() == 0 else 'key',
                    'password': dialog.password.text() if dialog.auth_combo.currentIndex() == 0 else '',
                    'key_path': dialog.key_path.text() if dialog.auth_combo.currentIndex() != 0 else ''
                }

                print("Session Name:", session_data['name'])
                print("Username:", session_data['username'])
                print("Host:", session_data['host'])
                print("Port:", session_data['port'])
                print("Authentication method:", session_data['auth_type'])
                print("Password:", session_data['password'])
                print("Key Path:", session_data['key_path'])

                try:
                    content_mode = self.tr("New")
                    if mode == "edit":
                        self.session_manager.delete_session(
                            session_id=session_id)
                        content_mode = self.tr("Edit")
                    new_session = self.session_manager.create_session(
                        name=session_data['name'],
                        host=session_data['host'],
                        username=session_data['username'],
                        port=session_data['port'],
                        auth_type=session_data['auth_type'],
                        password=session_data['password'],
                        key_path=session_data['key_path']
                    )
                    self._load_sessions()
                    # self.sessionClicked.emit(new_session.id)

                    InfoBar.success(
                        title=self.tr('Success'),
                        content=self.tr(
                            f"{content_mode}session [ {session_data['name']} ] success"),
                        orient=Qt.Horizontal,
                        isClosable=True,
                        position=InfoBarPosition.TOP_RIGHT,
                        duration=2000,
                        parent=self
                    )

                except ValueError as e:
                    InfoBar.error(
                        title=self.tr('Error！！！'),
                        content=self.tr(f"Session attempt failed Reason：{e}"),
                        orient=Qt.Horizontal,
                        isClosable=True,
                        position=InfoBarPosition.TOP_RIGHT,
                        duration=10000,
                        parent=self
                    )

            else:
                InfoBar.warning(
                    title=self.tr('Creation failed'),
                    content=self.tr(
                        "The IP/domain name/port is illegal, please re-enter"),
                    orient=Qt.Horizontal,
                    isClosable=True,
                    position=InfoBarPosition.TOP_RIGHT,
                    duration=5000,
                    parent=self
                )

    def refresh_sessions(self):
        self.session_manager.sessions_cache = self.session_manager.load_sessions()
        self._load_sessions()

    # def showEvent(self, event):
    #     super().showEvent(event)
    #     self.refresh_sessions()
</file>

<file path="widgets/network_detaile.py">
import random
from PyQt5.QtCore import Qt, QAbstractTableModel, QModelIndex, QSortFilterProxyModel
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QVBoxLayout, QWidget, QHeaderView
from qfluentwidgets import TableView, setTheme, Theme, PrimaryPushButton, LineEdit, ComboBox


class NetConnectionModel(QAbstractTableModel):
    def __init__(self, headers, data=None):
        super().__init__()
        self._headers = headers
        self._data = data or []  # list of lists

    def rowCount(self, parent=QModelIndex()):
        return len(self._data)

    def columnCount(self, parent=QModelIndex()):
        return len(self._headers)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None

        row, col = index.row(), index.column()

        if role == Qt.DisplayRole:
            # 返回显示文本
            if col < len(self._data[row]):
                return str(self._data[row][col])
            return ""

        elif role == Qt.TextAlignmentRole:
            # 数字列右对齐，其他左对齐
            if col in [1, 2, 4, 5]:  # PID, Local Port, Remote Port, Connections
                return Qt.AlignRight | Qt.AlignVCenter
            return Qt.AlignLeft | Qt.AlignVCenter

        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._headers[section]
        return None

    def updateData(self, new_data):
        """更新表格数据的接口"""
        self.beginResetModel()
        # 转换 dict list 到 list of lists
        converted_data = []
        for item in new_data:
            row = [
                item.get("Process Name", ""),
                item.get("PID", 0),
                item.get("Local Port", 0),
                item.get("Local IP", ""),
                item.get("Remote Port", 0),
                item.get("Connections", 0),
                item.get("Upload/Download", "")
            ]
            converted_data.append(row)
        self._data = converted_data
        self.endResetModel()


class NetProcessMonitor(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(self.tr("Process Network Connections Monitor"))
        self.resize(1000, 600)

        # setTheme(Theme.DARK)

        self.headers = [
            self.tr("Process Name"),
            self.tr("PID"),
            self.tr("Local Port"),
            self.tr("Local IP"),
            self.tr("Remote Port"),
            self.tr("Connections"),
            self.tr("Upload/Download")
        ]

        self.initUI()

        # self.generateSampleData()

    def initUI(self):
        # 设置透明背景
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        self.setStyleSheet("background: transparent;")

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # 创建控制面板
        control_layout = QVBoxLayout()
        control_layout.setContentsMargins(0, 0, 0, 0)
        control_layout.setSpacing(5)

        # 搜索框 - 透明样式
        self.filter_input = LineEdit(self)
        self.filter_input.setPlaceholderText(
            self.tr("Filter by process name or PID..."))
        self.filter_input.textChanged.connect(self.filterData)
        self.filter_input.setStyleSheet("""
            LineEdit {
            /* 毛玻璃背景 */
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);           /* 毛玻璃模糊 */
            -webkit-backdrop-filter: blur(10px);   /* WebKit 兼容 */
            
            /* 半透明边框 */
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;                   /* 圆角 */
            
            /* 文字和图标颜色 */
            color: rgba(255, 255, 255, 0.9);
            padding: 12px 16px;                    /* 内边距 */
            font-size: 13px;
            min-height: 20px;
            
            /* 聚焦效果 */
        }
        LineEdit:focus {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(0, 120, 212, 0.5);
            color: white;
            box-shadow: 0 0 20px rgba(0, 120, 212, 0.2);  /* 聚焦发光 */
        }
        LineEdit::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* 光标样式 */
        LineEdit QCursor {
            color: rgba(255, 255, 255, 0.7);
        }
        """)
        control_layout.addWidget(self.filter_input)

        # 创建表格视图
        self.source_model = NetConnectionModel(self.headers)
        self.proxy_model = QSortFilterProxyModel(self)
        self.proxy_model.setSourceModel(self.source_model)
        self.proxy_model.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxy_model.setFilterKeyColumn(-1)  # 过滤所有列

        self.table_view = TableView(self)
        self.table_view.setModel(self.proxy_model)

        # 设置表格为透明
        self.table_view.setAttribute(Qt.WA_TranslucentBackground, True)
        self.table_view.viewport().setAttribute(Qt.WA_TranslucentBackground, True)

        # 表格透明样式
        self.table_view.setStyleSheet("""
            TableView {
        background: transparent;
        border: none;
        gridline-color: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.9);
        font-family: 'Consolas', 'SF Mono', monospace;
        font-size: 12px;
        selection-background-color: rgba(0, 120, 212, 0.3);
        selection-color: white;
        alternate-background-color: transparent;
        show-decoration-selected: 1;  /* 启用选中装饰 */
    }
    
    /* 关键：设置行间距 */
    TableView::item {
        padding: 8px 8px;           /* 单元格内边距 */
        margin: 2px 0;              /* 行间距：上下各2px */
        border: none;
        color: rgba(255, 255, 255, 0.8);
        background: transparent;    /* 确保透明 */
    }
    
    TableView::item:selected {
        background: rgba(0, 120, 212, 0.2);
        color: white;
        border: none;
        margin: 2px 0;              /* 选中状态也保持间距 */
    }
    
    TableView::item:hover {
        background: rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.9);
        margin: 2px 0;
    }
    
    TableView::pane {
        border: none;
        background: transparent;
        margin: 0;
    }
    
    /* 表头样式 */
    QHeaderView::section {
        background: transparent;
        border: none;
        padding: 10px 8px;
        color: rgba(255, 255, 255, 0.9);
        font-weight: 600;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        margin: 0;
    }
        """)

        # 表头透明样式
        self.table_view.horizontalHeader().setStyleSheet("""
            QHeaderView::section {
                background: transparent;
                border: none;
                padding: 8px;
                color: rgba(255, 255, 255, 0.9);
                font-weight: 600;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            QHeaderView::section:hover {
                background: rgba(255, 255, 255, 0.05);
            }
            QHeaderView::section:selected {
                background: rgba(0, 120, 212, 0.2);
            }
        """)

        # 设置表格属性
        self.table_view.setBorderVisible(False)
        self.table_view.setBorderRadius(0)
        self.table_view.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.table_view.setAlternatingRowColors(False)  # 移除交替颜色
        self.table_view.setSortingEnabled(True)
        self.table_view.verticalHeader().setVisible(False)
        self.table_view.verticalHeader().setDefaultSectionSize(0)

        # 设置列宽
        header = self.table_view.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)  # 进程名自适应
        header.resizeSection(1, 80)   # PID
        header.resizeSection(2, 100)  # 本地端口
        header.resizeSection(3, 120)  # 本地IP
        header.resizeSection(4, 100)  # 远程端口
        header.resizeSection(5, 100)  # 连接数
        header.resizeSection(6, 200)  # 上传/下载

        # 添加到布局
        layout.addLayout(control_layout)
        layout.addWidget(self.table_view, 1)

        # 设置整体布局透明
        self.setStyleSheet("background: transparent;")

    def generateSampleData(self):
        """生成示例数据"""
        processes = [
            "chrome.exe", "firefox.exe", "explorer.exe", "svchost.exe",
            "python.exe", "code.exe", "steam.exe", "discord.exe",
            "spotify.exe", "notepad.exe", "taskmgr.exe", "msedge.exe"
        ]

        sample_data = []
        for i in range(20):
            process = random.choice(processes)
            pid = random.randint(1000, 8000)
            local_port = random.randint(1000, 65535)
            remote_port = random.randint(1000, 65535)
            connections = random.randint(1, 50)

            # 随机生成上传下载数据
            upload = random.randint(100, 10000)
            download = random.randint(100, 50000)
            upload_download = f"{upload} KB / {download} KB"

            # 随机IP地址
            local_ip = f"192.168.1.{random.randint(1, 254)}"
            remote_ip = f"{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}"

            sample_data.append({
                "Process Name": process,
                "PID": pid,
                "Local Port": local_port,
                "Local IP": local_ip,
                "Remote Port": remote_port,
                "Connections": connections,
                "Upload/Download": upload_download
            })

        # 更新表格数据
        self.source_model.updateData(sample_data)

    def filterData(self, text):
        """根据输入文本过滤数据"""
        self.proxy_model.setFilterRegExp(text)

    def sortData(self, text):
        """根据选择排序数据"""
        col = -1
        order = Qt.AscendingOrder

        if text == self.tr("Sort by PID"):
            col = 1
        elif text == self.tr("Sort by Process Name"):
            col = 0
        elif text == self.tr("Sort by Connections"):
            col = 5
            order = Qt.DescendingOrder  # 默认降序

        if col >= 0:
            self.proxy_model.sort(col, order)

    def convert_connections_for_api(self, connections):
        api_data = []
        for conn in connections:
            api_item = {
                "Process Name": conn.get("name", ""),
                "PID": conn.get("pid", 0),
                "Local Port": conn.get("local_port", 0),
                "Local IP": conn.get("local_ip", ""),
                "Remote Port": conn.get("remote_port", 0),
                "Connections": conn.get("connections", 0),
                "Upload/Download": f"{conn.get('upload_kbps', 0)} KB / {conn.get('download_kbps', 0)} KB"
            }
            api_data.append(api_item)
        return api_data

    def updateProcessData(self, process_data):
        """
        提供给外部调用的接口，用于更新进程数据

        Args:
            process_data: 字典列表，每个字典包含进程信息
                Example:
                [
                    {
                        "Process Name": "chrome.exe",
                        "PID": 1234,
                        "Local Port": 8080,
                        "Local IP": "192.168.1.10",
                        "Remote Port": 443,
                        "Connections": 5,
                        "Upload/Download": "100 KB / 500 KB"
                    },
                    ...
                ]
        """
        self.source_model.updateData(
            self.convert_connections_for_api(process_data))
</file>

<file path="widgets/network_widget.py">
from PyQt5.QtCore import pyqtSignal, Qt
from PyQt5.QtWidgets import QVBoxLayout, QLabel, QHBoxLayout
from qfluentwidgets import CardWidget
import pyqtgraph as pg


class NetMonitor(CardWidget):
    clicked = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("netMonitor")
        self.setMaximumHeight(120)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)

        # 创建绘图区域
        self.plot_widget = pg.PlotWidget()
        self.plot_widget.showGrid(x=True, y=True, alpha=0.3)
        self.plot_widget.setBackground(None)
        self.plot_widget.setAttribute(Qt.WA_TranslucentBackground, True)
        self.plot_widget.setStyleSheet(
            "background: transparent; border: none;")
        self.plot_widget.setYRange(0, 25000)
        self.plot_widget.setXRange(0, 50)

        # 隐藏坐标值（保留轴线）
        for axis in ("bottom", "left", "right", "top"):
            ax = self.plot_widget.getAxis(axis)
            ax.setTicks([])
            ax.setStyle(showValues=False)

        self.plot_widget.setMenuEnabled(False)
        self.plot_widget.setMouseEnabled(x=False, y=False)

        self.upload_curve = self.plot_widget.plot(
            pen=pg.mkPen("#e67e22", width=2)
        )
        self.download_curve = self.plot_widget.plot(
            pen=pg.mkPen("#27ae60", width=2)
        )

        layout.addWidget(self.plot_widget)

        # ✅ 底部增加速率标签
        label_layout = QHBoxLayout()
        self.upload_label = QLabel("↑ 0 KB/s")
        self.download_label = QLabel("↓ 0 KB/s")

        # 样式（你可以改颜色）
        self.upload_label.setStyleSheet("color:#e67e22; font-weight:bold;")
        self.download_label.setStyleSheet("color:#27ae60; font-weight:bold;")

        label_layout.addWidget(self.upload_label)
        label_layout.addStretch()
        label_layout.addWidget(self.download_label)
        layout.addLayout(label_layout)

        self.upload_data, self.download_data = [], []
        self.max_points = 50

    def update_speed(self, upload_kbps: float, download_kbps: float):
        """
        外部 API 调用：更新上传和下载速率 (单位 KB/s)
        自动刷新曲线和标签
        """
        self.upload_data.append(upload_kbps)
        self.download_data.append(download_kbps)

        if len(self.upload_data) > self.max_points:
            self.upload_data.pop(0)
            self.download_data.pop(0)

        x = list(range(len(self.upload_data)))
        if self.upload_curve:
            self.upload_curve.setData(x, self.upload_data)
            self.download_curve.setData(x, self.download_data)

            # 更新标签
            self.upload_label.setText(f"↑ {self.format_speed(upload_kbps)}")
            self.download_label.setText(
                f"↓ {self.format_speed(download_kbps)}")

            # 强制刷新绘图
            self.plot_widget.update()
            self.plot_widget.repaint()

    def format_speed(self, value: float) -> str:
        """根据 KB/s 数值自动选择单位显示"""
        if value >= 1_000_000:  # GB/s
            return f"{value / 1_000_000:.2f} GB/s"
        elif value >= 1_000:  # MB/s
            return f"{value / 1_000:.2f} MB/s"
        else:  # KB/s
            return f"{value:.1f} KB/s"

    def mousePressEvent(self, event):
        self.clicked.emit()
        super().mousePressEvent(event)
</file>

<file path="widgets/session_dialog.py">
from PyQt5.QtWidgets import QHBoxLayout, QLabel, QFileDialog, QWidget
from qfluentwidgets import LineEdit, ComboBox, SubtitleLabel, MessageBoxBase, PushButton, InfoBar, InfoBarPosition, PasswordLineEdit
from PyQt5.QtCore import Qt, QDir


class SessionDialog(MessageBoxBase):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._font = getattr(parent, "fonts", None)
        # print(self._font)
        self.titleLabel = SubtitleLabel(self.tr('New SSH Session'))
        if self._font:
            self.titleLabel.setFont(self._font)
        self.yesButton.setText(self.tr("Save"))
        self.cancelButton.setText(self.tr("Cancel"))

        self.session_name = LineEdit()
        self.username = LineEdit()
        self.host = LineEdit()
        self.port = LineEdit()
        self.auth_combo = ComboBox()
        self.password = PasswordLineEdit()
        self.key_path = LineEdit()
        self.key_browse_btn = PushButton(self.tr("Browse..."))
        self.key_browse_btn.clicked.connect(self._browse_ssh_key)
        # for w in [self.session_name, self.username, self.host, self.port,
        #           self.auth_combo, self.password, self.key_path, self.key_browse_btn]:
        #     if self._font:
        #         w.setFont(self._font)

        # Session Name
        self.session_name.setPlaceholderText(self.tr("Enter session name"))
        session_name_layout = QHBoxLayout()
        session_name_layout.addWidget(QLabel(self.tr("Session Name:")))
        session_name_layout.addWidget(self.session_name)
        session_name_layout.setStretch(1, 1)

        # Username
        self.username.setPlaceholderText(self.tr("Enter username"))
        username_layout = QHBoxLayout()
        username_layout.addWidget(QLabel(self.tr("Username:")))
        username_layout.addWidget(self.username)
        username_layout.setStretch(1, 1)

        # Host
        self.host.setPlaceholderText(self.tr("e.g.: 192.168.1.100"))
        host_layout = QHBoxLayout()
        host_layout.addWidget(QLabel(self.tr("Host Address:")))
        host_layout.addWidget(self.host)
        host_layout.setStretch(1, 1)

        # Port
        self.port.setPlaceholderText(self.tr("Default: 22"))
        port_layout = QHBoxLayout()
        port_layout.addWidget(QLabel(self.tr("Port:")))
        port_layout.addWidget(self.port)
        port_layout.setStretch(1, 1)

        # Authentication method
        self.auth_combo.addItems(["Password", "Key"])
        self.auth_combo.currentIndexChanged.connect(self._on_auth_changed)
        auth_layout = QHBoxLayout()
        auth_layout.addWidget(QLabel(self.tr("Authentication Method:")))
        auth_layout.addWidget(self.auth_combo)
        auth_layout.setStretch(1, 1)

        # Password
        self.password.setPlaceholderText(self.tr("Enter password"))
        self.password.setEchoMode(LineEdit.Password)
        password_layout = QHBoxLayout()
        password_layout.addWidget(QLabel(self.tr("Password:")))
        password_layout.addWidget(self.password)
        password_layout.setStretch(1, 1)

        # key file
        self.key_path.setPlaceholderText(self.tr("Select private key file"))
        self.key_path.setReadOnly(True)
        key_layout = QHBoxLayout()
        key_layout.addWidget(QLabel(self.tr("Key File:")))
        key_layout.addWidget(self.key_path)
        key_layout.addWidget(self.key_browse_btn)
        key_layout.setStretch(1, 1)

        self.viewLayout.addWidget(self.titleLabel)
        self.viewLayout.addLayout(session_name_layout)
        self.viewLayout.addLayout(username_layout)
        self.viewLayout.addLayout(host_layout)
        self.viewLayout.addLayout(port_layout)
        self.viewLayout.addLayout(auth_layout)
        self.viewLayout.addLayout(password_layout)
        self.viewLayout.addLayout(key_layout)

        button_layout = QHBoxLayout()
        button_layout.addStretch()
        self.viewLayout.addLayout(button_layout)

        self.widget.setMinimumWidth(400)
        self._on_auth_changed(0)  # Initialize to password authentication

        self.set_font_recursive(self, self._font)

    def set_font_recursive(self, widget: QWidget, font):
        """
        Recursively set the font for a widget and all its children.
        """
        if font is None:
            return
        widget.setFont(font)
        for child in widget.findChildren(QWidget):
            child.setFont(font)

    def _on_auth_changed(self, index):
        if index == 0:  # Password
            self.password.setVisible(True)
            self.key_path.setVisible(False)
            self.key_browse_btn.setVisible(False)
        else:  # Key
            self.password.setVisible(False)
            self.key_path.setVisible(True)
            self.key_browse_btn.setVisible(True)

    def _browse_ssh_key(self):

        key_filters = (
            self.tr(
                "SSH Private Key Files (*.pem *.key ppk id_rsa id_dsa id_ecdsa id_ed25519);;")
            + self.tr("PEM Format (*.pem);;")
            + self.tr("KEY Format (*.key);;")
            + self.tr("PuTTY Format (*.ppk);;")
            + self.tr("OpenSSH Format (id_rsa id_dsa id_ecdsa id_ed25519);;")
            + self.tr("All Files (*.*)")
        )

        key_path, _ = QFileDialog.getOpenFileName(
            self,
            self.tr("Select SSH Private Key File"),
            QDir.homePath(),
            key_filters
        )

        if key_path:
            if self._validate_ssh_key_strict(key_path):
                self.key_path.setText(key_path)
            else:
                InfoBar.error(
                    title=self.tr('Creation Failed'),
                    content=self.tr("SSH private key validation failed"),
                    orient=Qt.Horizontal,
                    isClosable=True,
                    position=InfoBarPosition.TOP_RIGHT,
                    duration=10000,
                    parent=self
                )

    def _validate_ssh_key_strict(self, key_path):
        import os
        import re

        if not os.path.exists(key_path):
            return False

        try:
            with open(key_path, 'r', encoding='utf-8') as f:
                content = f.read(4096)

                # OpenSSH
                openssh_pattern = r'-----BEGIN OPENSSH PRIVATE KEY-----'
                if re.search(openssh_pattern, content):
                    return True

                # PEM
                pem_pattern = r'-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----'
                if re.search(pem_pattern, content):
                    return True

                # PKCS#8
                pkcs8_pattern = r'-----BEGIN PRIVATE KEY-----'
                if re.search(pkcs8_pattern, content):
                    return True

                # PuTTY
                putty_pattern = r'PuTTY-User-Key-File'
                if re.search(putty_pattern, content):
                    return True

                file_name = os.path.basename(key_path).lower()
                common_key_files = [
                    'id_rsa', 'id_dsa', 'id_ecdsa', 'id_ed25519']
                if file_name in common_key_files:
                    if content.strip() and not content.startswith('#'):
                        return True

        except Exception:
            return False

        return False
</file>

<file path="widgets/ssh_webterm.py">
# ssh_webterm.py
"""
Web-based terminal widget using xterm.js embedded in a QWebEngineView,
communicating via QWebChannel.

Features:
- Transparent/web-background-supporting terminal (best-effort; some Qt/Chromium builds
  may not support page transparency; a bg_color fallback is available).
- text_color parameter (foreground color).
- bg_color parameter (fallback background color when transparency isn't desirable).
- text_shadow parameter (boolean) to add subtle text shadow for readability.
- Dynamic theme update via set_colors().
- Bridge (TerminalBridge) relays bytes <-> base64 across the QWebChannel.

Usage:
    widget = WebTerminal(parent, cols=120, rows=30,
                         text_color="white", bg_color="#00000080", text_shadow=True)
    widget.set_worker(ssh_worker)
    # To update colors later:
    widget.set_colors(text_color="#00ffcc",
                      bg_color="rgba(0,0,0,0.6)", text_shadow=False)
"""
import base64
import json
from PyQt5.QtCore import Qt, QObject, pyqtSignal, pyqtSlot, QUrl
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QSizePolicy, QHBoxLayout, QApplication
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtWebChannel import QWebChannel
import PyQt5.QtCore as qc
from tools.setting_config import SCM
import re
import os
from PyQt5.QtWidgets import QShortcut
from PyQt5.QtGui import QKeySequence
print("QT_VERSION:", qc.QT_VERSION_STR, "PYQT:", qc.PYQT_VERSION_STR)

configer = SCM()
config = configer.read_config()
_ansi_csi_re = re.compile(r'\x1b\[[0-9;?]*[ -/]*[@-~]')
_ansi_esc_re = re.compile(r'\x1b.[@-~]?')


def _strip_ansi_sequences(s: str) -> str:
    """移除常见的 ESC/CSI 控制序列（方向键、功能键等）"""
    s = _ansi_csi_re.sub('', s)
    s = _ansi_esc_re.sub('', s)
    return s


class TerminalBridge(QObject):
    """
    Bridge object exposed to JavaScript via QWebChannel.

    Signals:
        output(str) : emits base64-encoded bytes from SSHWorker to JS.
        ready() : emits when frontend is ready.
        scrollPositionChanged(int) : emits scroll position from JS to Python.
        directoryChanged(str) : emits directory change events.
    """
    output = pyqtSignal(str)
    ready = pyqtSignal()
    directoryChanged = pyqtSignal(str)

    def __init__(self, parent=None, user_name=None, home_path=None):
        super().__init__(parent)
        self.worker = None
        self.current_directory = "/"
        self._input_buffer = ""  # 用户输入缓冲
        self.username = user_name
        # self.home_path = home_path
        # print(home_path)

    def set_worker(self, worker):
        """Attach an SSHWorker. The worker must emit bytes via result_ready signal."""
        if self.worker is not None:
            try:
                self.worker.result_ready.disconnect(self._on_worker_output)
            except Exception:
                pass
        self.worker = worker
        if worker:
            worker.result_ready.connect(self._on_worker_output)

    def _process_user_input(self, data: bytes):
        """
        处理用户输入：
         - 识别退格、Ctrl+U、Ctrl+W
         - 忽略常见 ESC/CSI 序列
         - 遇到回车时提交命令
        """
        try:
            text = data.decode('utf-8', errors='ignore')
            text = _strip_ansi_sequences(text)

            buf_chars = list(self._input_buffer)
            i = 0
            L = len(text)
            while i < L:
                ch = text[i]

                # 退格
                if ch == '\x08' or ch == '\x7f':
                    if buf_chars:
                        buf_chars.pop()
                    i += 1
                    continue

                # Ctrl+U 清行
                if ch == '\x15':
                    buf_chars = []
                    i += 1
                    continue

                # Ctrl+W 删除上一个单词
                if ch == '\x17':
                    while buf_chars and buf_chars[-1].isspace():
                        buf_chars.pop()
                    while buf_chars and not buf_chars[-1].isspace():
                        buf_chars.pop()
                    i += 1
                    continue

                # 回车或换行
                if ch == '\r' or ch == '\n':
                    cmd = ''.join(buf_chars).strip()
                    if cmd:
                        self._process_command(cmd)
                    buf_chars = []
                    while i < L and (text[i] == '\r' or text[i] == '\n'):
                        i += 1
                    continue

                # 普通字符追加
                buf_chars.append(ch)
                i += 1

            self._input_buffer = ''.join(buf_chars)

        except Exception as e:
            print(f"处理用户输入时出错: {e}")
            self._input_buffer = ""

    def _process_command(self, command: str):
        """
        只在完整命令提交（按回车）时调用。
        支持 cd <dir>、cd、cd ~、cd ~/subdir 等。
        """
        try:
            parts = command.split()
            if not parts:
                return

            if parts[0] == 'cd':
                target_dir = '~' if len(parts) == 1 else parts[1]
                username = self.username
                # 波浪符展开
                if target_dir == '~':
                    if username == 'root':
                        target_dir = '/root'
                    else:
                        target_dir = f'/home/{username}' if username else '/home/user'
                elif target_dir.startswith('~/'):
                    if username == 'root':
                        target_dir = target_dir.replace('~', '/root', 1)
                    else:
                        target_dir = target_dir.replace(
                            '~', f'/home/{username}' if username else '/home/user', 1)
                # 相对路径处理
                if not target_dir.startswith('/'):
                    base = self.current_directory.rstrip('/')
                    base = '/' if base == '' else base
                    candidate = base + '/' + \
                        target_dir if not base.endswith(
                            '/') else base + target_dir
                else:
                    candidate = target_dir

                # 规范化路径
                candidate = os.path.normpath(candidate).replace('\\', '/')

                if candidate != self.current_directory:
                    self.current_directory = candidate
                    self.directoryChanged.emit(candidate)

        except Exception as e:
            print(f"_process_command error: {e}")

    def _on_worker_output(self, chunk: bytes):
        """Encode bytes -> base64 and emit to JS."""
        try:
            b64 = base64.b64encode(chunk).decode("ascii")
            self.output.emit(b64)
        except Exception as e:
            print(f"处理输出时出错: {e}")

    @pyqtSlot(str)
    def sendInput(self, b64: str):
        """JS -> Python: base64-encoded user input"""
        if not self.worker:
            return
        try:
            data = base64.b64decode(b64)
            # print("接收到:", data.decode("utf-8", errors="ignore"))
            self._process_user_input(data)
            self.worker.run_command(data, add_newline=False)
        except Exception as e:
            print("TerminalBridge.sendInput error:", e)

    @pyqtSlot(int, int)
    def resize(self, cols: int, rows: int):
        """JS -> Python: terminal size change"""
        if not self.worker:
            return
        try:
            self.worker.resize_pty(cols, rows)
        except Exception as e:
            print("TerminalBridge.resize error:", e)

    @pyqtSlot()
    def notifyReady(self):
        self.ready.emit()

    @pyqtSlot(str)
    def copyToClipboard(self, text):
        QApplication.clipboard().setText(text)


class WebTerminal(QWidget):
    """
    Web terminal widget embedding xterm.js in a QWebEngineView.

    Parameters:
      parent: parent widget
      cols, rows: initial terminal size (cols, rows)
      text_color: CSS color for foreground text (e.g., "white" or "#fff")
      bg_color: CSS color fallback for background (e.g., "#000000" or "rgba(0,0,0,0.6)")
      text_shadow: boolean, whether to add a subtle text shadow for improve readability
    """
    directoryChanged = pyqtSignal(str)

    def __init__(self, parent=None, cols=120, rows=30, text_color="white", bg_color="transparent", text_shadow=False, font_name=None, user_name=None, devmode=False):
        super().__init__(parent)
        self._rows = int(rows)
        self._cols = cols
        # Means not set color
        if text_color == "white":
            self._text_color = text_color
            # config = configer.read_config()
            # self._text_color = config["ssh_widget_text_color"]
            # print(self._text_color)
        else:
            self._text_color = text_color
        # self._text_color = text_color or "white"
        self._bg_color = bg_color or "transparent"
        self._text_shadow = bool(text_shadow)
        self._scroll_position = 0
        self._max_scroll = 1000
        print(font_name)
        self._font_family = font_name or "monospace"

        # 确保整个 widget 透明
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        self.setStyleSheet("background: transparent; border: none;")

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)

        # 创建水平布局用于放置终端和自定义滚动条
        self.terminal_layout = QHBoxLayout()
        self.terminal_layout.setContentsMargins(0, 0, 0, 0)
        self.terminal_layout.setSpacing(0)

        # QWebEngineView setup
        self.view = QWebEngineView(self)

        self.view.setAttribute(Qt.WA_TranslucentBackground, True)
        self.view.setStyleSheet("""
            QWebEngineView {
                background: transparent;
                border: none;
            }
            QWebEngineView::scroll-bar:vertical {
                width: 0px;
            }
            QWebEngineView::scroll-bar:horizontal {
                height: 0px;
            }
        """)

        self.view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        self.terminal_layout.addWidget(self.view, 1)
        self.main_layout.addLayout(self.terminal_layout)

        try:
            self.view.page().setBackgroundColor(QColor(0, 0, 0, 0))
        except Exception as e:
            print("Warning: could not set page background transparent:", e)

        # WebChannel + Bridge
        self.channel = QWebChannel(self.view.page())
        print(f"User name {user_name}")
        self.bridge = TerminalBridge(self, user_name=user_name)
        self.bridge.directoryChanged.connect(self._on_directory_changed)
        self.channel.registerObject("bridge", self.bridge)
        self.view.page().setWebChannel(self.channel)

        if devmode:
            self._open_dev_mode()

        self.hide_scrollbars_js = """
        const style = document.createElement('style');
        style.innerHTML = `
            ::-webkit-scrollbar {
                display: none !important;
                width: 0 !important;
                height: 0 !important;
            }
            * {
                scrollbar-width: none !important;
                -ms-overflow-style: none !important;
            }
        `;
        document.head.appendChild(style);
        """

        # Load HTML
        html = self._build_html()
        self.view.setHtml(html, QUrl("qrc:///"))

        self.view.page().loadFinished.connect(self._on_page_loaded)

        self.terminal_texts = ""
        self._terminal_texts_max = 1500
        if config["aigc_open"]:
            try:
                self.bridge.output.connect(self._on_bridge_output)
            except Exception:
                pass

    def _open_dev_mode(self):
        self.devtools = QWebEngineView()
        self.devtools.setWindowTitle("DevTools")
        self.devtools.resize(900, 700)
        self.view.page().setDevToolsPage(self.devtools.page())

        shortcut = QShortcut(QKeySequence("Ctrl+Shift+I"), self)
        shortcut.activated.connect(self._toggle_devtools)

    def _toggle_devtools(self):
        if self.devtools.isVisible():
            self.devtools.hide()
        else:
            self.devtools.show()
            self.devtools.raise_()
            self.devtools.activateWindow()

    def _on_directory_changed(self, new_dir):
        if config["follow_cd"]:
            self.directoryChanged.emit(new_dir)

    def _set_font(self, font_name):
        """
        设置终端内显示的字体

        Args:
            font_name: 系统已安装的字体名称
        """

        self._font_family = font_name or "monospace"
        self._update_font_in_html()
        self._force_rerender()

    def _force_rerender(self):
        """强制终端重新渲染"""
        rerender_js = """
        const term = window.term;
        if (term) {
            const text = term.getSelection() || term.getText();
            term.clear();
            term.write(text);
        }
        """
        self.view.page().runJavaScript(rerender_js)

    def _update_font_in_html(self):
        """更新 HTML 中的字体设置"""
        font_js = f"""
      // 更新终端字体
      const terminal = document.getElementById('terminal');
      if (terminal) {{
          terminal.style.fontFamily = '{self._font_family}, monospace !important';
          terminal.style.letterSpacing = 'normal !important';
      }}
      
      // 更新 xterm 字体
      const xtermElements = document.querySelectorAll('.xterm, .xterm *');
      xtermElements.forEach(element => {{
          element.style.fontFamily = '{self._font_family}, monospace !important';
          element.style.letterSpacing = 'normal !important';
      }});
      """
        self.view.page().runJavaScript(font_js)

    def _on_page_loaded(self):
        """页面加载完成后的回调函数，用于调试透明度和隐藏滚动条"""
        def check_bg_color(color):
            print(f"Page background color: {color}")

        def check_body_bg(color):
            print(f"Body background color: {color}")

        def check_terminal_bg(color):
            print(f"Terminal div background color: {color}")

        # 检查各种元素的背景色
        self.view.page().runJavaScript(
            "window.getComputedStyle(document.body).backgroundColor",
            check_body_bg
        )

        self.view.page().runJavaScript(
            "window.getComputedStyle(document.getElementById('terminal')).backgroundColor",
            check_terminal_bg
        )

        # 检查页面背景色
        bg_color = self.view.page().backgroundColor()
        print(
            f"QWebEnginePage background color: {bg_color.name(QColor.HexArgb)}")

        # 隐藏原生滚动条
        self.view.page().runJavaScript(self.hide_scrollbars_js)

    def _html_escape(self, s: str) -> str:
        return json.dumps(s)

    def _build_html(self) -> str:
        """
        Return the HTML string used as the web page for the terminal.
        """
        try:
            # 获取当前脚本所在的目录
            current_dir = os.path.dirname(os.path.abspath(__file__))
            # 拼接正确的模板文件路径
            tpl_path = os.path.join(
                current_dir, '..', 'resource', 'tpl', 'terminal.tpl')

            with open(tpl_path, 'r', encoding='utf-8') as f:
                tpl = f.read()
        except Exception as e:
            print(f"Error loading terminal.html: {e}")
            return f"<html><body><h1>Error loading template</h1><p>{e}</p></body></html>"

        # JSON-encoded strings for safe embedding in JS
        fg_js = self._html_escape(self._text_color)
        bg_js = self._html_escape(self._bg_color)
        shadow_bool = "true" if self._text_shadow else "false"

        # Replace placeholders in the template
        final = tpl.replace("{{rows}}", str(self._rows))
        final = final.replace("{{cols}}", str(self._cols))
        final = final.replace("{{fg}}", fg_js)
        final = final.replace("{{bg}}", bg_js)
        final = final.replace("{{shadow}}", shadow_bool)
        final = final.replace("{{bg_css}}", self._bg_color)
        final = final.replace("{{font_family}}", self._font_family)

        return final

    def set_worker(self, worker):
        """Attach SSHWorker to the bridge and notify it of current pty size."""
        self.bridge.set_worker(worker)
        try:
            worker.resize_pty(self._cols, self._rows)
        except Exception:
            pass

    def set_colors(self, text_color=None, bg_color=None, text_shadow=None):
        """
        Dynamically update terminal colors.
        Parameters accept CSS color strings:
          text_color: e.g. "white" or "#00ffcc"
          bg_color: fallback background (used as CSS variable), e.g. "rgba(0,0,0,0.6)"
          text_shadow: boolean
        """
        if text_color is not None:
            self._text_color = text_color
        if bg_color is not None:
            self._bg_color = bg_color
        if text_shadow is not None:
            self._text_shadow = bool(text_shadow)

        # Call JS function to update theme; serialize strings safely via json.dumps
        fg_js = json.dumps(self._text_color)
        bg_js = json.dumps(self._bg_color)
        shadow_js = "true" if self._text_shadow else "false"
        js = f"if (window.setTerminalTheme) window.setTerminalTheme({fg_js}, {bg_js}, {shadow_js});"
        try:
            self.view.page().runJavaScript(js)
        except Exception as e:
            print("set_colors runJavaScript error:", e)

    def resizeEvent(self, event):
        """
        Optionally, we rely on the front-end's window.resize event and fitAddon to call
        bridge.resize. Still, we keep this hook in case additional Python-side logic is desired.
        """
        super().resizeEvent(event)
        # No explicit action here; JS side handles sizing via fitAddon and window resize listener.

    # Prevent all drag operations

    def dragEnterEvent(self, event):
        event.ignore()

    def dropEvent(self, event):
        event.ignore()

    def clear_screen(self):
        """Clears the terminal screen."""
        js = "if (window.term) window.term.clear();"
        try:
            self.view.page().runJavaScript(js)
        except Exception as e:
            print("clear_screen runJavaScript error:", e)

    def send_command(self, command: str):
        """Sends a string command to the terminal."""
        try:
            # The bridge's sendInput expects base64
            b64 = base64.b64encode(command.encode('utf-8')).decode('ascii')
            self.bridge.sendInput(b64)
        except Exception as e:
            print("send_command error:", e)

    def fit_terminal(self):
        """Triggers the fit addon in the browser to resize the terminal."""
        js = "if (typeof notifySize === 'function') notifySize();"
        try:
            self.view.page().runJavaScript(js)
        except Exception as e:
            print("fit_terminal runJavaScript error:", e)

    def cleanup(self):
        """
        安全清理 WebTerminal：
        - 注销 TerminalBridge 的信号
        - 清理 QWebEngineView
        - 断开 worker
        - 删除子控件
        """
        # 1️⃣ 断开 bridge 的信号
        try:
            self.bridge.directoryChanged.disconnect()
        except Exception:
            pass
        try:
            self.terminal_texts = ""
        except Exception:
            pass
        # 2️⃣ 注销 worker
        if self.bridge.worker:
            try:
                self.bridge.worker.result_ready.disconnect(
                    self.bridge._on_worker_output)
            except Exception:
                pass
            self.bridge.worker = None

        # 3️⃣ 清空输入缓冲
        self.bridge._input_buffer = ""
        self.bridge.current_directory = "/"

        # 4️⃣ 清理 QWebEngineView
        if hasattr(self, 'view') and self.view:
            try:
                self.view.page().setWebChannel(None)
                self.view.setParent(None)
                self.view.deleteLater()
            except Exception:
                pass
            self.view = None

        # 5️⃣ 删除主布局里的所有 item
        if hasattr(self, 'main_layout') and self.main_layout:
            while self.main_layout.count():
                item = self.main_layout.takeAt(0)
                w = item.widget()
                if w:
                    w.setParent(None)
                    w.deleteLater()
            self.main_layout = None

        # 6️⃣ 从父控件中移除自己
        parent_layout = self.parentWidget().layout() if self.parentWidget() else None
        if parent_layout:
            parent_layout.removeWidget(self)
        self.setParent(None)

    def _on_bridge_output(self, b64: str):
        """
        Slot connected to TerminalBridge.output (base64-encoded bytes).
        Decode -> strip ANSI -> append to self.terminal_texts, trimming from head if needed.
        """
        try:
            # decode base64 -> bytes -> text
            chunk_bytes = base64.b64decode(b64)
            text = chunk_bytes.decode('utf-8', errors='ignore')
            # strip ANSI sequences to keep plain terminal text (optional but usually desired)
            plain = _strip_ansi_sequences(text)

            # append and trim to max length (keep newest chars)
            self.terminal_texts += plain
            if len(self.terminal_texts) > self._terminal_texts_max:
                # keep the last _terminal_texts_max characters
                self.terminal_texts = self.terminal_texts[-self._terminal_texts_max:]

        except Exception as e:
            # Don't crash the app for logging reasons; print for debug
            print(f"_on_bridge_output error: {e}")

    def execute_command_and_capture(self, command: str):
        if self.bridge and self.bridge.worker:
            self.bridge.worker.execute_command_and_capture(command)
</file>

<file path="widgets/sync_widget.py">
from PyQt5.QtWidgets import QHBoxLayout, QLabel, QWidget
from qfluentwidgets import LineEdit, SubtitleLabel, MessageBoxBase,  PasswordLineEdit, PushButton
from tools.font_config import font_config
import requests
import os
from requests.adapters import HTTPAdapter
import ssl
import zipfile
from pathlib import Path
from PyQt5.QtCore import pyqtSignal
BASE_URL = "https://sync_setting.beefuny.shop"


class HostnameIgnoreAdapter(HTTPAdapter):
    def init_poolmanager(self, *args, **kwargs):
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        kwargs['ssl_context'] = ctx
        return super().init_poolmanager(*args, **kwargs)


def upload_zip(username: str, password: str, zip_path: str):
    """
    Upload a ZIP file to the server.
    Returns dict: {"status": "created/updated", "message": str} 或 {"status": "error", "message": str}
    """
    if not os.path.isfile(zip_path):
        return {"status": "error", "message": f"File not found: {zip_path}"}

    url = f"{BASE_URL}/upload"
    s = requests.Session()
    s.mount("https://", HostnameIgnoreAdapter())
    try:
        with open(zip_path, "rb") as f:
            files = {"zipfile": (os.path.basename(
                zip_path), f, "application/zip")}
            data = {"username": username, "password": password}

            try:
                r = s.post(url, data=data, files=files, timeout=10)
            except requests.exceptions.RequestException as e:
                return {"status": "error", "message": f"Request failed: {str(e)}"}

            try:
                result = r.json()
                return {"status": result.get("status", "error"), "message": str(result)}
            except Exception:
                return {"status": "error", "message": r.text}

    except Exception as e:
        return {"status": "error", "message": f"Unexpected error: {str(e)}"}


def download_zip(username: str, password: str, output_path: str):
    """
    Download a ZIP file from the server.
    Returns dict: {"status": "success", "message": saved_path} 或 {"status": "error", "message": str}
    """
    url = f"{BASE_URL}/download"
    payload = {"username": username, "password": password}
    s = requests.Session()
    s.mount("https://", HostnameIgnoreAdapter())
    try:
        try:
            r = s.post(url, json=payload, timeout=10)
        except requests.exceptions.RequestException as e:
            return {"status": "error", "message": f"Request failed: {str(e)}"}

        content_type = r.headers.get("Content-Type", "")
        if content_type == "application/zip":
            try:
                with open(output_path, "wb") as f:
                    f.write(r.content)
                return {"status": "success", "message": output_path}
            except Exception as e:
                return {"status": "error", "message": f"Write failed: {str(e)}"}
        else:
            try:
                result = r.json()
                return {"status": "error", "message": str(result)}
            except Exception:
                return {"status": "error", "message": r.text}

    except Exception as e:
        return {"status": "error", "message": f"Unexpected error: {str(e)}"}


class SycnWidget(MessageBoxBase):

    sync_finished = pyqtSignal(str, str)  # status, message

    def __init__(self, parent=None):
        super().__init__(parent)
        font_ = font_config()
        self._font = font_.get_font()

        self.sync_mode = "sync_up"  # or "sync_dl"

        self.titleLabel = SubtitleLabel(self.tr('Sycn Settings'))
        self.yesButton.setText(self.tr("Sycn"))
        self.yesButton.clicked.connect(lambda: self._sync())
        self.cancelButton.setText(self.tr("Cancel"))

        self.username = LineEdit()
        self.password = PasswordLineEdit()

        username_layout = QHBoxLayout()
        username_layout.addWidget(QLabel(self.tr("Username:")))
        username_layout.addWidget(self.username)

        password_layout = QHBoxLayout()
        password_layout.addWidget(QLabel(self.tr("Password:")))
        password_layout.addWidget(self.password)

        self.modeButton = PushButton(f"Mode: {self.sync_mode}")
        self.modeButton.clicked.connect(self.toggle_mode)

        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(self.modeButton)

        self.viewLayout.addWidget(self.titleLabel)
        self.viewLayout.addLayout(username_layout)
        self.viewLayout.addLayout(password_layout)
        self.viewLayout.addLayout(button_layout)

        self.widget.setMinimumWidth(400)
        self.set_font_recursive(self, self._font)

    def toggle_mode(self):
        """切换模式"""
        self.sync_mode = "sync_dl" if self.sync_mode == "sync_up" else "sync_up"
        self.modeButton.setText(f"Mode: {self.sync_mode}")
        print(f"Switched to mode: {self.sync_mode}")

    def set_font_recursive(self, widget: QWidget, font):
        if font is None:
            return
        widget.setFont(font)
        for child in widget.findChildren(QWidget):
            child.setFont(font)

    def _compression_to_zip(self, source_dir, zip_path=".config.zip"):
        """Compress the source_dir into a zip file at zip_path"""
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(source_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, source_dir)
                    zipf.write(file_path, arcname)

    def _sync(self):
        username = self.username.text().strip()
        password = self.password.text().strip()
        if not username or not password:
            return {"status": "error", "message": "Username and password cannot be empty."}

        config_dir = Path.home() / ".config"
        # print(username, password, self.sync_mode, config_dir)
        if self.sync_mode == "sync_up":
            self._compression_to_zip(config_dir, ".config.zip")
            result = upload_zip(username, password, ".config.zip")
            if os.path.exists(".config.zip"):
                os.remove(".config.zip")
            if result["status"] in ["created", "updated"]:
                self.sync_finished.emit("success", self.tr(
                    "Settings uploaded successfully!"))
            else:
                self.sync_finished.emit("error", self.tr(
                    f"Upload failed: {result['message']}"))

        else:  # sync_dl
            result = download_zip(username, password, ".config.zip")
            if result["status"] == "success":
                try:
                    with zipfile.ZipFile(".config.zip", 'r') as zipf:
                        zipf.extractall(config_dir)
                    self.sync_finished.emit("success", self.tr(
                        "Settings downloaded and applied successfully! Please restart the application."))
                except Exception as e:
                    self.sync_finished.emit("error", self.tr(
                        f"Extraction failed: {str(e)}"))
                finally:
                    if os.path.exists(".config.zip"):
                        os.remove(".config.zip")
            else:
                self.sync_finished.emit("error", self.tr(
                    f"Download failed: {result['message']}"))
</file>

<file path="widgets/system_resources_widget.py">
from PyQt5.QtCore import Qt, QRectF,  pyqtSignal
from PyQt5.QtGui import QPainter, QColor, QBrush, QLinearGradient, QFont,  QPen
from PyQt5.QtWidgets import QFrame


class ProcessTable(QFrame):
    fontChanged = pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setStyleSheet("""
            ProcessTable {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(30, 30, 40, 180), 
                    stop:1 rgba(20, 20, 30, 200));
                border: 1px solid rgba(255, 255, 255, 60);
                border-radius: 12px;
            }
        """)
        self.setMinimumHeight(120)
        self.setMinimumWidth(300)

        self.progress = {'cpu': 0.0, 'ram': 0.0}

        self._font_family = "Segoe UI"
        self._font_size = 10
        self._font_bold = True

        self.colors = {
            'cpu': {
                'gradient_start': QColor(100, 200, 255),    # 蓝色系
                'gradient_end': QColor(50, 120, 220),
                'text': QColor(200, 230, 255)
            },
            'ram': {
                'gradient_start': QColor(255, 100, 150),    # 粉色系
                'gradient_end': QColor(220, 60, 120),
                'text': QColor(255, 200, 220)
            }
        }

    def set_font_family(self, font_family: str):
        """设置字体族"""
        if font_family and font_family != self._font_family:
            self._font_family = font_family
            self.fontChanged.emit(font_family)
            self.update()

    def set_font_size(self, size: int):
        """设置字体大小"""
        if 8 <= size <= 20 and size != self._font_size:
            self._font_size = size
            self.update()

    def set_font_bold(self, bold: bool):
        """设置字体是否粗体"""
        if bold != self._font_bold:
            self._font_bold = bold
            self.update()

    def set_progress(self, type_str: str, percent: float):
        """设置进度值"""
        if type_str not in self.progress:
            return
        p = max(0.0, min(100.0, float(percent)))
        if abs(self.progress[type_str] - p) > 0.1:
            self.progress[type_str] = p
            self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # 绘制背景阴影效果
        self._draw_shadow(painter)

        total_width = self.width() - 40
        total_height = self.height() - 30
        rect_height = (total_height - 10) / 2

        rects = {
            'cpu': QRectF(20, 15, total_width, rect_height),
            'ram': QRectF(20, 20 + rect_height, total_width, rect_height)
        }

        for name, rect in rects.items():
            self._draw_progress_bar(painter, name, rect)

    def _draw_shadow(self, painter):
        """绘制阴影效果"""
        shadow_rect = QRectF(2, 2, self.width() - 4, self.height() - 4)
        painter.setPen(Qt.NoPen)
        painter.setBrush(QColor(0, 0, 0, 80))
        painter.drawRoundedRect(shadow_rect, 10, 10)

    def _draw_progress_bar(self, painter, name, rect):
        """绘制单个进度条"""
        bg_rect = QRectF(rect.x(), rect.y(), rect.width(), rect.height())
        painter.setPen(QPen(QColor(255, 255, 255, 30), 1))
        painter.setBrush(QColor(50, 50, 60, 150))
        painter.drawRoundedRect(bg_rect, 8, 8)

        if self.progress[name] > 0:
            fill_width = max(10, rect.width() * self.progress[name] / 100.0)
            fill_rect = QRectF(rect.left() + 2, rect.top() + 2,
                               fill_width - 4, rect.height() - 4)

            # 创建渐变
            grad = QLinearGradient(fill_rect.topLeft(), fill_rect.topRight())
            colors = self.colors[name]
            grad.setColorAt(0, colors['gradient_start'])
            grad.setColorAt(0.7, colors['gradient_end'])
            grad.setColorAt(1, colors['gradient_end'].darker(120))

            painter.setBrush(QBrush(grad))
            painter.setPen(Qt.NoPen)
            painter.drawRoundedRect(fill_rect, 6, 6)

            if fill_width > 20:
                highlight_rect = QRectF(fill_rect.left(), fill_rect.top(),
                                        fill_rect.width(), fill_rect.height() * 0.3)
                highlight_grad = QLinearGradient(
                    highlight_rect.topLeft(), highlight_rect.bottomLeft())
                highlight_grad.setColorAt(0, QColor(255, 255, 255, 80))
                highlight_grad.setColorAt(1, QColor(255, 255, 255, 0))
                painter.setBrush(QBrush(highlight_grad))
                painter.drawRoundedRect(highlight_rect, 6, 6)

        self._draw_text(painter, name, rect)

    def _draw_text(self, painter, name, rect):
        """绘制文本"""
        font = QFont(self._font_family)
        font.setPointSize(self._font_size)
        font.setBold(self._font_bold)
        painter.setFont(font)

        painter.setPen(self.colors[name]['text'])
        label_rect = QRectF(rect.left() + 12, rect.top(),
                            rect.width() * 0.3, rect.height())
        painter.drawText(label_rect, Qt.AlignVCenter | Qt.AlignLeft,
                         f"{name.upper()}")

        percent_text = f"{int(self.progress[name])}%"
        percent_rect = QRectF(rect.left(), rect.top(),
                              rect.width() - 12, rect.height())
        painter.drawText(percent_rect, Qt.AlignVCenter | Qt.AlignRight,
                         percent_text)

        if self.progress[name] > 10:
            indicator_font = QFont(self._font_family)
            indicator_font.setPointSize(self._font_size - 1)
            indicator_font.setBold(True)
            painter.setFont(indicator_font)

            fill_width = rect.width() * self.progress[name] / 100.0
            if fill_width > 80:
                indicator_rect = QRectF(rect.left() + 12, rect.top(),
                                        fill_width - 24, rect.height())
                painter.setPen(QColor(255, 255, 255, 200))
                painter.drawText(indicator_rect, Qt.AlignVCenter | Qt.AlignCenter,
                                 percent_text)

    def sizeHint(self):
        """返回建议大小"""
        return self.minimumSize()
</file>

<file path="widgets/task_detaile.py">
import random
from PyQt5.QtCore import Qt, QAbstractTableModel, QModelIndex, QSortFilterProxyModel
from PyQt5.QtWidgets import QVBoxLayout, QWidget, QHeaderView
from qfluentwidgets import TableView, LineEdit


class ProcessTableModel(QAbstractTableModel):
    def __init__(self, headers, data=None):
        super().__init__()
        self._headers = headers
        self._data = data or []  # list of lists

    def rowCount(self, parent=QModelIndex()):
        return len(self._data)

    def columnCount(self, parent=QModelIndex()):
        return len(self._headers)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        row, col = index.row(), index.column()
        if role == Qt.DisplayRole:
            if col < len(self._data[row]):
                return str(self._data[row][col])
            return ""
        elif role == Qt.TextAlignmentRole:
            # 数字右对齐
            if col in [1, 3, 4]:  # PID, CPU%, MEM%
                return Qt.AlignRight | Qt.AlignVCenter
            return Qt.AlignLeft | Qt.AlignVCenter
        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._headers[section]
        return None

    def updateData(self, new_data):
        """更新表格数据"""
        self.beginResetModel()
        converted = []
        for item in new_data:
            row = [
                item.get("user", ""),
                item.get("pid", 0),
                item.get("name", ""),
                item.get("cpu", 0.0),
                item.get("mem", 0.0),
                item.get("command", "")
            ]
            converted.append(row)
        self._data = converted
        self.endResetModel()


class ProcessMonitor(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Process Info Monitor Demo")
        self.resize(1200, 600)

        self.headers = [
            "User", "PID", "Process Name", "CPU %", "Mem %", "Command"
        ]
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # 搜索框
        self.filter_input = LineEdit(self)
        self.filter_input.setPlaceholderText("Filter by any field...")
        self.filter_input.textChanged.connect(self.filterData)
        layout.addWidget(self.filter_input)

        # 模型
        self.source_model = ProcessTableModel(self.headers)
        self.proxy_model = QSortFilterProxyModel(self)
        self.proxy_model.setSourceModel(self.source_model)
        self.proxy_model.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxy_model.setFilterKeyColumn(-1)  # 所有列都可过滤

        # 表格
        self.table_view = TableView(self)
        self.table_view.setModel(self.proxy_model)
        self.table_view.setSortingEnabled(True)
        self.table_view.verticalHeader().setVisible(False)
        self.table_view.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.table_view.horizontalHeader().setStretchLastSection(True)

        # 设置列宽
        header = self.table_view.horizontalHeader()
        header.resizeSection(0, 100)  # User
        header.resizeSection(1, 80)   # PID
        header.resizeSection(2, 150)  # Process Name
        header.resizeSection(3, 80)   # CPU %
        header.resizeSection(4, 80)   # Mem %
        header.resizeSection(5, 700)  # Command

        layout.addWidget(self.table_view, 1)

    def filterData(self, text):
        self.proxy_model.setFilterRegExp(text)

    def updateProcessData(self, process_data):
        """外部接口：更新进程信息"""
        self.source_model.updateData(process_data)

    def generateSampleData(self):
        """生成模拟数据"""
        users = ["root", "user1", "mysql", "nginx"]
        procs = ["python3", "nginx", "mysqld",
                 "chrome", "firefox", "sshd", "java"]

        sample = []
        for i in range(30):
            item = {
                "user": random.choice(users),
                "pid": random.randint(100, 5000),
                "name": random.choice(procs),
                "cpu": round(random.uniform(0, 50), 1),
                "mem": round(random.uniform(0, 10), 1),
                "command": f"/usr/bin/{random.choice(procs)} --option {random.randint(1, 10)}"
            }
            sample.append(item)
        self.updateProcessData(sample)
</file>

<file path="widgets/task_widget.py">
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont, QColor, QStandardItemModel, QStandardItem
from PyQt5.QtWidgets import QFrame, QVBoxLayout, QSizePolicy
from qfluentwidgets import TableView, isDarkTheme, PrimaryPushButton
from widgets.network_widget import NetMonitor


class Tasks(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameShape(QFrame.NoFrame)
        self.setStyleSheet("background: transparent;")
        self.setMinimumHeight(100)
        self.netmonitor = NetMonitor()
        self.netmonitor.setMinimumHeight(80)
        self.netmonitor.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.netmonitor.setStyleSheet("""
                QFrame#netmonitor
                {
                    background-color: rgba(220, 220, 220, 0.06);
                    border: 1px solid rgba(0,0,0,0.06);
                    border-radius: 6px;
                }
            """)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # ✅ 使用 QFluentWidgets 的 TableView
        self.table = TableView(self)
        self.model = QStandardItemModel(0, 3, self)
        self.model.setHorizontalHeaderLabels(["RAM", "CPU", "NAME"])
        self.table.setModel(self.model)

        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionMode(self.table.NoSelection)
        self.table.setEditTriggers(self.table.NoEditTriggers)
        self.table.setAlternatingRowColors(False)

        # 样式
        self.table.setShowGrid(False)
        self.table.setCornerButtonEnabled(False)
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setStyleSheet("""
            TableView {
                border: none;
                background: transparent;
            }
            TableView::item {
                padding: 4px;
            }
        """)

        # 水平表头也可以透明
        self.table.horizontalHeader().setStyleSheet("""
            QHeaderView::section {
                background: transparent;
                border: none;
                color: white; /* 或者根据主题切换 */
                font-weight: bold;
                padding: 4px;
            }
        """)

        self.sysinfo_button = PrimaryPushButton("System Info")
        self.sysinfo_button.setCursor(Qt.PointingHandCursor)
        self.sysinfo_button.setStyleSheet("""
            PrimaryPushButton {
                background: transparent;
                border: none;
                color: #0078D4;
                font-weight: bold;
            }
            PrimaryPushButton:hover {
                text-decoration: underline;
            }
        """)

        layout.addWidget(self.table)
        layout.addWidget(self.sysinfo_button)
        layout.addWidget(self.netmonitor)
        self.text_color = "#ffffff" if isDarkTheme() else "#000000"

    def set_text_color(self, color_hex: str):
        self.text_color = color_hex

    def add_row(self, mem, cpu, cmd):
        # 如果行数超过5，清空
        if self.model.rowCount() >= 4:
            self.model.removeRows(0, self.model.rowCount())

        items = []

        # RAM
        mem_item = QStandardItem(str(mem))
        mem_item.setTextAlignment(Qt.AlignCenter)
        mem_item.setFont(self._bold_font())
        mem_item.setForeground(QColor(self.text_color))
        items.append(mem_item)

        # CPU
        cpu_item = QStandardItem(str(cpu))
        cpu_item.setTextAlignment(Qt.AlignCenter)
        cpu_item.setFont(self._bold_font())
        cpu_item.setForeground(QColor(self.text_color))
        items.append(cpu_item)

        # NAME / Command
        cmd_item = QStandardItem(str(cmd))
        cmd_item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        cmd_item.setForeground(QColor(self.text_color))
        items.append(cmd_item)

        self.model.appendRow(items)

        # 可选：固定行高
        row_index = self.model.rowCount() - 1
        self.table.setRowHeight(row_index, 32)

    def _bold_font(self):
        font = QFont()
        font.setBold(True)
        return font

    # def set_netmonitor(self, upload, download):
    #     self.netmonitor.update_speed(
    #         upload_kbps=upload, download_kbps=download)
</file>

<file path="widgets/theme_helper.py">
# theme_helper.py
from qfluentwidgets import toggleTheme, Theme
from PyQt5.QtGui import QFont

_current_theme = Theme.DARK
_on_theme_changed = None
_font_settings = {
    'family': 'Courier New',
    'size': 12,
    'bg_color_light': "#888888",
    'bg_color_dark': "#252525"
}


def apply_dark_theme():
    global _current_theme
    _current_theme = Theme.DARK
    toggleTheme(Theme.DARK)
    if _on_theme_changed:
        _on_theme_changed()


def apply_light_theme():
    global _current_theme
    _current_theme = Theme.LIGHT
    toggleTheme(Theme.LIGHT)
    if _on_theme_changed:
        _on_theme_changed()


def current_theme():
    return _current_theme


def set_theme_change_callback(cb):
    global _on_theme_changed
    _on_theme_changed = cb


def get_font_settings():
    return _font_settings.copy()


def update_font_settings(settings):
    global _font_settings
    _font_settings.update(settings)
    if _on_theme_changed:
        _on_theme_changed()


def get_current_font_color():
    """Automatically return font color based on theme"""
    if _current_theme == Theme.DARK:
        return '#ffffff'
    else:
        return '#000000'


def get_current_bg_color():
    if _current_theme == Theme.DARK:
        return _font_settings['bg_color_dark']
    else:
        return _font_settings['bg_color_light']


def get_font():
    return QFont(_font_settings['family'], _font_settings['size'])
</file>

<file path="tools/llm_helper.py">
from openai import OpenAI
from tools.setting_config import SCM
from PyQt5.QtCore import QThread, pyqtSignal
import json

configer = SCM()
config = configer.read_config()

MODEL_URL = {
    "DeepSeek": "https://api.deepseek.com",
    "ChatGPT": "https://api.openai.com",
    "Local ollama": "http://127.0.0.1"
}
MODEL_NAME = {
    "DeepSeek": "deepseek-chat"
}


class LLMHelper(QThread):
    error_signal = pyqtSignal(str)
    result_signal = pyqtSignal(str)
    finished_signal = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.loading_settings()
        self.client = None
        self.is_running = False
        self.current_messages = []
        self.system_prompt = self.tr('''
You are a professional SSH assistant. Generate corresponding SSH commands based on terminal output and user requirements.

Please return in strict JSON format:
{
    "command": ["generated SSH command, can be multi-line script", "is multi-line command: true/false"],
    "explanation": "explanation of the generated SSH command (explanation language should match user input language)"
}

If unable to generate command, return:
{
    "command": ["", false],
    "explanation": "reason why command cannot be generated"
}

Input format:
{
    "terminal": "terminal output content",
    "user_input": "user natural language requirement"
}

Please note that there may be multi-turn Q&A information. Pay attention to whether the context is related. Only answer the content of the latest text. The previous text may contain helpful auxiliary information. The assistant field corresponds to your previous answer.
''')

        self.history_messages_max_length = config.get(
            "aigc_history_max_length", 10)
        self.recent_commands = []

        if self.init_client():
            print("LLM client initialized successfully")
        else:
            print("LLM client initialization failed")

    def run(self):
        if not self.client or not self.current_messages:
            self.error_signal.emit(
                self.tr("Client not initialized or no message content"))
            return

        try:
            buffer = ""
            buffer_size = 0
            max_buffer_size = 50

            messages = self._build_messages()
            print(messages)
            # print("Model Name:", MODEL_NAME.get(MODEL))
            response = self.client.chat.completions.create(
                model=MODEL_NAME.get(self.MODEL),
                messages=messages,
                stream=True
            )

            full_content = ""
            for chunk in response:
                if not self.is_running:
                    break

                if chunk.choices[0].delta.content is not None:
                    content = chunk.choices[0].delta.content
                    full_content += content
                    buffer += content
                    buffer_size += len(content)

                    if (buffer_size >= max_buffer_size or
                            content in ['\n', '。', '!', '?', '；', '.']):
                        self.result_signal.emit(buffer)
                        buffer = ""
                        buffer_size = 0

            if buffer and self.is_running:
                self.result_signal.emit(buffer)

            if self.is_running and full_content:
                self._add_to_history("assistant", full_content)
                self.finished_signal.emit()

        except Exception as e:
            self.error_signal.emit(self.tr(f"API request failed: {str(e)}"))
        finally:
            self.is_running = False

    def send_request(self, terminal_output, user_input, use_compact_history=True):
        """
        发送请求：
          - use_compact_history=True 时，调用 _compact_history_for_send 来节省 tokens
          - 注意：recent_commands 保持原样（用于本地保存或后续展示）
        """
        if self.is_running:
            self.error_signal.emit(
                self.tr("Previous request is still processing"))
            return False

        # 记录历史（保留原始内容以便之后复用）
        user_message = json.dumps(
            {"terminal": terminal_output, "user_input": user_input}, ensure_ascii=False)
        self._add_to_history("user", user_message)

        # 生成 current_messages（但不要把 oversized terminal 带到历史里）
        if use_compact_history:
            self.current_messages = self._compact_history_for_send(
                terminal_output, user_input)
        else:
            # 不压缩，直接 system + recent_commands + current user
            msgs = [{"role": "system", "content": self.system_prompt}]
            for msg in self.recent_commands:
                if msg.get("role") != "system":
                    msgs.append(msg)
            msgs.append({"role": "user", "content": user_message})
            self.current_messages = msgs

        self.is_running = True
        self.start()
        return True

    def _build_messages(self):
        messages = [{"role": "system", "content": self.system_prompt}]

        for msg in self.recent_commands:
            if msg["role"] != "system":
                messages.append(msg)

        return messages

    def _add_to_history(self, role, content):
        self.recent_commands.append({"role": role, "content": content})

        if len(self.recent_commands) > self.history_messages_max_length:
            self.recent_commands = [self.recent_commands[0]] + \
                self.recent_commands[-(self.history_messages_max_length-1):]

    def init_client(self, ):
        try:
            if not self.API_KEY:
                self.error_signal.emit(self.tr("API key is empty"))
                return False

            self.client = OpenAI(
                api_key=self.API_KEY,
                base_url=MODEL_URL.get(self.MODEL, None)
            )
            print("Model : ", MODEL_URL.get(self.MODEL, None))
            return True

        except Exception as e:
            self.error_signal.emit(
                self.tr(f"Client initialization failed: {str(e)}"))
            return False

    def stop(self):
        self.is_running = False
        self.wait()

    def _safe_load_json(self, s):
        """尝试把字符串解析为 JSON，失败则返回 None"""
        try:
            return json.loads(s)
        except Exception:
            return None

    def _compact_history_for_send(self, latest_terminal: str, latest_user_input: str):
        """
        构建 compact 的 messages 列表以发送给模型，策略：
         - 保留 system prompt（始终）
         - 对于历史 user 条目：保留 user_input 文本，但把 terminal 字段清空或置为简短占位
         - 对于历史 assistant 条目：如果能解析为 JSON，则只保留 explanation 字段（或少量元信息）
           否则保留原文本（但可考虑截断）
         - 最后追加当前 user（带上 latest_terminal 与 latest_user_input）
        这样可以显著减少 tokens 用量而保留上下文要点。
        """
        messages = [{"role": "system", "content": self.system_prompt}]

        # 遍历 recent_commands（它是按时间顺序追加的：user/assistant/...）
        for msg in self.recent_commands:
            role = msg.get("role")
            content = msg.get("content", "")

            if role == "user":
                parsed = self._safe_load_json(content)
                if isinstance(parsed, dict):
                    # 保留 user_input，删除/缩短 terminal
                    ui = parsed.get("user_input", "")
                    # 用空字符串或占位符替代历史 terminal（节省 tokens）
                    compact_user = {"terminal": "", "user_input": ui}
                    messages.append({"role": "user", "content": json.dumps(
                        compact_user, ensure_ascii=False)})
                else:
                    # content 不是 json（回退），只保留原文的前 N 字（防止过大）
                    short = content if len(content) <= 200 else content[-200:]
                    messages.append({"role": "user", "content": short})

            elif role == "assistant":
                parsed = self._safe_load_json(content)
                if isinstance(parsed, dict):
                    # 只保留 explanation 字段（通常较短且有意义）
                    expl = parsed.get("explanation", "")
                    if expl:
                        compact_assistant = {"command": [
                            "", False], "explanation": expl}
                        messages.append({"role": "assistant", "content": json.dumps(
                            compact_assistant, ensure_ascii=False)})
                    else:
                        # 若没有 explanation，则保留少量文本
                        messages.append({"role": "assistant", "content": ""})
                else:
                    # 非 JSON：截断保留最后一段（若太长）
                    short = content if len(content) <= 200 else content[-200:]
                    messages.append({"role": "assistant", "content": short})

            else:
                # 其他 role（如 system），直接附上（但 system 一般只有第一个）
                messages.append({"role": role, "content": content})

        # 最后追加当前 user（带上最新的 terminal 内容）
        current_user_obj = {"terminal": latest_terminal or "",
                            "user_input": latest_user_input or ""}
        messages.append({"role": "user", "content": json.dumps(
            current_user_obj, ensure_ascii=False)})

        return messages

    def loading_settings(self):
        config = configer.read_config()
        self.API_KEY = config.get("aigc_api_key", "")
        self.MODEL = config.get("aigc_model", "DeepSeek")
        self.history_messages_max_length = config.get(
            "aigc_history_max_length", 10)
        self.init_client()
</file>

<file path="tools/remote_file_manage.py">
# remote_file_manage.py
from PyQt5.QtCore import pyqtSignal, QThread, QMutex, QWaitCondition, QThreadPool
from tools.transfer_worker import TransferWorker
from tools.setting_config import SCM
import paramiko
import traceback
from typing import Dict, List, Optional
import stat
import os
from typing import Tuple
from datetime import datetime
import shlex
from PyQt5.QtCore import Qt
from functools import partial


class RemoteFileManager(QThread):
    """
    Remote file manager, responsible for building and maintaining remote file trees
    """
    file_tree_updated = pyqtSignal(dict, str)  # file tree , path
    error_occurred = pyqtSignal(str)
    sftp_ready = pyqtSignal()
    upload_progress = pyqtSignal(str, int, int, int)
    download_progress = pyqtSignal(str, int, int, int)
    # File path, success, error message
    upload_finished = pyqtSignal(str, bool, str)
    # Path, success, error message
    delete_finished = pyqtSignal(str, bool, str)
    list_dir_finished = pyqtSignal(str, list)  # path, result
    # path, result (e.g. "directory"/"file"/False)
    path_check_result = pyqtSignal(str, object)
    # remote_path , local_path , status , error msg,open it
    download_finished = pyqtSignal(str, str, bool, str, bool)
    # source_path, target_path, status, error msg
    copy_finished = pyqtSignal(str, str, bool, str)
    # Original path, new path, success, error message
    rename_finished = pyqtSignal(str, str, bool, str)
    # path, info(dict), status(bool), error_msg(str)
    file_info_ready = pyqtSignal(str, dict, bool, str)
    # path , type
    file_type_ready = pyqtSignal(str, str)
    # path , status , error_msg
    mkdir_finished = pyqtSignal(str, bool, str)
    # target_zip_path
    start_to_compression = pyqtSignal(str)
    # remote_path_path
    start_to_uncompression = pyqtSignal(str)
    compression_finished = pyqtSignal(str, str)

    def __init__(self, session_info, parent=None, child_key=None):
        super().__init__(parent)
        self.session_info = session_info
        self.host = session_info.host
        self.user = session_info.username
        self.password = session_info.password
        self.port = session_info.port
        self.auth_type = session_info.auth_type
        self.key_path = session_info.key_path

        self.conn = None
        self.sftp = None
        self.upload_conn = None
        self.download_conn = None

        # File_tree
        self.file_tree: Dict = {}

        # UID/GID Caching
        self.uid_map: Dict[int, str] = {}
        self.gid_map: Dict[int, str] = {}

        # Thread Control
        self.mutex = QMutex()
        self.condition = QWaitCondition()
        self._is_running = True
        self._tasks = []

        # Thread pool for handling concurrent transfers
        self.thread_pool = QThreadPool()
        config = SCM().read_config()
        max_threads = config.get("max_concurrent_transfers", 4)
        self.thread_pool.setMaxThreadCount(max_threads)
        self.active_workers = {}  # To track active TransferWorker instances

    # ---------------------------
    # Main thread loop
    # ---------------------------
    def _create_ssh_connection(self):
        """Helper function to create and configure an SSH connection."""
        conn = paramiko.SSHClient()
        conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        if self.auth_type == "password":
            conn.connect(
                self.host,
                port=self.port,
                username=self.user,
                password=self.password,
                timeout=30,
                banner_timeout=30
            )
        else:
            conn.connect(
                self.host,
                port=self.port,
                username=self.user,
                key_filename=self.key_path,
                timeout=30,
                banner_timeout=30
            )
        return conn

    def run(self):
        try:
            # Create all three connections at the start
            self.conn = self._create_ssh_connection()
            self.upload_conn = self._create_ssh_connection()
            self.download_conn = self._create_ssh_connection()

            self.sftp = self.conn.open_sftp()
            self.sftp_ready.emit()
            self._fetch_user_group_maps()
            while self._is_running:
                self.mutex.lock()
                if not self._tasks:
                    self.condition.wait(self.mutex)
                if self._tasks:
                    task = self._tasks.pop(0)
                    self.mutex.unlock()
                    try:
                        ttype = task.get('type')
                        if ttype == 'add_path':
                            self._add_path_to_tree(
                                task['path'], task["update_tree_sign"])
                        elif ttype == 'remove_path':
                            self._remove_path_from_tree(task['path'])
                        elif ttype == 'refresh':
                            self._refresh_paths_impl(task.get('paths'))
                        elif ttype == 'upload_file':
                            self._dispatch_transfer_task(
                                'upload',
                                task['local_path'],
                                task['remote_path'],
                                task['compression'],
                                task_id=task.get('task_id')
                            )
                        elif ttype == 'delete':
                            self._handle_delete_task(
                                task['path'],
                                task.get('callback')
                            )
                        elif ttype == "download_files":
                            self._dispatch_transfer_task(
                                'download',
                                None,  # local_path is not used for download tasks
                                task['path'],
                                task["compression"],
                                open_it=task["open_it"],
                                session_id=task.get("session_id")
                            )
                        elif ttype == 'list_dir':
                            # print(f"Handle:{[task['path']]}")
                            result = self.list_dir_detailed(task['path'])
                            # print(f"List dir : {result}")
                            self.list_dir_finished.emit(
                                task['path'], result or [])
                        elif ttype == 'check_path':
                            path_to_check = task['path']
                            try:
                                res = self.check_path_type(
                                    path_to_check)
                            except Exception as e:
                                res = False
                            self.path_check_result.emit(path_to_check, res)
                        elif ttype == 'copy_to':
                            self._handle_copy_task(
                                task['source_path'],
                                task['target_path'],
                                task.get('cut', False)
                            )
                        elif ttype == 'rename':
                            self._handle_rename_task(
                                task['path'],
                                task['new_name'],
                                task.get('callback')
                            )
                        elif ttype == 'file_info':
                            path, info_dict, status, error_msg = self._get_file_info(
                                task['path'])
                            self.file_info_ready.emit(
                                path, info_dict, status, error_msg)
                        elif ttype == 'file_type':
                            self.classify_file_type_using_file(task['path'])
                        elif ttype == 'mkdir':
                            self._handle_mkdir_task(
                                task['path'], task.get('callback'))
                        else:
                            print(f"Unknown task type: {ttype}")
                    except Exception as e:
                        self.error_occurred.emit(
                            f"Error while executing task: {e}")
                else:
                    self.mutex.unlock()

        except Exception as e:
            tb = traceback.format_exc()
            self.error_occurred.emit(f"Remote File Manager Error: {e}\n{tb}")
        finally:
            self._cleanup()

    # ---------------------------
    # Thread Control & Cleanup
    # ---------------------------
    def stop(self):
        self._is_running = False
        self.condition.wakeAll()
        self.wait()

    def _cleanup(self):
        try:
            if self.sftp:
                self.sftp.close()
        except Exception:
            pass
        try:
            if self.conn:
                self.conn.close()
            if self.upload_conn:
                self.upload_conn.close()
            if self.download_conn:
                self.download_conn.close()
        except Exception:
            pass

    # ---------------------------
    # Transfer Worker Management
    # ---------------------------
        # try:
        #     signals = [
        #         'file_tree_updated', 'error_occurred', 'sftp_ready', 'upload_progress',
        #         'upload_finished', 'delete_finished', 'list_dir_finished', 'path_check_result',
        #         'download_finished', 'copy_finished', 'rename_finished', 'file_info_ready',
        #         'file_type_ready', 'mkdir_finished', 'start_to_compression', 'start_to_uncompression'
        #     ]
        #     for sig_name in signals:
        #         sig = getattr(self, sig_name, None)
        #         if sig:
        #             try:
        #                 sig.disconnect()
        #             except Exception:
        #                 pass
        # except Exception:
        #     pass
        try:
            if self.isRunning():
                self.quit()
                # self.wait(2000)
        except Exception:
            pass

    def _dispatch_transfer_task(self, action, local_path, remote_path, compression, open_it=False, task_id=None, session_id=None):
        """Creates and starts TransferWorker(s) for uploads or downloads."""
        if action == 'upload':
            self._dispatch_upload_task(
                local_path, remote_path, compression, open_it, task_id=task_id)
        elif action == 'download':
            self._dispatch_download_task(
                remote_path, compression, open_it, session_id=session_id)

    def _dispatch_upload_task(self, local_path, remote_path, compression, open_it, task_id=None):
        """Handles dispatching of upload tasks, expanding directories if necessary."""
        # If compression is on and we have a list of paths, treat it as a single batch job.
        if compression and isinstance(local_path, list):
            self._create_and_start_worker(
                'upload', self.upload_conn, local_path, remote_path, compression, open_it, task_id=task_id)
            return

        # Fallback to original logic for single items or non-compressed lists.
        paths_to_process = local_path if isinstance(
            local_path, list) else [local_path]

        for path_item in paths_to_process:
            is_dir = os.path.isdir(path_item)

            if is_dir and not compression:
                # Expand directory into a list of files for individual upload
                all_files = self._list_local_files_recursive(path_item)
                for file_path in all_files:
                    # For each file, we pass the original directory as 'context'
                    self._create_and_start_worker(
                        'upload', self.upload_conn, file_path, remote_path, compression, open_it, upload_context=path_item)
            else:
                # It's a single file, a list of files, or a compressed directory
                self._create_and_start_worker(
                    'upload', self.upload_conn, path_item, remote_path, compression, open_it)

    def _dispatch_download_task(self, remote_path, compression, open_it, session_id=None):
        """Handles dispatching of download tasks, expanding directories if necessary."""
        paths_to_process = remote_path if isinstance(
            remote_path, list) else [remote_path]
        print(f"paths_to_process : {paths_to_process}")
        if compression:
            # compression all files to a tar
            self._create_and_start_worker(
                'download', self.download_conn, None, paths_to_process, compression, open_it, session_id=session_id)
        else:
            for path_item in paths_to_process:
                print(f"非压缩下载 {path_item}")
                is_dir = self.check_path_type(path_item) == "directory"

                if is_dir:
                    # Expand directory into a list of files for individual download
                    all_files, dirs_to_create = self._list_remote_files_recursive(
                        path_item)
                    for file_path in all_files:
                        # For each file, we pass the original directory as 'context'
                        print(f"添加 {file_path} 到任务")
                        self._create_and_start_worker(
                            'download', self.download_conn, None, file_path, compression, open_it, download_context=path_item, session_id=session_id)
                else:
                    # It's a single file, a list of files, or a compressed directory
                    self._create_and_start_worker(
                        'download', self.download_conn, None, path_item, compression, open_it, session_id=session_id)

    def _list_remote_files_recursive(self, remote_path):
        """Recursively lists all files in a remote directory. Returns a tuple of (file_paths, dir_paths)."""
        file_paths = []
        dir_paths = [remote_path]

        items_to_scan = [remote_path]

        while items_to_scan:
            current_path = items_to_scan.pop(0)
            try:
                for attr in self.sftp.listdir_attr(current_path):
                    full_path = f"{current_path.rstrip('/')}/{attr.filename}"
                    if stat.S_ISDIR(attr.st_mode):
                        dir_paths.append(full_path)
                        items_to_scan.append(full_path)
                    else:
                        file_paths.append(full_path)
            except Exception as e:
                print(f"Error listing remote directory {current_path}: {e}")

        return file_paths, dir_paths

    def _list_local_files_recursive(self, local_path):
        """Recursively lists all files in a local directory."""
        file_paths = []
        for root, _, files in os.walk(local_path):
            for file in files:
                file_paths.append(os.path.join(root, file))
        return file_paths

    def _create_and_start_worker(self, action, connection, local_path, remote_path, compression, open_it=False, download_context=None, upload_context=None, task_id=None, session_id=None):
        """Helper to create, connect signals, and start a single TransferWorker."""
        worker = TransferWorker(
            connection,
            action,
            local_path,
            remote_path,
            compression,
            download_context,
            upload_context,
            task_id,
            session_id
        )

        # Store open_it parameter in worker for download callback
        if action == 'download':
            worker._open_it = open_it

        if action == 'upload':
            worker.signals.finished.connect(self.upload_finished)
            # Refresh the parent directory of the remote path upon successful upload.
            worker.signals.finished.connect(
                lambda path, success, msg: self.refresh_paths(
                    [os.path.dirname(remote_path.rstrip('/'))]) if success and remote_path else None
            )
            worker.signals.progress.connect(self.upload_progress)
            worker.signals.start_to_compression.connect(
                self.start_to_compression)
            worker.signals.start_to_uncompression.connect(
                self.start_to_uncompression)
            worker.signals.compression_finished.connect(
                self.compression_finished)

        elif action == 'download':
            # Create callback function for download completion
            def emit_download_finished(identifier, success, msg):
                """Emit download finished signal with proper parameters"""
                self.download_finished.emit(
                    identifier,
                    msg if success else "",
                    success,
                    "" if success else msg,
                    worker._open_it
                )
            worker._download_callback = emit_download_finished
            worker.signals.progress.connect(
                self.download_progress, Qt.QueuedConnection)

        self.thread_pool.start(worker)

        # Track the worker
        if task_id:
            identifier = task_id
        else:
            identifier = str(
                local_path if action == 'upload' else remote_path)
        self.active_workers[identifier] = worker

    # ---------------------------
    # Public task API
    # ---------------------------

    def cancel_transfer(self, identifier: str):
        """Cancels an active transfer task."""
        worker = self.active_workers.pop(identifier, None)
        print(worker)
        if worker:
            print('stop loading')
            worker.stop()

    def mkdir(self, path: str, callback=None):
        self.mutex.lock()
        self._tasks.append({
            'type': 'mkdir',
            'path': path,
            "callback": callback,
        })
        self.condition.wakeAll()
        self.mutex.unlock()

    def get_file_type(self, path: str):
        self.mutex.lock()
        self._tasks.append({'type': 'file_type', 'path': path})
        self.condition.wakeAll()
        self.mutex.unlock()

    def get_file_info(self, path: str):
        """
        The result is sent via the file_info_ready signal.
        """
        self.mutex.lock()
        self._tasks.append({'type': 'file_info', 'path': path})
        self.condition.wakeAll()
        self.mutex.unlock()

    def copy_to(self, source_path: str, target_path: str, cut: bool = False):
        """
    Asynchronously copies or moves a remote file or directory.

    This method queues a copy or move task to be executed in the background.
    When the operation is complete, the `copy_finished` signal is emitted.

    Args:
        source_path (str): The source path of the file or directory to copy/move.
        target_path (str): The destination path where the file or directory will be copied/moved.
        cut (bool, optional): If True, moves the file or directory (deletes the source after copying).
                              If False, copies the file or directory without deleting the source.
                              Defaults to False.

    Signals:
        copy_finished (str, str, bool, str): Emitted upon completion with parameters:
            - source_path (str): The original source path.
            - target_path (str): The target path.
            - success (bool): True if the operation succeeded, False otherwise.
            - error_msg (str): Error message if the operation failed, empty string otherwise.
        """
        self.mutex.lock()
        self._tasks.append({
            'type': 'copy_to',
            'source_path': source_path,
            'target_path': target_path,
            'cut': cut
        })
        self.condition.wakeAll()
        self.mutex.unlock()

    def delete_path(self, path, callback=None):
        """
        Asynchronously deletes a remote file or directory.

        This method queues a delete task to be executed in the background.
        Upon completion, the `delete_finished` signal is emitted.

        Args:
            path (str): The remote path of the file or directory to delete.
            callback (callable, optional): A function to be called when the deletion
                is complete. The callback receives two arguments:
                - success (bool): True if deletion succeeded, False otherwise.
                - error_msg (str): Error message if deletion failed, empty string otherwise.

        Signals:
            delete_finished (str, bool, str): Emitted upon completion with parameters:
                - path (str): The path that was deleted.
                - success (bool): True if deletion succeeded, False otherwise.
                - error_msg (str): Error message if deletion failed, empty string otherwise.
        """

        self.mutex.lock()
        self._tasks.append({
            'type': 'delete',
            'path': path,
            'callback': callback
        })
        self.condition.wakeAll()
        self.mutex.unlock()

    def add_path(self, path: str, update_tree_sign=True):
        self.mutex.lock()
        self._tasks.append({'type': 'add_path', 'path': path,
                           "update_tree_sign": update_tree_sign})
        self.condition.wakeAll()
        self.mutex.unlock()

    def remove_path(self, path: str):
        self.mutex.lock()
        self._tasks.append({'type': 'remove_path', 'path': path})
        self.condition.wakeAll()
        self.mutex.unlock()

    def refresh_paths(self, paths: Optional[List[str]] = None):
        """Refresh the specified path or all directories if paths is None"""
        self.mutex.lock()
        self._tasks.append({'type': 'refresh', 'paths': paths})
        self.condition.wakeAll()
        self.mutex.unlock()

    def check_path_async(self, path: str):
        self.mutex.lock()
        self._tasks.append({'type': 'check_path', 'path': path})
        self.condition.wakeAll()
        self.mutex.unlock()

    def list_dir_async(self, path: str):
        """List a directory"""
        self.mutex.lock()
        if any(t.get('type') == 'list_dir' and t.get('path') == path for t in self._tasks):
            self.mutex.unlock()
            return
        self._tasks.append({'type': 'list_dir', 'path': path})
        self.condition.wakeAll()
        self.mutex.unlock()

    def download_path_async(self, path: str, open_it: bool = False, compression=False, session_id: str = None):
        self.mutex.lock()
        self._tasks.append(
            {'type': 'download_files', 'path': path, "open_it": open_it, "compression": compression, "session_id": session_id})
        self.condition.wakeAll()
        self.mutex.unlock()

    def rename(self, path: str, new_name: str, callback=None):
        """
        Asynchronously renames a remote file or directory.

        This method queues a rename task to be executed in the background.
        Upon completion, the `rename_finished` signal is emitted.

        Args:
            path (str): The remote path of the file or directory to rename.
            new_name (str): The new name for the file or directory.
            callback (callable, optional): A function to be called when the rename
                is complete. The callback receives two arguments:
                - success (bool): True if rename succeeded, False otherwise.
                - error_msg (str): Error message if rename failed, empty string otherwise.

        Signals:
            rename_finished (str, str, bool, str): Emitted upon completion with parameters:
                - original_path (str): The original path.
                - new_path (str): The new path after renaming.
                - success (bool): True if rename succeeded, False otherwise.
                - error_msg (str): Error message if rename failed, empty string otherwise.
        """

        self.mutex.lock()
        self._tasks.append({
            'type': 'rename',
            'path': path,
            'new_name': new_name,
            'callback': callback
        })
        self.condition.wakeAll()
        self.mutex.unlock()

    def upload_file(self, local_path, remote_path: str, compression: bool, callback=None, task_id=None):
        """
        Uploads a local file to the remote server asynchronously.

        This method queues an upload task to be executed in the background.
        Upon completion, the `upload_finished` signal is emitted.

        Args:
            local_path (str or list): Path to the local file to upload.
            remote_path (str): Target path on the remote server.
            callback (callable, optional): Function to call when upload is complete.
                Receives two arguments:
                - success (bool): True if upload succeeded, False otherwise.
                - error_msg (str): Error message if upload failed, empty string otherwise.

        Signals:
            upload_finished (str, bool, str): Emitted upon completion with parameters:
                - local_path (str): The local file path.
                - success (bool): True if upload succeeded, False otherwise.
                - error_msg (str): Error message if upload failed, empty string otherwise.
        """

        self.mutex.lock()
        self._tasks.append({
            'type': 'upload_file',
            'local_path': local_path,
            'remote_path': remote_path,
            'compression': compression,
            'callback': callback,
            'task_id': task_id
        })
        self.condition.wakeAll()
        self.mutex.unlock()

    def classify_file_type_using_file(self, path: str) -> str:
        """
        Use remote `file` command to detect a simplified file type and emit the result.

        Returns one of:
        - "image/video"
        - "text"
        - "executable"
        - "unknown"

        Emits: file_type_ready(path, type)
        """
        # safety: ensure conn exists
        if self.conn is None:
            self.file_type_ready.emit(path, "unknown")
            return "unknown"

        # quote path for shell safety
        safe_path = shlex.quote(path)

        try:
            # 1) Try MIME type first (follow symlink with -L)
            cmd_mime = f"file -b --mime-type -L {safe_path}"
            stdin, stdout, stderr = self.conn.exec_command(cmd_mime)
            exit_status = stdout.channel.recv_exit_status()
            mime_out = stdout.read().decode('utf-8', errors='ignore').strip().lower()
            _err = stderr.read().decode('utf-8', errors='ignore').strip()

            if exit_status == 0 and mime_out:
                # image/video by MIME
                if mime_out.startswith("image") or mime_out.startswith("video"):
                    self.file_type_ready.emit(path, "image/video")
                    return "image/video"

                # text-like MIME (text/* or some application types that are textual)
                if (mime_out.startswith("text")
                    or mime_out in {"application/json", "application/xml", "application/javascript"}
                        or mime_out.endswith("+xml") or mime_out.endswith("+json")):
                    self.file_type_ready.emit(path, "text")
                    return "text"

                # common executable-related MIME strings
                if ("executable" in mime_out
                        or "x-executable" in mime_out
                        or mime_out.startswith("application/x-sharedlib")
                        or "x-mach-binary" in mime_out
                        or "pe" in mime_out  # covers various PE-like mimes
                    ):
                    self.file_type_ready.emit(path, "executable")
                    return "executable"

            # 2) Fallback: use human-readable `file -b -L` output
            cmd_hr = f"file -b -L {safe_path}"
            stdin, stdout, stderr = self.conn.exec_command(cmd_hr)
            exit_status2 = stdout.channel.recv_exit_status()
            hr_out = stdout.read().decode('utf-8', errors='ignore').lower()
            _err2 = stderr.read().decode('utf-8', errors='ignore').strip()

            if exit_status2 == 0 and hr_out:
                # executable indicators
                if ("executable" in hr_out
                    or "elf" in hr_out
                    or "pe32" in hr_out
                    or "ms-dos" in hr_out
                        or "mach-o" in hr_out):
                    self.file_type_ready.emit(path, "executable")
                    return "executable"

                # image/video indicators
                if ("png" in hr_out or "jpeg" in hr_out or "jpg" in hr_out
                    or "gif" in hr_out or "bitmap" in hr_out
                    or "svg" in hr_out or "png image" in hr_out
                        or "video" in hr_out or "matroska" in hr_out or "mp4" in hr_out):
                    self.file_type_ready.emit(path, "image/video")
                    return "image/video"

                # text indicators
                if ("text" in hr_out or "ascii" in hr_out or "utf-8" in hr_out
                        or "script" in hr_out or "json" in hr_out or "xml" in hr_out):
                    self.file_type_ready.emit(path, "text")
                    return "text"

            # 3) 最后兜底：检查执行权限（远端 stat via sftp）
            try:
                attr = self.sftp.lstat(path)
                if bool(attr.st_mode & stat.S_IXUSR):
                    self.file_type_ready.emit(path, "executable")
                    return "executable"
            except Exception:
                # ignore stat errors here
                pass

            # default
            self.file_type_ready.emit(path, "unknown")
            return "unknown"

        except Exception as e:
            print(f"Failed to run remote file command for {path}: {e}")
            self.file_type_ready.emit(path, "unknown")
            return "unknown"

    def _handle_mkdir_task(self, path: str, callback=None):
        """
        Asynchronously create a remote directory (mkdir -p behavior) via SFTP.

        Emits:
            mkdir_finished(path, status, error_msg)
        """
        if self.sftp is None:
            error_msg = "SFTP connection not ready"
            print(f"❌ Mkdir failed - {error_msg}: {path}")
            self.mkdir_finished.emit(path, False, error_msg)
            if callback:
                callback(False, error_msg)
            return

        try:
            # Recursively create directories like 'mkdir -p'
            parts = path.strip("/").split("/")
            current_path = ""
            for part in parts:
                current_path += f"/{part}"
                try:
                    self.sftp.stat(current_path)
                except FileNotFoundError:
                    try:
                        self.sftp.mkdir(current_path)
                        print(f"✅ Created directory: {current_path}")
                    except Exception as mkdir_exc:
                        error_msg = f"Failed to create directory {current_path}: {mkdir_exc}"
                        print(f"❌ Mkdir failed - {error_msg}")
                        self.mkdir_finished.emit(path, False, error_msg)
                        if callback:
                            callback(False, error_msg)
                        return

            # Success
            self.mkdir_finished.emit(path, True, "")
            if callback:
                callback(True, "")

        except Exception as e:
            error_msg = f"Error during mkdir: {str(e)}"
            print(f"❌ Mkdir failed - {error_msg}")
            import traceback
            traceback.print_exc()
            self.mkdir_finished.emit(path, False, error_msg)
            if callback:
                callback(False, error_msg)

    def _ensure_remote_directory_exists(self, remote_dir: str) -> Tuple[bool, str]:
        """
        确保远程目录存在，如果不存在则创建
        """
        try:
            # 尝试列出目录，如果不存在会抛出异常
            self.sftp.listdir(remote_dir)
            return True, ""
        except IOError:
            try:
                # 递归创建目录
                parts = remote_dir.strip('/').split('/')
                current_path = ''
                for part in parts:
                    current_path = current_path + '/' + part if current_path else '/' + part
                    try:
                        self.sftp.listdir(current_path)
                    except IOError:
                        self.sftp.mkdir(current_path)
                return True, ""
            except Exception as e:
                print(f"创建远程目录失败: {remote_dir}, 错误: {e}")
                return False, e
    # ---------------------------
    # 内部文件树操作
    # ---------------------------

    def _get_file_info(self, path: str):
        """
        获取文件/目录信息，跨平台兼容
        """
        if self.sftp is None:
            return None, "", False, "SFTP 未就绪"

        try:
            attr = self.sftp.lstat(path)

            # 权限 rwxr-xr-x 格式
            perm = stat.filemode(attr.st_mode)

            # 用户和组（跨平台）
            owner, group = self._get_owner_group(attr.st_uid, attr.st_gid)

            # 是否可执行
            is_executable = bool(attr.st_mode & stat.S_IXUSR)

            # 最后修改时间
            mtime = datetime.fromtimestamp(
                attr.st_mtime).strftime("%Y-%m-%d %H:%M:%S")

            # 是否符号链接
            is_symlink = stat.S_ISLNK(attr.st_mode)
            symlink_target = None
            if is_symlink:
                try:
                    symlink_target = self.sftp.readlink(path)
                except Exception:
                    symlink_target = "<unresolved>"

            info = {
                "path": path,
                "filename": os.path.basename(path.rstrip('/')),
                "size": self._human_readable_size(attr.st_size),
                "owner": owner,
                "group": group,
                "permissions": perm,
                "is_executable": is_executable,
                "last_modified": mtime,
                "is_directory": stat.S_ISDIR(attr.st_mode),
                "is_symlink": is_symlink,
                "symlink_target": symlink_target
            }

            return path, info, True, ""

        except Exception as e:
            return path, {}, False, f"获取文件信息失败: {e}"

    def _handle_rename_task(self, path: str, new_name: str, callback=None):
        """
        处理重命名任务（内部实现）
        """
        if self.sftp is None:
            error_msg = "SFTP 连接未就绪"
            print(f"❌ 重命名失败 - {error_msg}: {path} -> {new_name}")
            self.rename_finished.emit(path, new_name, False, error_msg)
            if callback:
                callback(False, error_msg)
            return

        try:
            # 检查源路径是否存在
            try:
                self.sftp.stat(path)
            except IOError:
                error_msg = f"源路径不存在: {path}"
                print(f"❌ 重命名失败 - {error_msg}")
                self.rename_finished.emit(path, new_name, False, error_msg)
                if callback:
                    callback(False, error_msg)
                return

            # 构建新路径
            parent_dir = os.path.dirname(path.rstrip('/'))
            new_path = f"{parent_dir}/{new_name}" if parent_dir != '/' else f"/{new_name}"

            print(f"🔁 开始重命名: {path} -> {new_path}")

            # 执行重命名
            self.sftp.rename(path, new_path)

            print(f"✅ 重命名成功: {path} -> {new_path}")
            self.rename_finished.emit(path, new_path, True, "")

            # 刷新父目录
            if parent_dir:
                print(f"🔄 刷新父目录: {parent_dir}")
                self.refresh_paths([parent_dir])

            if callback:
                callback(True, "")

        except Exception as e:
            error_msg = f"重命名过程错误: {str(e)}"
            print(f"❌ 重命名失败 - {error_msg}")
            import traceback
            traceback.print_exc()
            self.rename_finished.emit(path, new_name, False, error_msg)
            if callback:
                callback(False, error_msg)

    def _handle_copy_task(self, source_path: str, target_path: str, cut: bool = False):
        """
        内部处理复制/移动任务
        """
        if self.conn is None:
            error_msg = "SSH 连接未就绪"
            print(f"❌ 复制失败: {source_path} -> {target_path}, {error_msg}")
            self.copy_finished.emit(source_path, target_path, False, error_msg)
            return

        try:
            # 检查源路径
            path_type = self.check_path_type(source_path)
            if not path_type:
                error_msg = f"源路径不存在: {source_path}"
                print(f"❌ 复制失败: {error_msg}")
                self.copy_finished.emit(
                    source_path, target_path, False, error_msg)
                return

            print(f"📁 源路径类型: {path_type}")

            # 确保目标目录存在
            remote_dir = os.path.dirname(target_path.rstrip('/'))
            dir_status, error = self._ensure_remote_directory_exists(
                remote_dir)
            if remote_dir and not dir_status:
                error_msg = f"无法创建目标目录: {remote_dir}\n{error}"
                print(f"❌ 复制失败: {error_msg}")
                self.copy_finished.emit(
                    source_path, target_path, False, error_msg)
                return

            # 执行复制或移动
            cmd = f'cp -r "{source_path}" "{target_path}"'
            if cut:
                cmd = f'mv "{source_path}" "{target_path}"'

            print(f"🔧 执行命令: {cmd}")
            stdin, stdout, stderr = self.conn.exec_command(cmd)
            exit_status = stdout.channel.recv_exit_status()
            error_output = stderr.read().decode('utf-8').strip()

            if exit_status == 0:
                print(f"✅ 复制成功: {source_path} -> {target_path}")
                self.copy_finished.emit(source_path, target_path, True, "")

                # 刷新源和目标父目录
                parent_dirs = list(
                    {os.path.dirname(source_path), os.path.dirname(target_path)})
                self.refresh_paths(parent_dirs)

            else:
                error_msg = error_output if error_output else "未知错误"
                print(f"❌ 复制失败: {error_msg}")
                self.copy_finished.emit(
                    source_path, target_path, False, error_msg)

        except Exception as e:
            error_msg = f"复制过程错误: {str(e)}"
            print(f"❌ 复制失败: {error_msg}")
            import traceback
            traceback.print_exc()
            self.copy_finished.emit(source_path, target_path, False, error_msg)

    def _add_path_to_tree(self, path: str, update_tree_sign: bool = True):
        parts = [p for p in path.strip("/").split("/") if p]
        if "" not in self.file_tree:
            self.file_tree[""] = {}
        current = self.file_tree[""]

        # 列出根目录
        try:
            self._get_directory_contents("/", current)
        except Exception as e:
            print(f"列出根目录时出错: {e}")

        # 逐级添加
        full_path_parts = []
        for part in parts:
            full_path_parts.append(part)
            full_path = "/" + "/".join(full_path_parts)
            if part not in current or not isinstance(current[part], dict):
                current[part] = {}
            try:
                self._get_directory_contents(full_path, current[part])
            except Exception as e:
                print(f"列出目录 {full_path} 时出错: {e}")
            current = current[part]
        if update_tree_sign:
            self.file_tree_updated.emit(self.file_tree, path)

    def _remove_path_from_tree(self, path: str):
        parts = path.strip('/').split('/')
        current = self.file_tree.get('', {})
        for part in parts[:-1]:
            if part in current:
                current = current[part]
            else:
                return
        if parts and parts[-1] in current:
            del current[parts[-1]]
        self.file_tree_updated.emit(self.file_tree, path)

    def _get_directory_contents(self, path: str, node: Dict):
        try:
            for attr in self.sftp.listdir_attr(path):
                name = attr.filename
                full_path = f"{path.rstrip('/')}/{name}"
                if stat.S_ISLNK(attr.st_mode):
                    try:
                        target = self.sftp.stat(full_path)
                        if stat.S_ISDIR(target.st_mode):
                            node[name] = node.get(name, {})
                        else:
                            node[name] = "is_file"
                    except Exception:
                        node[name] = "is_symlink_broken"
                elif stat.S_ISDIR(attr.st_mode):
                    node[name] = node.get(name, {})
                else:
                    node[name] = "is_file"
        except Exception as e:
            self.error_occurred.emit(f"Error\n{e}")
            print(f"获取目录内容时出错: {e}")

    # ---------------------------
    # 刷新功能
    # ---------------------------
    def _refresh_paths_impl(self, paths: Optional[List[str]] = None):
        """线程内部刷新目录"""
        if self.sftp is None:
            print("_refresh_paths_impl: sftp 未就绪")
            return

        # 构建刷新列表
        if paths is None:
            to_refresh = []

            def walk_existing(node: Dict, cur_path: str):
                if not isinstance(node, dict):
                    return
                pathstr = '/' if cur_path == '' else cur_path
                to_refresh.append(pathstr)
                # 只遍历已有非空子目录
                for name, child in node.items():
                    if isinstance(child, dict) and child:  # 只有非空字典才继续
                        child_path = (cur_path.rstrip('/') + '/' +
                                      name) if cur_path else '/' + name
                        walk_existing(child, child_path)

            walk_existing(self.file_tree.get('', {}), '')
        else:
            to_refresh = [
                '/' + p.strip('/') if p.strip('/') else '/' for p in paths]

        # 去重
        dirs = list(dict.fromkeys(to_refresh))

        # 遍历刷新
        for directory in dirs:
            try:
                node = self._find_node_by_path(directory)
                if node is None:
                    if directory == '/':
                        if '' not in self.file_tree:
                            self.file_tree[''] = {}
                        node = self.file_tree['']
                    else:
                        parts = [p for p in directory.strip(
                            '/').split('/') if p]
                        if '' not in self.file_tree:
                            self.file_tree[''] = {}
                        cur = self.file_tree['']
                        for part in parts:
                            if part not in cur or cur[part] == "is_file":
                                cur[part] = {}
                            cur = cur[part]
                        node = cur

                try:
                    entries = self.sftp.listdir_attr(directory)
                except IOError as e:
                    print(
                        f"_refresh_paths_impl: listdir_attr({directory}) failed: {e}")
                    continue

                new_map = {}
                for attr in entries:
                    name = attr.filename
                    full = directory.rstrip(
                        '/') + '/' + name if directory != '/' else '/' + name
                    try:
                        if stat.S_ISLNK(attr.st_mode):
                            try:
                                tattr = self.sftp.stat(full)
                                if stat.S_ISDIR(tattr.st_mode):
                                    new_map[name] = node.get(name, {}) if isinstance(
                                        node.get(name), dict) else {}
                                else:
                                    new_map[name] = "is_file"
                            except Exception:
                                new_map[name] = "is_symlink_broken"
                        elif stat.S_ISDIR(attr.st_mode):
                            new_map[name] = node.get(name, {}) if isinstance(
                                node.get(name), dict) else {}
                        else:
                            new_map[name] = "is_file"
                    except Exception:
                        new_map[name] = "is_file"

                if not isinstance(node, dict):
                    if directory == '/':
                        self.file_tree[''] = new_map
                    else:
                        parent_path = '/' + \
                            '/'.join(directory.strip('/').split('/')
                                     [:-1]) if '/' in directory.strip('/') else '/'
                        parent_node = self._find_node_by_path(parent_path)
                        last_name = directory.strip('/').split('/')[-1]
                        if isinstance(parent_node, dict):
                            parent_node[last_name] = new_map
                else:
                    node.clear()
                    node.update(new_map)

            except Exception as e:
                print(f"_refresh_paths_impl error for {directory}: {e}")

        self.file_tree_updated.emit(self.file_tree, "")

    # ---------------------------
    # 辅助方法
    # ---------------------------
    def _remote_untar(self, remote_tar_path: str, target_dir: str, remove_tar: bool = True):
        """
        在远程服务器解压 tar.gz 文件

        :param remote_tar_path: 远程 tar.gz 文件完整路径
        :param target_dir: 解压到目标目录
        :param remove_tar: 是否解压后删除远程 tar.gz 文件
        """
        try:
            self.start_to_uncompression.emit(remote_tar_path)
            # 确保目标目录存在
            mkdir_cmd = f'mkdir -p "{target_dir}"'
            self._exec_remote_command(mkdir_cmd)

            # 解压 tar.gz
            untar_cmd = f'tar -xzf "{remote_tar_path}" -C "{target_dir}"'
            out, err = self._exec_remote_command(untar_cmd)

            if err:
                print(f"⚠️ Remote untar error: {err}")
            else:
                print(
                    f"✅ Remote untar completed: {remote_tar_path} -> {target_dir}")

            # 删除远程 tar.gz
            if remove_tar:
                rm_cmd = f'rm -f "{remote_tar_path}"'
                self._exec_remote_command(rm_cmd)
                print(f"🗑️ Remote tar.gz removed: {remote_tar_path}")

        except Exception as e:
            print(f"❌ Remote untar failed: {e}")
            import traceback
            traceback.print_exc()

    def _exec_remote_command(self, command: str):
        """
        在远程服务器执行命令
        :param command: shell 命令字符串
        :return: (stdout, stderr)
        """
        if not hasattr(self, "conn") or self.conn is None:
            print("SSH connection is not established")

        stdin, stdout, stderr = self.conn.exec_command(command)
        out = stdout.read().decode(errors="ignore")
        err = stderr.read().decode(errors="ignore")
        return out, err

    def _human_readable_size(self, size_bytes: int) -> str:
        """将字节数转换为可读的格式"""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        for unit in ["KB", "MB", "GB", "TB"]:
            size_bytes /= 1024.0
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
        return f"{size_bytes:.2f} PB"

    def _find_node_by_path(self, path: str) -> Optional[Dict]:
        if not path:
            return None
        if path == '/' or path.strip('/') == '':
            return self.file_tree.get('', {})

        parts = [p for p in path.strip('/').split('/') if p]
        node = self.file_tree.get('', {})
        for part in parts:
            if not isinstance(node, dict):
                return None
            if part not in node:
                return None
            node = node[part]
        return node if isinstance(node, dict) else None

    def get_file_tree(self) -> Dict:
        return self.file_tree

    def check_path_type(self, path: str):
        try:
            attr = self.sftp.lstat(path)
            if stat.S_ISDIR(attr.st_mode):
                return "directory"
            elif stat.S_ISREG(attr.st_mode):
                return "file"
            elif stat.S_ISLNK(attr.st_mode):
                try:
                    target = self.sftp.stat(path)
                    return "directory" if stat.S_ISDIR(target.st_mode) else "file"
                except Exception:
                    return "symlink_broken"
            else:
                return False
        except IOError:
            return False

    def check_path_type_list(self, paths: List[str]) -> Dict[str, str]:
        """
        Checks the type of multiple remote paths using a single shell command.
        Returns a dictionary mapping each path to its type ('directory', 'file', or 'unknown').
        This is a synchronous method and will block until the command completes.
        """
        if not paths or self.conn is None:
            return {p: 'unknown' for p in paths}

        quoted_paths = " ".join([shlex.quote(p) for p in paths])
        command = f"""
        for p in {quoted_paths}; do
            if [ -L "$p" ]; then
                if [ -d "$p" ]; then echo "directory:$p"; else echo "file:$p"; fi
            elif [ -d "$p" ]; then echo "directory:$p"
            elif [ -f "$p" ]; then echo "file:$p"
            else echo "unknown:$p"; fi
        done
        """

        try:
            stdin, stdout, stderr = self.conn.exec_command(command, timeout=20)
            exit_status = stdout.channel.recv_exit_status()
            output = stdout.read().decode('utf-8', errors='ignore').strip()
            error_output = stderr.read().decode('utf-8', errors='ignore').strip()

            if exit_status != 0:
                print(f"Error in check_path_type_list command: {error_output}")
                return {p: self.check_path_type(p) for p in paths}

            result = {}
            for line in output.splitlines():
                if not line:
                    continue
                try:
                    type_str, path_str = line.split(':', 1)
                    result[path_str] = type_str
                except ValueError:
                    print(
                        f"Could not parse line from check_path_type_list: {line}")
            # Ensure all paths get a result
            for p in paths:
                if p not in result:
                    result[p] = 'unknown'
            return result

        except Exception as e:
            print(f"Exception in check_path_type_list: {e}")
            return {p: self.check_path_type(p) for p in paths}

    def get_default_path(self) -> Optional[str]:
        try:
            if self.conn is None:
                print("SSH 连接未建立")
                return None
            stdin, stdout, stderr = self.conn.exec_command("pwd")
            exit_status = stdout.channel.recv_exit_status()
            path = stdout.read().decode('utf-8').strip()
            error = stderr.read().decode('utf-8').strip()
            if exit_status != 0 or error:
                print(f"执行 pwd 出错: {error}")
                return None
            return path
        except Exception as e:
            print(f"获取默认路径失败: {e}")
            return None

    def list_dir_simple(self, path: str) -> Optional[Dict[str, bool]]:
        """
        列出目录内容，返回 {name: True/False}
        True 表示目录，False 表示文件/其他
        """
        if self.sftp is None:
            print("list_dir_simple: sftp 未就绪")
            return None
        print(path)
        result: Dict[str, bool] = {}
        try:
            items = self.sftp.listdir_attr(path)
            # print(items)
            for attr in items:
                name = attr.filename
                full_path = f"{path.rstrip('/')}/{name}"

                if stat.S_ISDIR(attr.st_mode):
                    result[name] = True
                elif stat.S_ISLNK(attr.st_mode):
                    try:
                        target = self.sftp.stat(full_path)
                        result[name] = stat.S_ISDIR(target.st_mode)
                    except Exception:
                        result[name] = False
                else:
                    result[name] = False
            print(f"处理result完成 {result}")
            return result
        except Exception as e:
            print(f"list_dir_simple 获取目录内容时出错: {e}")
            return None

    def _fetch_user_group_maps(self):
        """
        Fetch and parse /etc/passwd and /etc/group to cache UID/GID mappings.
        """
        if self.conn is None:
            return

        # Fetch /etc/passwd
        try:
            stdin, stdout, stderr = self.conn.exec_command("cat /etc/passwd")
            passwd_content = stdout.read().decode('utf-8', errors='ignore')
            for line in passwd_content.strip().split('\n'):
                parts = line.split(':')
                if len(parts) >= 3:
                    username, _, uid = parts[0], parts[1], parts[2]
                    self.uid_map[int(uid)] = username
        except Exception as e:
            print(f"Could not fetch or parse /etc/passwd: {e}")

        # Fetch /etc/group
        try:
            stdin, stdout, stderr = self.conn.exec_command("cat /etc/group")
            group_content = stdout.read().decode('utf-8', errors='ignore')
            for line in group_content.strip().split('\n'):
                parts = line.split(':')
                if len(parts) >= 3:
                    groupname, _, gid = parts[0], parts[1], parts[2]
                    self.gid_map[int(gid)] = groupname
        except Exception as e:
            print(f"Could not fetch or parse /etc/group: {e}")

    def _get_owner_group(self, uid, gid):
        owner = self.uid_map.get(uid, str(uid))
        group = self.gid_map.get(gid, str(gid))
        return owner, group

    def list_dir_detailed(self, path: str) -> Optional[List[dict]]:
        if self.sftp is None:
            print("list_dir_detailed: sftp not ready")
            return None
        detailed_result = []
        try:
            for attr in self.sftp.listdir_attr(path):
                owner, group = self._get_owner_group(attr.st_uid, attr.st_gid)
                is_dir = stat.S_ISDIR(attr.st_mode)
                if stat.S_ISLNK(attr.st_mode):
                    try:
                        full_path = f"{path.rstrip('/')}/{attr.filename}"
                        target_attr = self.sftp.stat(full_path)
                        if stat.S_ISDIR(target_attr.st_mode):
                            is_dir = True
                    except Exception as e:
                        print(
                            f"Could not stat symlink target for {attr.filename}: {e}")

                detailed_result.append({
                    "name": attr.filename,
                    "is_dir": is_dir,
                    "size": attr.st_size,
                    "mtime": datetime.fromtimestamp(attr.st_mtime).strftime('%Y/%m/%d %H:%M'),
                    "perms": stat.filemode(attr.st_mode),
                    "owner": f"{owner}/{group}"
                })
            return detailed_result
        except Exception as e:
            print(
                f"list_dir_detailed error when getting directory contents: {e}")
            return None

    # ---------------------------
    # 删除功能实现
    # ---------------------------

    def _handle_delete_task(self, paths, callback=None):
        """
        Handles the deletion task for one or more remote paths.
        删除逻辑优化：一次性调用 rm -rf 删除多个路径，而不是逐个遍历。
        """
        if self.conn is None:
            error_msg = "SSH connection is not ready"
            print(f"❌ Deletion failed - {error_msg}: {paths}")
            self.delete_finished.emit(str(paths), False, error_msg)
            if callback:
                callback(False, error_msg)
            return

        # 统一成列表
        if isinstance(paths, str):
            paths = [paths]

        try:
            print(f"🗑️ Starting deletion of {len(paths)} paths")

            # 拼接命令，注意路径加引号防止空格问题
            quoted_paths = " ".join(f'"{p}"' for p in paths)
            cmd = f"rm -rf {quoted_paths}"
            print(f"🔧 Executing command: {cmd}")

            stdin, stdout, stderr = self.conn.exec_command(cmd)
            exit_status = stdout.channel.recv_exit_status()
            error_output = stderr.read().decode('utf-8').strip()

            if exit_status == 0:
                print(f"✅ Deletion successful: {paths}")

                # 计算所有父目录，刷新文件树
                parent_dirs = {os.path.dirname(p)
                               for p in paths if os.path.dirname(p)}
                if parent_dirs:
                    print(f"🔄 Refreshing parent directories: {parent_dirs}")
                    self.refresh_paths(list(parent_dirs))

                # 发信号：成功
                display_path = "Multiple files" if len(paths) > 1 else paths[0]
                self.delete_finished.emit(display_path, True, "")
                if callback:
                    callback(True, "")

            else:
                error_msg = f"Deletion failed: {error_output or 'Unknown error'}"
                print(f"❌ {error_msg}")
                display_path = "Multiple files" if len(paths) > 1 else paths[0]
                self.delete_finished.emit(display_path, False, error_msg)
                if callback:
                    callback(False, error_msg)

        except Exception as e:
            error_msg = f"Error during deletion: {str(e)}"
            print(f"❌ {error_msg}")
            traceback.print_exc()
            display_path = "Multiple files" if len(paths) > 1 else paths[0]
            self.delete_finished.emit(display_path, False, error_msg)
            if callback:
                callback(False, error_msg)

    # ---------------------------
    # 辅助方法 - 添加安全的路径处理
    # ---------------------------
    def _sanitize_path(self, path: str) -> str:
        """
        对路径进行基本的清理和安全检查
        """
        if not path or path.strip() == "":
            return ""

        # 移除多余的斜杠和空格
        sanitized = path.strip().rstrip('/')

        # 基本的安全检查（防止删除关键目录）
        critical_paths = ['/', '/root', '/home',
                          '/etc', '/bin', '/sbin', '/usr', '/var']
        if sanitized in critical_paths:
            raise ValueError(f"禁止删除关键目录: {sanitized}")

        return sanitized

    # 修改现有的 remove_path_force 方法，使其使用新的删除逻辑
    def remove_path_force(self, path: str) -> bool:
        """
        尝试删除指定路径（文件或文件夹），使用 rm -rf
        返回 True 表示删除成功，False 表示失败
        """
        try:
            sanitized_path = self._sanitize_path(path)
            if not sanitized_path:
                return False

            # 使用新的删除方法
            success = False
            error_msg = ""

            # 创建同步等待机制
            from PyQt5.QtCore import QEventLoop, QTimer
            loop = QEventLoop()

            def delete_callback(s, e):
                nonlocal success, error_msg
                success = s
                error_msg = e
                loop.quit()

            self.delete_path(sanitized_path, delete_callback)

            # 设置超时
            QTimer.singleShot(30000, loop.quit)  # 30秒超时

            loop.exec_()

            return success

        except Exception as e:
            print(f"删除路径 {path} 出错: {e}")
            return False


class FileManagerHandler:
    """负责处理 RemoteFileManager 的所有信号，避免匿名函数乱飞"""

    def __init__(self, file_manager: RemoteFileManager, session_widget, child_key, parent):
        self.fm = file_manager
        self.session_widget = session_widget
        self.child_key = child_key
        self.parent = parent  # main_window or whoever owns the callbacks

        # 绑定信号
        self._connect_signals()

    def _connect_signals(self):
        fm = self.fm
        ck = self.child_key

        fm.file_tree_updated.connect(
            lambda file_tree, path: self.parent.on_file_tree_updated(
                file_tree, self.session_widget, path)
        )
        fm.error_occurred.connect(self.parent.on_file_manager_error)

        fm.delete_finished.connect(
            partial(self._wrap_show_info, type_="delete"))
        fm.upload_finished.connect(
            partial(self._wrap_show_info, type_="upload"))
        fm.download_finished.connect(self._on_download_finished)
        fm.copy_finished.connect(self._on_copy_finished)
        fm.rename_finished.connect(self._on_rename_finished)
        fm.file_type_ready.connect(self._on_file_type_ready)
        fm.file_info_ready.connect(self._on_file_info_ready)
        fm.mkdir_finished.connect(partial(self._wrap_show_info, type_="mkdir"))

        # fm.start_to_compression.connect(
        #     partial(self._wrap_show_info, type_="compression"))
        # fm.start_to_uncompression.connect(
        #     partial(self._wrap_show_info, type_="uncompression"))

        fm.compression_finished.connect(self._on_compression_finished)
        fm.upload_progress.connect(partial(self._on_progress, mode="upload"))
        fm.download_progress.connect(
            partial(self._on_progress, mode="download"))

        self.session_widget.file_explorer.upload_file.connect(
            self._on_upload_request)

    # ---- 封装的槽函数 ----

    def _wrap_show_info(self, path, status, msg, type_, local_path=None, target_path=None, open_it=False):
        print(f"type : {type_}")
        self.parent._show_info(path, status, msg, type_, self.child_key,
                               local_path=local_path,  open_it=open_it)

    def _on_download_finished(self, remote_path, local_path, status, error_msg, open_it):
        self._wrap_show_info(remote_path, status, error_msg, "download",
                             local_path=local_path, open_it=open_it)

    def _on_copy_finished(self, source_path, target_path, status, error_msg):
        self._wrap_show_info(source_path, status, error_msg,
                             "paste", target_path=target_path)

    def _on_rename_finished(self, source_path, new_path, status, error_msg):
        self._wrap_show_info(source_path, status, error_msg,
                             "rename", local_path=new_path)

    def _on_file_type_ready(self, path, type_):
        self.parent._open_server_files(path, type_, self.child_key)

    def _on_file_info_ready(self, path, info, status, error_msg):
        self._wrap_show_info(path, status, error_msg, "info", local_path=info)

    def _on_compression_finished(self, identifier, new_name):
        self.parent._update_transfer_item_name(
            identifier, new_name, self.child_key)

    def _on_progress(self, path, percentage, bytes_so_far, total_bytes, mode):
        self.parent._show_progresses(path, percentage, bytes_so_far, total_bytes,
                                     self.child_key, mode)

    def _on_upload_request(self, local_path, remote_path, compression):
        self.parent._handle_upload_request(self.child_key, local_path, remote_path,
                                           compression, self.fm)

    def cleanup(self):
        """断开所有信号，防止 widget 删除后还有事件进来"""
        signals = [
            "file_tree_updated",
            "error_occurred",
            "sftp_ready",
            "upload_progress",
            "download_progress",
            "upload_finished",
            "delete_finished",
            "list_dir_finished",
            "path_check_result",
            "download_finished",
            "copy_finished",
            "rename_finished",
            "file_info_ready",
            "file_type_ready",
            "mkdir_finished",
            "start_to_compression",
            "start_to_uncompression",
            "compression_finished",
        ]

        for sig_name in signals:
            sig = getattr(self, sig_name, None)
            if sig is not None:
                try:
                    sig.disconnect()
                except (TypeError, RuntimeError):
                    # 信号没连接任何槽或已经断开，忽略
                    pass
</file>

<file path="tools/ssh.py">
import os
import re
import json
import traceback
import paramiko
from typing import Dict, List
from PyQt5.QtCore import QThread, QTimer, pyqtSignal
from tools.atool import resource_path
import binascii


class SSHWorker(QThread):
    result_ready = pyqtSignal(bytes)
    connected = pyqtSignal(bool, str)
    error_occurred = pyqtSignal(str)
    sys_resource = pyqtSignal(dict)
    file_tree_updated = pyqtSignal(dict)
    # host_key , processes_md5 key
    key_verification = pyqtSignal(str, str)
    stop_timer_sig = pyqtSignal()
    command_output_ready = pyqtSignal(str, int)

    def __init__(self, session_info, parent=None, for_resources=False, for_file=False):
        super().__init__(parent)
        self.host = session_info.host
        self.user = session_info.username
        self.port = session_info.port
        self.password = session_info.password
        self.auth_type = session_info.auth_type
        self.key_path = session_info.key_path
        # print(f"{self.host}  {self.user}  {self.password}")
        self.conn = None
        self.channel = None
        self.timer = None
        self.for_resources = for_resources
        self.for_file = for_file
        self._buffer = b""  # Storing incomplete output data

        # File tree structure
        self.file_tree: Dict = {}
        # Store the contents of each directory
        self.dir_contents: Dict[str, List[str]] = {}

        self.is_capturing = False
        self.capture_buffer = b""
        self.start_marker = ""
        self.end_marker = ""

    def get_hostkey_fp_hex(self) -> str:
        try:
            transport = self.conn.get_transport()
            if transport is None:
                return None
            host_key = transport.get_remote_server_key()
            if host_key is None:
                return None
            fp_bytes = host_key.get_fingerprint()
            if not fp_bytes:
                return None
            fp_hex = binascii.hexlify(fp_bytes).decode().lower()
            return fp_hex
        except Exception:
            return None

    def get_remote_md5(self, path):
        try:
            cmd = f"md5sum {path} 2>/dev/null | awk '{{print $1}}'"
            stdin, stdout, stderr = self.conn.exec_command(cmd, timeout=10)
            result = stdout.read().decode().strip()
            if result:
                return result
            else:
                return None
        except Exception:
            return None

    def run(self):
        try:
            self.conn = paramiko.SSHClient()
            self.conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            if self.auth_type == "password":
                self.conn.connect(self.host, username=self.user,
                                  password=self.password, timeout=10, port=self.port)
            else:
                self.conn.connect(self.host, username=self.user,
                                  key_filename=self.key_path, timeout=10, port=self.port)

            transport = self.conn.get_transport()
            self.channel = transport.open_session()
            self.channel.get_pty(term='xterm', width=120, height=30)
            self.channel.invoke_shell()
            self.connected.emit(True, "连接成功")

            # ---------- resources handling: ensure ./ .ssh/processes exists & is executable ----------
            if self.for_resources:
                try:
                    sftp = self.conn.open_sftp()
                    remote_dir = "./.ssh"
                    self.remote_proc = "./.ssh/processes.sh"
                    self.local_proc = resource_path(os.path.join(
                        "resource", "processes.sh"))
                    # ensure remote .ssh dir exists
                    try:
                        sftp.stat(remote_dir)
                    except IOError:
                        try:
                            sftp.mkdir(remote_dir, mode=0o700)
                            print(f"创建远端目录 {remote_dir}")
                        except Exception as e:
                            print(f"无法创建远端目录 {remote_dir}: {e}")

                    exists_remote_proc = True
                    try:
                        st = sftp.stat(self.remote_proc)
                        print(f"远端 processes 存在: {self.remote_proc}")
                    except IOError:
                        exists_remote_proc = False
                        print(f"远端 processes 不存在: {self.remote_proc}")

                    if exists_remote_proc:
                        try:
                            try:
                                current_mode = st.st_mode
                                new_mode = current_mode | 0o111
                                sftp.chmod(self.remote_proc, new_mode)
                            except Exception:
                                sftp.chmod(self.remote_proc, 0o755)
                            print(f"已将远端文件 {self.remote_proc} 设为可执行")
                        except Exception as e:
                            print(f"设为可执行失败: {e}")
                    else:

                        if not os.path.exists(self.local_proc):
                            err = f"本地 processes 文件不存在: {self.local_proc}"
                            print(err)
                            self.error_occurred.emit(err)
                        else:
                            try:
                                print(
                                    f"上传本地 {self.local_proc} 到远端 {self.remote_proc} ...")
                                sftp.put(self.local_proc, self.remote_proc)
                                try:
                                    sftp.chmod(self.remote_proc, 0o755)
                                except Exception:
                                    pass
                                print("上传并设置可执行成功")
                            except Exception as e:
                                tb = traceback.format_exc()
                                err = f"上传 processes 失败: {e}\n{tb}"
                                print(err)
                                self.error_occurred.emit(err)
                    try:
                        sftp.close()
                    except Exception:
                        pass
                except Exception as e:
                    tb = traceback.format_exc()
                    print(f"resources pre-check/upload 出错: {e}\n{tb}")
                    self.error_occurred.emit(
                        f"resources pre-check/upload 出错: {e}")

            self.timer = QTimer()
            self.stop_timer_sig.connect(self.timer.stop)
            self.timer.timeout.connect(self._check_output)
            self.timer.start(100)
            if self.for_resources:
                md5 = self.get_remote_md5(self.remote_proc)
                host_key = self.get_hostkey_fp_hex()
                self.key_verification.emit(md5, host_key)
                # print(md5, host_key)
                if self.user == "root":
                    cmd = f'./.ssh/processes.sh'
                    print("Running without sudo as root")
                else:
                    cmd = f'echo {self.password} | sudo -S ./.ssh/processes.sh'
                    print("Running with sudo as non-root")
                try:
                    self.run_command(cmd)
                    print("已启动远端 processes 可执行文件（./.ssh/processes）")
                except Exception as e:
                    print(f"启动 processes 失败：{e}")

            self.exec_()
            self._cleanup()

        except Exception as e:
            tb = traceback.format_exc()
            self.error_occurred.emit(f"{e}\n{tb}")

    def update_script(self):
        sftp = self.conn.open_sftp()
        try:
            print(
                f"上传本地 {self.local_proc} 到远端 {self.remote_proc} ...")
            sftp.put(self.local_proc, self.remote_proc)
            try:
                sftp.chmod(self.remote_proc, 0o755)
            except Exception:
                pass
            print("上传并设置可执行成功")
        except Exception as e:
            tb = traceback.format_exc()
            err = f"上传 processes 失败: {e}\n{tb}"
            print(err)
            self.error_occurred.emit(err)

    def disconnect_all_signals(self):
        signals = [
            self.result_ready,
            self.connected,
            self.error_occurred,
            self.sys_resource,
            self.file_tree_updated,
            self.key_verification,
            self.stop_timer_sig,
        ]
        for sig in signals:
            try:
                sig.disconnect()
            except TypeError:
                pass

    def _cleanup(self):
        try:
            if hasattr(self, "stop_timer_sig"):
                self.stop_timer_sig.emit()
        except Exception:
            pass

        try:
            if self.channel:
                self.channel.close()
        except Exception:
            pass
        try:
            if self.conn:
                self.conn.close()
        except Exception:
            pass
        self.disconnect_all_signals()
        # try:
        #     signals = [
        #         'result_ready', 'connected', 'error_occurred', 'sys_resource', 'file_tree_updated', 'stop_timer_sig'
        #     ]
        #     for sig_name in signals:
        #         sig = getattr(self, sig_name, None)
        #         if sig:
        #             try:
        #                 sig.disconnect()
        #             except Exception:
        #                 pass
        # except Exception:
        #     pass
        try:
            if self.isRunning():
                self.quit()
                # self.wait(2000)
        except Exception:
            pass

    def _check_output(self):
        try:
            if not self.channel:
                return
            if self.channel.recv_ready():
                chunk = self.channel.recv(4096)  # bytes
                self.result_ready.emit(chunk)
                if self.is_capturing:
                    self.capture_buffer += chunk
                    self._process_capture_buffer()
                elif self.for_resources:
                    self._buffer += chunk
                    self._process_sys_resource_buffer()

            if self.channel.closed or self.channel.exit_status_ready():
                while self.channel.recv_ready():
                    chunk = self.channel.recv(4096)
                    self.result_ready.emit(chunk)
                    if self.is_capturing:
                        self.capture_buffer += chunk
                        self._process_capture_buffer()
                    elif self.for_resources:
                        self._buffer += chunk
                        self._process_sys_resource_buffer()
                self.quit()
        except Exception as e:
            self.error_occurred.emit(str(e))

    def _process_sys_resource_buffer(self):
        """
        Extract the ///Start ... End/// or ///SysInfo ... End/// JSON from _buffer 
        and emit the sys_resource signal
        """
        try:
            text = self._buffer.decode(errors='ignore')
            # print(text)
            pattern = re.compile(r'///(SysInfo|Start)(.*?)End///', re.DOTALL)
            match = pattern.search(text)
            if match:
                tag, payload = match.groups()
                try:
                    data = json.loads(payload.strip())
                    if tag == "SysInfo":
                        data = {"type": "sysinfo", **data}
                    else:
                        data = {"type": "info", **data}
                    self.sys_resource.emit(data)
                except Exception:
                    pass

                last_end = match.end()
                self._buffer = self._buffer[last_end:]
        except Exception:
            pass

    def run_command(self, command=None, add_newline=True):
        """command can be str or bytes; if None, a newline is sent"""
        try:
            if not self.channel or self.channel.closed:
                return
            if command is None:
                payload = b"\n"
            else:
                if isinstance(command, bytes):
                    payload = command
                    if add_newline:
                        payload += b"\n"
                else:
                    payload = command.encode("utf-8")
                    if add_newline:
                        payload += b"\n"
            self.channel.send(payload)
        except Exception as e:
            self.error_occurred.emit(str(e))

    def resize_pty(self, cols: int, rows: int):
        try:
            if self.channel:
                self.channel.resize_pty(width=cols, height=rows)
        except Exception:
            pass

    def close(self):
        self._cleanup()

    def add_path_to_tree(self, path: str):
        """添加路径到文件树，并获取每个父目录下的文件夹"""
        if not self.for_file:
            return

        parts = path.strip('/').split('/')

        if '' not in self.file_tree:
            self.file_tree[''] = {}

        current = self.file_tree['']
        for i, part in enumerate(parts):
            full_path = '/' + '/'.join(parts[:i+1])
            if part not in current:
                current[part] = {}
                if i == len(parts) - 1:
                    self._get_directory_contents(full_path, current[part])

            current = current[part]

        self.file_tree_updated.emit(self.file_tree)

    def _get_directory_contents(self, path: str, node: Dict):
        try:
            command = f"ls -1 -p {path} | grep '/$' | sed 's#/$##'"
            self.run_command(command)
        except Exception as e:
            print(f"获取目录内容时出错: {e}")

    def remove_path_from_tree(self, path: str):
        if not self.for_file:
            return

        parts = path.strip('/').split('/')
        current = self.file_tree.get('', {})

        for i, part in enumerate(parts[:-1]):
            if part in current:
                current = current[part]
            else:
                return  # Path does not exist

        if parts and parts[-1] in current:
            del current[parts[-1]]

        self.file_tree_updated.emit(self.file_tree)

    def get_file_tree(self) -> Dict:
        return self.file_tree

    def execute_command_and_capture(self, command: str):
        import uuid
        if self.is_capturing:
            self.error_occurred.emit("Another command capture is already in progress.")
            return

        unique_id = str(uuid.uuid4())
        self.start_marker = f"START_CMD_MARKER_{unique_id}"
        self.end_marker = f"END_CMD_MARKER_{unique_id}"
        
        self.is_capturing = True
        self.capture_buffer = b""
        
        wrapped_command = f'echo "{self.start_marker}"; {command}; echo "{self.end_marker}:$?"\n'
        self.run_command(wrapped_command, add_newline=False)

    def _process_capture_buffer(self):
        try:
            start_bytes = self.start_marker.encode()
            end_bytes = self.end_marker.encode()
            
            if end_bytes in self.capture_buffer:
                start_pos = self.capture_buffer.find(start_bytes)
                end_pos = self.capture_buffer.rfind(end_bytes)
                
                if start_pos != -1:
                    content_start = start_pos + len(start_bytes)
                    exit_code_part = self.capture_buffer[end_pos + len(end_bytes):].strip()
                    
                    actual_content_bytes = self.capture_buffer[content_start:end_pos]
                    
                    first_newline = actual_content_bytes.find(b'\n')
                    if first_newline != -1:
                        actual_content_bytes = actual_content_bytes[first_newline+1:]

                    exit_code = -1
                    try:
                        exit_code_str = exit_code_part.split(b':')[-1].strip().decode()
                        exit_code = int(exit_code_str)
                    except (ValueError, IndexError):
                        pass

                    output_str = actual_content_bytes.decode('utf-8', errors='replace')
                    self.command_output_ready.emit(output_str, exit_code)

                self.is_capturing = False
                self.capture_buffer = b""
                self.start_marker = ""
                self.end_marker = ""
        except Exception as e:
            self.error_occurred.emit(f"Error processing command output: {e}")
            self.is_capturing = False
</file>

<file path="tools/transfer_worker.py">
# transfer_worker.py
import traceback
import paramiko
import os
import stat
import tarfile
import tempfile
from PyQt5.QtCore import QObject, QRunnable, pyqtSignal
import time


class TransferSignals(QObject):
    """
    Defines signals available for a transfer worker.
    """
    progress = pyqtSignal(str, int, int, int)
    # local_path_or_identifier, success, message
    finished = pyqtSignal(str, bool, str)
    # target_zip_path (for compression)
    start_to_compression = pyqtSignal(str)
    # remote_path (for uncompression)
    start_to_uncompression = pyqtSignal(str)
    compression_finished = pyqtSignal(str, str)


class TransferWorker(QRunnable):
    """
    A QRunnable worker for performing a single file/directory transfer operation (upload or download)
    in a separate thread from the QThreadPool.
    """

    def __init__(self, connection, action, local_path, remote_path, compression, download_context=None, upload_context=None, task_id=None, session_id=None):
        super().__init__()
        self.conn = connection  # Now receives an active connection
        self.action = action
        self.local_path = local_path
        self.remote_path = remote_path
        self.compression = compression
        self.download_context = download_context
        self.upload_context = upload_context
        self.task_id = task_id
        self.session_id = session_id
        self.signals = TransferSignals()
        self.sftp = None
        self.is_stopped = False

    def stop(self):
        self.is_stopped = True
        if self.sftp:
            try:
                self.sftp.close()
            except Exception as e:
                print(f"Error closing SFTP in worker stop: {e}")

    def run(self):
        """The main work of the thread. Uses a pre-established SSH connection to perform the transfer."""
        retry_delay = 1  # Delay in seconds between retries
        attempts = 0
        if self.task_id:
            identifier = self.task_id
        else:
            identifier = str(
                self.local_path if self.action == 'upload' else self.remote_path)
        self.signals.progress.emit(identifier, -1, 0, 0)

        while not self.is_stopped:
            try:
                if self.is_stopped:
                    break
                if not self.conn or not self.conn.get_transport() or not self.conn.get_transport().is_active():
                    raise Exception(
                        "SSH connection is not active or provided.")

                self.sftp = self.conn.open_sftp()

                if self.action == 'upload':
                    self._handle_upload_task(
                        identifier, self.local_path, self.remote_path, self.compression, self.upload_context)
                elif self.action == 'download':
                    self._download_files(
                        identifier, self.remote_path, self.compression)

                # If we reach here, the operation was successful
                return

            except paramiko.ssh_exception.ChannelException as e:
                attempts += 1
                tb = traceback.format_exc()
                print(
                    f"⚠️ ChannelException encountered (attempt {attempts}): {e}\n{tb}")
                print(
                    f"Retrying {identifier} in {retry_delay} second(s)...")
                time.sleep(retry_delay)
                # Loop will continue indefinitely
            except Exception as e:
                if self.is_stopped:
                    break
                tb = traceback.format_exc()
                error_msg = f"TransferWorker Error: {e}\n{tb}"
                print(f"❌ {error_msg}")
                self.signals.finished.emit(identifier, False, error_msg)
                # For non-recoverable errors, break the loop
                return
            finally:
                if self.sftp:
                    self.sftp.close()
                    self.sftp = None  # Reset sftp for next retry

        if self.is_stopped:
            identifier = str(
                self.local_path if self.action == 'upload' else self.remote_path)
            error_msg = "Transfer was cancelled by user."
            print(f"🛑 {error_msg} [{identifier}]")
            self.signals.finished.emit(identifier, False, error_msg)

    # ==================================================================================
    # == The following methods are adapted from RemoteFileManager for standalone execution ==
    # ==================================================================================

    def _handle_upload_task(self, identifier, local_path, remote_path, compression, upload_context=None):
        """
        Handles upload of a single file or list of files.
        Emits one finished signal per batch (for non-compressed lists).
        """
        try:
            if isinstance(local_path, list):
                if compression:
                    # Compressed list upload: whole list as one archive
                    self._upload_list_compressed(
                        identifier, local_path, remote_path)
                else:
                    # Non-compressed list: upload each file individually, but emit finished once at the end
                    all_successful = True
                    error_messages = []

                    for path in local_path:
                        if not os.path.exists(path):
                            error_msg = f"Local path does not exist: {path}"
                            all_successful = False
                            error_messages.append(error_msg)
                            continue

                        try:
                            if os.path.isfile(path):
                                self._upload_file(
                                    path, path, remote_path, upload_context)
                            elif os.path.isdir(path):
                                # Non-compressed directory: upload files inside directory
                                for root, _, files in os.walk(path):
                                    for f in files:
                                        local_file = os.path.join(root, f)
                                        self._upload_file(
                                            local_file, local_file, remote_path, upload_context)
                        except Exception as e:
                            tb = traceback.format_exc()
                            all_successful = False
                            error_messages.append(
                                f"Failed to upload {path}: {e}\n{tb}")

                    # Emit a single finished signal for the whole batch
                    final_msg = "; ".join(error_messages)
                    print(f"发送上传钩子:{all_successful}")
                    self.signals.finished.emit(
                        identifier, all_successful, final_msg)

            elif isinstance(local_path, str):
                # Single file or directory
                status, msg = self._upload_item(identifier, local_path,
                                                remote_path, compression, upload_context)
                self.signals.finished.emit(
                    identifier, status, msg)
        except Exception as e:
            tb = traceback.format_exc()
            error_msg = f"Error during upload task: {e}\n{tb}"
            print(f"❌ {error_msg}")
            self.signals.finished.emit(identifier, False, error_msg)

    def _upload_item(self, identifier, item_path, remote_path, compression, upload_context=None):
        """Returns (bool, str) for success status and message, and also emits signals."""
        if not os.path.exists(item_path):
            error_msg = f"Local path does not exist: {item_path}"
            self.signals.finished.emit(item_path, False, error_msg)
            return False, error_msg

        try:
            if compression:
                self._upload_compressed(item_path, item_path, remote_path)
            else:
                if os.path.isfile(item_path):
                    self._upload_file(
                        item_path, item_path, remote_path, upload_context)
                elif os.path.isdir(item_path):
                    # This should no longer be called for non-compressed directory uploads
                    # as the dispatcher breaks them down into files.
                    self._upload_directory(item_path, item_path, remote_path)

            return True, ""
        except Exception as e:
            traceback.print_exc()
            error_msg = f"Failed to upload {item_path}: {e}"
            self.signals.finished.emit(item_path, False, error_msg)
            return False, error_msg

    def _upload_list_compressed(self, identifier, path_list, remote_path):
        tmp_dir = "tmp"
        os.makedirs(tmp_dir, exist_ok=True)
        tmp_fd, tmp_tar_path = tempfile.mkstemp(suffix=".tar.gz", dir=tmp_dir)
        os.close(tmp_fd)
        self.signals.start_to_compression.emit(tmp_tar_path)
        try:
            with tarfile.open(tmp_tar_path, mode="w:gz") as tf:
                for path in path_list:
                    if not os.path.exists(path):
                        continue
                    arcname = os.path.basename(path)
                    tf.add(path, arcname=arcname)
            self.signals.compression_finished.emit(
                identifier, os.path.basename(tmp_tar_path))
            self._upload_file(
                identifier, tmp_tar_path, remote_path)
            remote_zip_path = f"{remote_path.rstrip('/')}/{os.path.basename(tmp_tar_path)}"
            self._remote_untar(remote_zip_path, remote_path)
            self.signals.finished.emit(identifier, True, "")
        except Exception as e:
            tb = traceback.format_exc()
            error_msg = f"Compressed list upload error: {e}\n{tb}"
            self.signals.finished.emit(identifier, False, error_msg)
            raise e
        finally:
            if os.path.exists(tmp_tar_path):
                os.remove(tmp_tar_path)

    def _upload_compressed(self, identifier, local_path, remote_path):
        tmp_dir = "tmp"
        os.makedirs(tmp_dir, exist_ok=True)
        tmp_fd, tmp_tar_path = tempfile.mkstemp(suffix=".tar.gz", dir=tmp_dir)
        os.close(tmp_fd)
        self.signals.start_to_compression.emit(tmp_tar_path)
        try:
            with tarfile.open(tmp_tar_path, mode="w:gz") as tf:
                arcname = os.path.basename(local_path)
                tf.add(local_path, arcname=arcname)

            self.signals.compression_finished.emit(
                identifier, os.path.basename(tmp_tar_path))
            self._upload_file(
                identifier, tmp_tar_path, remote_path, emit_finish_signal=False)
            remote_zip_path = f"{remote_path.rstrip('/')}/{os.path.basename(tmp_tar_path)}"
            self._remote_untar(remote_zip_path, remote_path)
            self.signals.finished.emit(identifier, True, "")
        except Exception as e:
            tb = traceback.format_exc()
            error_msg = f"Compressed upload error: {e}\n{tb}"
            self.signals.finished.emit(identifier, False, error_msg)
            raise e
        finally:
            if os.path.exists(tmp_tar_path):
                os.remove(tmp_tar_path)

    def _upload_file(self, identifier, local_path, remote_path, upload_context=None):
        """
        Upload a single file, emitting progress signals.
        Does NOT emit finished signal (handled at batch level).
        """
        try:
            if upload_context:
                relative_path = os.path.relpath(local_path, upload_context)
                upload_root_name = os.path.basename(upload_context)
                full_remote_path = os.path.join(
                    remote_path, upload_root_name, relative_path).replace('\\', '/')
            else:
                full_remote_path = os.path.join(
                    remote_path, os.path.basename(local_path)).replace('\\', '/')

            # Ensure remote parent directory exists
            self._ensure_remote_directory_exists(
                os.path.dirname(full_remote_path))

            def progress_callback(bytes_so_far, total_bytes):
                if total_bytes > 0:
                    progress = int((bytes_so_far / total_bytes) * 100)
                    self.signals.progress.emit(
                        identifier, progress, bytes_so_far, total_bytes)

            self.sftp.put(local_path, full_remote_path,
                          callback=progress_callback)

        except Exception as e:
            raise e

    def _upload_directory(self, identifier, local_dir, remote_dir):
        try:
            dir_name = os.path.basename(local_dir)
            target_remote_dir = os.path.join(
                remote_dir, dir_name).replace('\\', '/')
            self._ensure_remote_directory_exists(target_remote_dir)

            total_size = sum(os.path.getsize(os.path.join(root, file))
                             for root, _, files in os.walk(local_dir) for file in files)
            uploaded_size = 0

            for root, dirs, files in os.walk(local_dir):
                relative_path = os.path.relpath(root, local_dir)
                current_remote_dir = os.path.join(target_remote_dir, relative_path).replace(
                    '\\', '/') if relative_path != '.' else target_remote_dir

                self._ensure_remote_directory_exists(current_remote_dir)

                for file in files:
                    local_file_path = os.path.join(root, file)
                    remote_file_path = os.path.join(
                        current_remote_dir, file).replace('\\', '/')

                    file_size = os.path.getsize(local_file_path)
                    self.sftp.put(local_file_path, remote_file_path)
                    uploaded_size += file_size
                    progress = int((uploaded_size / total_size)
                                   * 100) if total_size > 0 else 100
                    self.signals.progress.emit(identifier, progress)

            self.signals.finished.emit(
                identifier, True, "Directory upload completed.")
        except Exception as e:
            tb = traceback.format_exc()
            error_msg = f"Directory upload error: {e}\n{tb}"
            self.signals.finished.emit(identifier, False, error_msg)

    def _download_files(self, identifier, remote_path, compression):
        # 根据 open_it 标志决定本地基础路径
        if hasattr(self, '_open_it') and self._open_it and self.session_id:
            # 双击编辑：使用会话隔离的编辑目录
            local_base = os.path.join("tmp", "edit", self.session_id)
        else:
            # 常规下载：使用原有的下载目录
            local_base = "_ssh_download"
        
        os.makedirs(local_base, exist_ok=True)
        paths = [remote_path] if isinstance(remote_path, str) else remote_path
        print(f"download1 : {remote_path}")
        try:
            if compression:
                # Simplified compression logic for now
                remote_tar = self._remote_tar(paths)
                if not remote_tar:
                    raise Exception("Failed to create remote tar file.")

                local_tar_path = os.path.join(
                    local_base, os.path.basename(remote_tar))

                def progress_callback(bytes_so_far, total_bytes):
                    if total_bytes > 0:
                        progress = int((bytes_so_far / total_bytes) * 100)
                        # We can perhaps divide progress for different stages
                        # Assuming download is the main part
                        self.signals.progress.emit(
                            identifier, progress, bytes_so_far, total_bytes)

                self.sftp.get(remote_tar, local_tar_path,
                              callback=progress_callback)

                with tarfile.open(local_tar_path, "r:gz") as tar:
                    tar.extractall(local_base)

                self._exec_remote_command(f'rm -f "{remote_tar}"')
                os.remove(local_tar_path)

                self.signals.finished.emit(identifier, True, local_base)

            else:  # Non-compressed
                # For non-compressed, _download_item will handle its own signals.
                for p in paths:
                    # Each item is its own task, so the identifier is the path itself.
                    self._download_item(p, p, local_base)
                # A batch 'finished' signal is not sent here, to allow individual tracking.

        except Exception as e:
            tb = traceback.format_exc()
            error_msg = f"Error during download task: {e}\n{tb}"
            print(f"❌ {error_msg}")
            self.signals.finished.emit(identifier, False, error_msg)

    def _download_item(self, identifier, remote_item_path, local_base_path):
        """Downloads a single item (file or directory) and emits a finished signal for it."""
        try:
            # 根据 open_it 标志决定本地路径构建方式
            if hasattr(self, '_open_it') and self._open_it and self.session_id:
                # 双击编辑模式：镜像远程路径结构
                # 移除远程路径开头的斜杠，然后拼接到 local_base_path
                remote_path_normalized = remote_item_path.lstrip('/')
                local_target = os.path.join(local_base_path, remote_path_normalized)
            else:
                # 常规下载模式：保持原有逻辑
                # Determine local path, preserving directory structure if context is given
                if self.download_context:
                    if remote_item_path.startswith(self.download_context):
                        # The download root itself should be included in the local path
                        download_root_name = os.path.basename(
                            self.download_context.rstrip('/'))
                        relative_path = os.path.relpath(
                            remote_item_path, self.download_context)
                        local_target = os.path.join(
                            local_base_path, download_root_name, relative_path)
                    else:  # Fallback for safety
                        local_target = os.path.join(
                            local_base_path, os.path.basename(remote_item_path.rstrip("/")))
                else:
                    local_target = os.path.join(
                        local_base_path, os.path.basename(remote_item_path.rstrip("/")))

            # Ensure local directory exists
            os.makedirs(os.path.dirname(local_target), exist_ok=True)

            # Since dispatcher now only sends files for non-compressed, we can simplify this.
            # We still check to be robust.
            attr = self.sftp.stat(remote_item_path)
            if stat.S_ISDIR(attr.st_mode):
                # This part should ideally not be hit in the new flow for non-compressed downloads
                self._download_directory(
                    identifier, remote_item_path, local_target)
            else:
                self._download_file(
                    identifier, remote_item_path, local_target)

            if hasattr(self, '_download_callback'):
                self._download_callback(identifier, True, local_target)
            else:
                self.signals.finished.emit(identifier, True, local_target)

        except Exception as e:
            tb = traceback.format_exc()
            error_msg = f"Failed to download {remote_item_path}: {e}\n{tb}"
            if hasattr(self, '_download_callback'):
                self._download_callback(identifier, False, error_msg)
            else:
                self.signals.finished.emit(identifier, False, error_msg)

    def _download_file(self, identifier, remote_file, local_file):
        def progress_callback(bytes_so_far, total_bytes):
            if total_bytes > 0:
                progress = int((bytes_so_far / total_bytes) * 100)
                self.signals.progress.emit(
                    identifier, progress, bytes_so_far, total_bytes)

        self.sftp.get(remote_file, local_file, callback=progress_callback)

    def _download_directory(self, identifier, remote_dir, local_dir):
        os.makedirs(local_dir, exist_ok=True)
        # This simplified version won't have accurate progress for directory downloads
        # A more complex implementation would be needed to calculate total size first.
        for entry in self.sftp.listdir_attr(remote_dir):
            remote_item = f"{remote_dir.rstrip('/')}/{entry.filename}"
            local_item = os.path.join(local_dir, entry.filename)
            if stat.S_ISDIR(entry.st_mode):
                self._download_directory(identifier, remote_item, local_item)
            else:
                # No progress for individual files in a dir download for now
                self.sftp.get(remote_item, local_item)

    def _remote_tar(self, paths):
        if not paths:
            return None
        common_path = os.path.dirname(paths[0]).replace('\\', '/')
        tar_name = f"archive_{os.path.basename(paths[0])}.tar.gz"
        remote_tar_path = f"{common_path}/{tar_name}"

        files_to_tar = ' '.join([f'"{os.path.basename(p)}"' for p in paths])

        cmd = f'cd "{common_path}" && tar -czf "{tar_name}" {files_to_tar}'
        out, err = self._exec_remote_command(cmd)
        if err:
            print(f"Error creating remote tar: {err}")
            return None
        return remote_tar_path

    def _ensure_remote_directory_exists(self, remote_dir):
        parts = remote_dir.strip('/').split('/')
        current_path = ''
        for part in parts:
            current_path = f"{current_path}/{part}" if current_path else f"/{part}"
            try:
                self.sftp.stat(current_path)
            except FileNotFoundError:
                self.sftp.mkdir(current_path)

    def _remote_untar(self, remote_tar_path, target_dir):
        self.signals.start_to_uncompression.emit(remote_tar_path)
        self._ensure_remote_directory_exists(target_dir)
        untar_cmd = f'tar -xzf "{remote_tar_path}" -C "{target_dir}"'
        self._exec_remote_command(untar_cmd)
        rm_cmd = f'rm -f "{remote_tar_path}"'
        self._exec_remote_command(rm_cmd)

    def _exec_remote_command(self, command):
        stdin, stdout, stderr = self.conn.exec_command(command)
        out = stdout.read().decode(errors="ignore")
        err = stderr.read().decode(errors="ignore")
        return out, err
</file>

<file path="widgets/command_input.py">
from PyQt5.QtCore import Qt, pyqtSignal, QRect, QPoint, QEvent, QStringListModel, QTimer
from PyQt5.QtGui import QFont, QFontMetrics
from PyQt5.QtWidgets import QApplication, QHBoxLayout, QWidget, QFrame, QVBoxLayout, QLabel
from qfluentwidgets import TextEdit, ListView, VBoxLayout, ToolButton, FluentIcon
import re
import json


class OneSuggestionPopup(QFrame):
    def __init__(self, parent=None, max_width=440):
        super().__init__(parent, Qt.Tool | Qt.FramelessWindowHint)
        self.suggestion_accepted = False
        self.max_width = max_width
        self.is_error_state = False  # 新增错误状态标记
        self.is_loading_state = False  # 新增加载状态标记

        self.setMinimumSize(150, 50)
        self.setAttribute(Qt.WA_ShowWithoutActivating)
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        self.setFocusPolicy(Qt.NoFocus)

        self.setObjectName("one_sugg_popup")
        self.setStyleSheet("""
            QFrame#one_sugg_popup {
                border-radius: 12px;
                background: rgb(29,29,29);
                border: 1px solid rgba(255,255,255,10);
            }
            QLabel { color: #FFFFFF; padding: 4px 8px; }
            QLabel#cmd_label { font-family: "Courier New", monospace; }
            QLabel#error_label { color: #FF6B6B; }  /* 错误样式 */
            QLabel#loading_label { color: #4ECDC4; }  /* 加载样式 */
        """)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)

        # 解释标签 - 支持不同状态
        self.expl_label = QLabel("", self)
        self.expl_label.setWordWrap(True)
        self.expl_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)

        font = QFont()
        font.setPointSize(10)
        font.setStyleStrategy(QFont.PreferAntialias)
        self.expl_label.setFont(font)

        # 命令标签
        self.cmd_label = QLabel("", self)
        self.cmd_label.setWordWrap(True)
        self.cmd_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        self.cmd_label.setFont(QFont("Courier New", 10))
        self.cmd_label.setObjectName("cmd_label")
        self.cmd_label.setStyleSheet("color: #00FF00; padding: 4px;")

        layout.addWidget(self.expl_label)
        layout.addWidget(self.cmd_label)

        self.hide()

    def show_suggestion(self, explanation: str = None, command: str = None,
                        input_widget=None, is_error=False, is_loading=False):
        """显示建议弹窗

        Args:
            explanation: 解释文本
            command: 命令文本
            input_widget: 关联的输入控件
            is_error: 是否为错误状态
            is_loading: 是否为加载状态
        """
        # 重置状态
        self.is_error_state = is_error
        self.is_loading_state = is_loading

        # 根据状态设置样式
        if is_error:
            self.expl_label.setObjectName("error_label")
            self.setStyleSheet(self.styleSheet() + """
                QFrame#one_sugg_popup { border: 1px solid #FF6B6B; }
            """)
        elif is_loading:
            self.expl_label.setObjectName("loading_label")
            self.setStyleSheet(self.styleSheet() + """
                QFrame#one_sugg_popup { border: 1px solid #4ECDC4; }
            """)
        else:
            self.expl_label.setObjectName("")
            self.setStyleSheet(self.styleSheet() + """
                QFrame#one_sugg_popup { border: 1px solid rgba(255,255,255,10); }
            """)

        # 更新内容
        if explanation is not None:
            self.expl_label.setText(explanation)
        if command is not None:
            self.cmd_label.setText(command)

        # 错误状态下隐藏命令显示
        if is_error:
            self.cmd_label.hide()
        else:
            self.cmd_label.show()

        # 计算和调整大小
        self._adjust_size()

        # 定位到输入控件
        if input_widget:
            self._position_relative_to_widget(input_widget)

        self.show()

    def _adjust_size(self):
        """调整弹窗大小"""
        fm_expl = QFontMetrics(self.expl_label.font())
        fm_cmd = QFontMetrics(self.cmd_label.font())

        expl_width = max([fm_expl.horizontalAdvance(line)
                          for line in self.expl_label.text().split('\n')] + [0])
        cmd_width = max([fm_cmd.horizontalAdvance(line)
                        for line in self.cmd_label.text().split('\n')] + [0])

        raw_width = max(expl_width, cmd_width) + 16
        min_width = 200
        desired_w = max(min_width, min(self.max_width, raw_width))

        self.expl_label.setFixedWidth(desired_w - 8)
        if not self.is_error_state:  # 错误状态下不调整命令标签
            self.cmd_label.setFixedWidth(desired_w - 8)

        self.expl_label.adjustSize()
        if not self.is_error_state:
            self.cmd_label.adjustSize()
        self.adjustSize()

    def _position_relative_to_widget(self, input_widget):
        """相对于输入控件定位"""
        rect = input_widget.rect()
        top_left = input_widget.mapToGlobal(rect.topLeft())

        x = top_left.x()
        y = top_left.y() - self.height() - 6

        screen_geo = QApplication.desktop().availableGeometry(input_widget)
        if y < screen_geo.top():
            y = input_widget.mapToGlobal(rect.bottomLeft()).y() + 6
        if x + self.width() > screen_geo.right():
            x = max(screen_geo.left(), screen_geo.right() - self.width() - 6)

        self.move(QPoint(x, y))

    def hide_suggestion(self):
        """隐藏建议并重置状态"""
        self.is_error_state = False
        self.is_loading_state = False
        self.hide()

    def start_loading_animation(self, parent_widget):
        """开始加载动画"""
        self.is_loading_state = True
        if hasattr(parent_widget, 'timer') and not parent_widget.timer.isActive():
            parent_widget.frame_index = 0
            parent_widget.timer.start(500)  # 500ms 间隔

    def stop_loading_animation(self, parent_widget):
        """停止加载动画"""
        self.is_loading_state = False
        if hasattr(parent_widget, 'timer') and parent_widget.timer.isActive():
            parent_widget.timer.stop()

    def set_font(self, font):
        self.expl_label.setFont(font)
        self.cmd_label.setFont(font)


class CommandInput(TextEdit):
    executeCommand = pyqtSignal(str)
    clear_history_ = pyqtSignal()

    def __init__(self, font_name, use_ai, parent=None):
        super().__init__(parent)
        self.use_ai = use_ai
        font = QFont(font_name)
        self.partial_output = ""
        self.suggestionpopup = OneSuggestionPopup(self, max_width=440)
        self.suggestionpopup.set_font(font)
        self.setFont(font)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_frame)
        self.frames = [".", "..", "..."]
        self.frame_index = 0
        self._history_model = QStringListModel()

        self._history_view = ListView(None)
        self._history_view.setModel(self._history_model)
        self._history_view.setSelectionMode(ListView.SingleSelection)
        self._history_view.setEditTriggers(ListView.NoEditTriggers)
        self._history_view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self._history_view.clicked.connect(self._on_history_index_clicked)
        self._history_view.activated.connect(self._on_history_index_activated)
        self._history_view.setFocusPolicy(Qt.NoFocus)

        flags = Qt.Tool | Qt.FramelessWindowHint
        self._history_popup = QWidget(None, flags)
        self._history_popup.setAttribute(Qt.WA_TranslucentBackground, False)
        self._history_popup.setWindowOpacity(1.0)
        self._history_popup.setAttribute(Qt.WA_ShowWithoutActivating, True)
        self._history_popup.setFocusPolicy(Qt.NoFocus)

        layout = VBoxLayout(self._history_popup)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        toolbar = QHBoxLayout()
        toolbar.setContentsMargins(0, 0, 0, 0)

        clear_btn = ToolButton(FluentIcon.BROOM, self)
        clear_btn.setFixedSize(22, 22)
        clear_btn.setFocusPolicy(Qt.NoFocus)
        clear_btn.setToolTip(self.tr("Clean History"))
        clear_btn.setStyleSheet("""
            PushButton {
                border: none;
                color: rgb(180, 180, 180);
                font-weight: bold;
                background: transparent;
                font-size: 14px;
            }
            PushButton:hover {
                color: white;
                background-color: rgb(60, 60, 60);
                border-radius: 11px;
            }
        """)
        clear_btn.clicked.connect(self.clear_history)

        toolbar.addStretch()
        toolbar.addWidget(clear_btn)

        layout.addLayout(toolbar)
        layout.addWidget(self._history_view)

        self._history_popup.setStyleSheet("""
            QWidget {
                background-color: rgb(29, 29, 29);
                border: 1px solid rgb(50, 50, 50);
                border-radius: 8px;
            }
            ListView::item {
                height: 24px;
                padding: 2px 8px;
                color: rgb(220, 220, 220);
            }
            ListView::item:hover {
                background-color: rgb(45, 45, 45);
                border-radius: 4px;
            }
            ListView::item:selected {
                background-color: rgb(70, 70, 70);
                border-radius: 4px;
                color: white;
            }
        """)

        self._history = []

        QApplication.instance().installEventFilter(self)

        self.textChanged.connect(self._on_text_changed)

    def add_history(self, cmd):
        if isinstance(cmd, (list, tuple)):
            for c in cmd:
                self.add_history(c)
            return

        cmd = (cmd or "").strip()
        if not cmd:
            return

        if cmd in self._history:
            self._history.remove(cmd)
        self._history.insert(0, cmd)

        self._refresh_history_model(self.toPlainText())

    def remove_history(self, cmd: str):
        while cmd in self._history:
            self._history.remove(cmd)
        self._refresh_history_model(self.toPlainText())

    def clear_history(self):
        self._history.clear()
        self._refresh_history_model(self.toPlainText())
        self.hide_history()
        self.clear_history_.emit()

    def _on_text_changed(self):
        current = self.toPlainText()
        self._refresh_history_model(current)

    def _refresh_history_model(self, filter_text: str):
        if not self._history:
            self._history_model.setStringList([])
            return

        ft = (filter_text or "").strip().lower()

        if ft == "":
            display_list = list(self._history)
        else:
            starts = []
            contains = []
            others = []
            for idx, h in enumerate(self._history):
                h_lower = h.lower()
                if h_lower.startswith(ft):
                    starts.append((idx, h))
                elif ft in h_lower:
                    contains.append((idx, h))
                else:
                    others.append((idx, h))
            display_list = [h for _, h in starts] + \
                [h for _, h in contains] + [h for _, h in others]

        self._history_model.setStringList(display_list)

        if self._history_popup.isVisible():
            if self._history_model.rowCount() > 0:
                idx0 = self._history_model.index(0, 0)
                if idx0.isValid():
                    self._history_view.setCurrentIndex(idx0)

    def show_history(self):
        if self._history_model.rowCount() == 0:
            return

        self._refresh_history_model(self.toPlainText())
        self._adjust_history_popup_position()
        self._history_popup.show()
        self._history_popup.raise_()
        self.setFocus()

        if not self._history_view.selectionModel().hasSelection():
            idx = self._history_model.index(0, 0)
            if idx.isValid():
                self._history_view.setCurrentIndex(idx)

    def hide_history(self):
        if self._history_popup.isVisible():
            self._history_popup.hide()
            self.setFocus()

    def toggle_history(self):
        if self._history_popup.isVisible():
            self.hide_history()
        else:
            self.show_history()

    def _adjust_history_popup_position(self):
        global_pos = self.mapToGlobal(QPoint(0, 0))
        input_rect = QRect(global_pos, self.size())

        screen = QApplication.screenAt(global_pos)
        screen_geom = screen.availableGeometry(
        ) if screen else QApplication.desktop().availableGeometry()

        count = max(0, self._history_model.rowCount())
        fm = self.fontMetrics()
        row_h = fm.height() + 4
        max_rows = min(10, max(1, count))
        popup_h = min(300, row_h * max_rows + 30)
        popup_w = max(self.width(), 220)

        x = input_rect.left()
        y_above = input_rect.top() - popup_h
        y_below = input_rect.bottom()

        if y_above >= screen_geom.top():
            y = y_above
        else:
            if y_below + popup_h <= screen_geom.bottom():
                y = y_below
            else:
                y = max(screen_geom.top(), screen_geom.bottom() - popup_h)

        self._history_popup.setGeometry(x, y, popup_w, popup_h)

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Escape:
            self.hide_history()
            self.suggestionpopup.hide()
            return

        # 如果 popup 可见，把方向键 / 回车 转发给 listview（即使输入框仍然聚焦）
        if self._history_popup.isVisible():
            if event.key() in (Qt.Key_Up, Qt.Key_Down, Qt.Key_Home, Qt.Key_End):
                QApplication.sendEvent(self._history_view, event)
                return
            elif event.key() in (Qt.Key_Return, Qt.Key_Enter):
                self._on_history_index_activated()
                return

        # Alt 切换历史
        if event.key() == Qt.Key_Alt:
            self.toggle_history()
            return

        if event.key() == Qt.Key_O and event.modifiers() == Qt.ControlModifier:

            print("pressed Alt+O")
            if self.use_ai:
                self._generate()
                return

        if event.key() == Qt.Key_Tab and self.suggestionpopup.isVisible():
            # accept suggestion
            suggested = self.suggestionpopup.cmd_label.text()
            if suggested:
                self.setText(suggested)
                self.setFocus()
                # self.setCursorPosition(len(suggested))
            self.suggestionpopup.hide()

            return

        if event.key() == Qt.Key_Up:
            cursor = self.textCursor()
            at_start = cursor.position() == 0 and cursor.blockNumber() == 0
            if at_start:
                self.show_history()
                return

        if event.key() in (Qt.Key_Return, Qt.Key_Enter):
            if not (event.modifiers() & Qt.ShiftModifier):
                command = self.toPlainText()
                self.executeCommand.emit(command)
                self.add_history(command)
                if command.strip():
                    self.add_history(command)
                self.clear()
                return
            else:
                super().keyPressEvent(event)
                return

        super().keyPressEvent(event)

    def focusOutEvent(self, event):
        new_focus = QApplication.focusWidget()
        if new_focus is None or not (
            new_focus is self._history_popup
            or self._history_popup.isAncestorOf(new_focus)
            or new_focus is self
            or self.isAncestorOf(new_focus)
        ):
            self.hide_history()
            self.suggestionpopup.hide()
        super().focusOutEvent(event)

    def eventFilter(self, obj, event):
        if event.type() == QEvent.MouseButtonPress:
            if self._history_popup.isVisible():
                w = QApplication.widgetAt(event.globalPos())
                if w is None:
                    self.hide_history()
                else:
                    if not (
                        w is self._history_popup
                        or self._history_popup.isAncestorOf(w)
                        or w is self
                        or self.isAncestorOf(w)
                    ):
                        self.hide_history()
        return super().eventFilter(obj, event)

    def _on_history_index_clicked(self, index):
        if index and index.isValid():
            self._fill_from_history(index.data())
            self.hide_history()

    def _on_history_index_activated(self, index=None):
        if index is None:
            index = self._history_view.currentIndex()
        if index and index.isValid():
            self._fill_from_history(index.data())
        self.hide_history()

    def _fill_from_history(self, cmd: str):
        self.setPlainText(cmd)
        cursor = self.textCursor()
        cursor.movePosition(cursor.End)
        self.setTextCursor(cursor)
        self.setFocus()

    def find_parent_with_llm(self):
        parent = self.parent()
        while parent is not None:
            if hasattr(parent, "llm"):
                return parent
            parent = parent.parent()
        return None

    def _on_partial_result(self, msg: str):

        self.partial_output += msg

        cmd_match = re.search(
            r'"command"\s*:\s*(\[[^\]]*\])', self.partial_output, re.S)
        if cmd_match:
            try:
                commands = json.loads(cmd_match.group(1))
                self.timer.stop()

                command, lines = commands
                if command:
                    self.suggestionpopup.show_suggestion(
                        command=command, input_widget=self)
                else:
                    self.suggestionpopup.hide()

            except Exception:
                pass

        exp_match = re.search(
            r'"explanation"\s*:\s*"([^"]*)', self.partial_output, re.S)
        if exp_match:
            print(exp_match.group(1))
            self.suggestionpopup.show_suggestion(
                explanation=exp_match.group(1), input_widget=self)

    def clear_out(self):
        self.partial_output = ""

    def suggestion_error(self, msg):
        if hasattr(self, 'timer') and self.timer.isActive():
            self.timer.stop()

        if self.suggestionpopup.isVisible():
            self.suggestionpopup.hide()

        self.suggestionpopup.show_suggestion(
            explanation=f"❌ {msg}",
            command="",
            input_widget=self,
            is_error=True
        )

    def update_frame(self):
        if not getattr(self.suggestionpopup, 'is_error_state', False):
            self.suggestionpopup.show_suggestion(
                explanation=self.frames[self.frame_index],
                command="",
                input_widget=self,
                is_loading=True
            )
            self.frame_index = (self.frame_index + 1) % len(self.frames)

    def _generate(self):
        text = self.toPlainText()
        parent_widget = self.find_parent_with_llm()
        self.timer.start(300)
        if parent_widget:
            parent_widget.llm.send_request(
                parent_widget.ssh_widget.terminal_texts, text)

    def cleanup_history(self):
        try:
            QApplication.instance().removeEventFilter(self)
        except Exception:
            pass
        try:
            self._shortcut_toggle.activated.disconnect()
            self._shortcut_toggle.setParent(None)
        except Exception:
            pass
        try:
            self._history_popup.hide()
        except Exception:
            pass
</file>

<file path="widgets/file_tree_widget.py">
from qfluentwidgets import BreadcrumbBar, LineEdit, TransparentToolButton
from typing import Dict, Optional
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QTreeWidgetItem, QStyle, QFrame
from qfluentwidgets import isDarkTheme, SegmentedWidget
from PyQt5.QtCore import Qt, pyqtSignal
from qfluentwidgets import TreeWidget, RoundMenu, Action, FluentIcon as FIF
from typing import Optional, Dict, Set
from tools.setting_config import SCM

configer = SCM()


def _parse_linux_path(path: str):
    """
    Change '/home/bee' -> ['home','bee']
    root '/' -> []
    """
    if not path:
        return []
    path = path.strip()
    if path == '/':
        return []
    parts = [p for p in path.strip('/').split('/') if p]
    return parts


class File_Navigation_Bar(QWidget):
    bar_path_changed = pyqtSignal(str)
    new_folder_clicked = pyqtSignal()
    refresh_clicked = pyqtSignal()
    view_switch_clicked = pyqtSignal()
    upload_mode_toggled = pyqtSignal(bool)
    internal_editor_toggled = pyqtSignal(bool)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.send_signal = True
        self.current_path = "/"
        self._is_submitting = False

        # Create a container for the border
        self.breadcrumb_container = QFrame(self)

        # Beautify the container with QSS
        if isDarkTheme():
            self.breadcrumb_container.setStyleSheet("""
                QFrame {
                    border: 1px solid #4a4a4a;
                    border-radius: 4px;
                    background-color: transparent;
                }
                QFrame:hover {
                    background-color: rgba(255, 255, 255, 0.08);
                }
            """)
        else:
            self.breadcrumb_container.setStyleSheet("""
                QFrame {
                    border: 1px solid #dcdcdc;
                    border-radius: 4px;
                    background-color: transparent;
                }
                QFrame:hover {
                    background-color: rgba(0, 0, 0, 0.05);
                }
            """)

        # Place the BreadcrumbBar inside the container
        container_layout = QHBoxLayout(self.breadcrumb_container)
        container_layout.setContentsMargins(2, 2, 2, 2)
        self.breadcrumbBar = BreadcrumbBar(self.breadcrumb_container)
        self.breadcrumbBar.setStyleSheet(
            "background-color: transparent; border: none;")
        container_layout.addWidget(self.breadcrumbBar)
        self.path_edit = LineEdit(self)
        self.path_edit.hide()

        self.hBoxLayout = QHBoxLayout(self)
        self.hBoxLayout.setContentsMargins(5, 5, 5, 5)
        self.hBoxLayout.setSpacing(2)
        self.hBoxLayout.addWidget(self.breadcrumb_container, 1)
        self.hBoxLayout.addWidget(self.path_edit)

        self.view_switch_button = TransparentToolButton(FIF.VIEW, self)
        self.hBoxLayout.addWidget(self.view_switch_button)

        self.upload_mode_button = TransparentToolButton(
            FIF.ZIP_FOLDER, self)
        self.upload_mode_button.setCheckable(True)
        self.upload_mode_button.setProperty('isChecked', False)
        style = """
            TransparentToolButton[isChecked="true"] {
                background-color: rgba(0, 0, 0, 0.1);
            }
        """
        if isDarkTheme():
            style = """
            TransparentToolButton[isChecked="true"] {
                background-color: rgba(255, 255, 255, 0.1);
            }
        """
        self.upload_mode_button.setStyleSheet(style)
        self.hBoxLayout.addWidget(self.upload_mode_button)

        self.new_folder_button = TransparentToolButton(FIF.FOLDER_ADD, self)
        self.new_folder_button.setToolTip(self.tr('New folder'))
        self.refresh_button = TransparentToolButton(FIF.UPDATE, self)
        self.refresh_button.setToolTip(self.tr('Refresh') + '(F5)')
        self.pivot = SegmentedWidget(self)
        self.pivot.addItem("file_explorer", self.tr("File Explorer"))
        self.pivot.addItem("net", self.tr("Network Detail"))
        self.pivot.addItem("task", self.tr("Task Detail"))
        self.pivot.setCurrentItem("file_explorer")
        self.hBoxLayout.addWidget(self.new_folder_button)
        self.hBoxLayout.addWidget(self.refresh_button)
        self.hBoxLayout.addWidget(self.pivot)
        self.new_folder_button.clicked.connect(self.new_folder_clicked.emit)
        self.refresh_button.clicked.connect(self.refresh_clicked.emit)
        self.view_switch_button.clicked.connect(self.view_switch_clicked.emit)
        self.upload_mode_button.toggled.connect(self.upload_mode_toggled.emit)
        self.breadcrumbBar.currentItemChanged.connect(self.updatePathLabel)
        self.path_edit.returnPressed.connect(self._submit_path_from_edit)
        self.path_edit.editingFinished.connect(self._submit_path_from_edit)

    def update_view_switch_button(self, current_mode: str):
        if current_mode == "icon":
            self.view_switch_button.setIcon(FIF.VIEW)
            self.view_switch_button.setToolTip(self.tr('Details View'))
        else:
            self.view_switch_button.setIcon(FIF.APPLICATION)
            self.view_switch_button.setToolTip(self.tr('Icon View'))

    def update_upload_mode_button(self, is_checked: bool):
        self.upload_mode_button.setChecked(is_checked)
        self.upload_mode_button.setProperty('isChecked', is_checked)
        self.upload_mode_button.setStyle(QApplication.style())
        if is_checked:
            self.upload_mode_button.setToolTip(
                self.tr('Compression Upload mode is on'))
        else:
            self.upload_mode_button.setToolTip(
                self.tr('Compression Upload mode is off'))

    def mousePressEvent(self, event):
        if not self.path_edit.isVisible() and self.breadcrumb_container.geometry().contains(event.pos()):
            self.path_edit.setText(self.current_path)
            self.breadcrumb_container.hide()
            self.path_edit.show()
            self.path_edit.setFocus()
            self.path_edit.selectAll()
        super().mousePressEvent(event)

    def _submit_path_from_edit(self):
        if self._is_submitting:
            return
        self._is_submitting = True
        new_path = self.path_edit.text().strip()
        if new_path:
            if self.current_path != new_path:
                self.current_path = new_path
                self.bar_path_changed.emit(new_path)
        self._hide_path_edit()
        self._is_submitting = False

    def _hide_path_edit(self):
        self.path_edit.hide()
        self.breadcrumb_container.show()

    def updatePathLabel(self, *_):
        if self.send_signal:
            currentIndex = self.breadcrumbBar.currentIndex()
            items = self.breadcrumbBar.items
            path_list = [item.text for item in items[:currentIndex + 1]]
            path = "/" + \
                "/".join(path_list[1:]) if len(path_list) > 1 else (
                    path_list[0] if path_list else "/")
            if path == "//":
                path = "/"
            self.current_path = path
            self.bar_path_changed.emit(path)

    def set_path(self, path: str):
        self.current_path = path


class FileTreeWidget(QWidget):
    """
File tree widget (can pass in an initial file_tree).\n
- refresh_tree(new_tree=None, preserve_expand=True)\n
- add_path(path, type='file')\n
- remove_path(path)\n
Internal model: {'': {...}}\n
Files are marked with the string "is_file"; directories are marked with a dict.
    """
    directory_selected = pyqtSignal(str)  # path

    def __init__(self, parent=None, file_tree: Optional[Dict] = None):
        super().__init__(parent)
        self.setLayout(QVBoxLayout(self))
        self.layout().setContentsMargins(0, 0, 0, 0)
        self.refresh = Action(FIF.UPDATE, self.tr('Refresh the file tree'))
        self.tree = TreeWidget(self)
        self.tree.setHeaderLabels([self.tr("File Manager")])
        self.tree.setColumnCount(1)
        self.layout().addWidget(self.tree)
        self.tree.itemDoubleClicked.connect(self._on_item_double_clicked)
        # Internal data model
        if file_tree is None:
            self.file_tree = {'': {}}
        else:
            self.file_tree = file_tree

        # Initialize rendering
        self.refresh_tree()

    # ------------------------
    # Expand state collection/recovery
    # ------------------------
    def _gather_expanded_paths(self) -> Set[str]:
        """Traverse the current tree and collect the full paths of all expanded items into a set"""
        expanded = set()

        def recurse(item):
            # item can be QTreeWidgetItem
            for i in range(item.childCount()):
                ch = item.child(i)
                path = ch.data(0, Qt.UserRole)
                if path and ch.isExpanded():
                    expanded.add(path)
                recurse(ch)

        root = self.tree.invisibleRootItem()
        for i in range(root.childCount()):
            top = root.child(i)
            path = top.data(0, Qt.UserRole)
            if path and top.isExpanded():
                expanded.add(path)
            recurse(top)
        return expanded

    def _restore_expanded_paths(self, expanded_paths: Set[str]):
        """Traverse all items and restore the expanded state according to the path collection"""
        def recurse(item):
            for i in range(item.childCount()):
                ch = item.child(i)
                path = ch.data(0, Qt.UserRole)
                if path and path in expanded_paths:
                    ch.setExpanded(True)
                else:
                    ch.setExpanded(False)
                recurse(ch)
        root = self.tree.invisibleRootItem()
        for i in range(root.childCount()):
            top = root.child(i)
            path = top.data(0, Qt.UserRole)
            if path and path in expanded_paths:
                top.setExpanded(True)
            else:
                top.setExpanded(False)
            recurse(top)

    # ------------------------
    # 渲染函数
    # ------------------------
    def refresh_tree(self, new_tree: Optional[Dict] = None, preserve_expand: bool = True):
        """
        Refresh the entire tree:\n
        - If new_tree is passed, replace the internal model\n
        - preserve_expand: Whether to preserve the previous expanded state (default True)        """
        if new_tree is not None:
            self.file_tree = new_tree

        # 收集当前展开状态
        expanded_paths = set()
        if preserve_expand:
            expanded_paths = self._gather_expanded_paths()

        # 清空 UI
        self.tree.clear()

        # 填入根节点下的子项（忽略顶层 '' 键本身）
        root_dict = self.file_tree.get('', {})
        self._populate_tree(root_dict, self.tree, parent_path='')

        # 恢复展开状态（如果需要）
        if preserve_expand:
            self._restore_expanded_paths(expanded_paths)
    print("Refresh tree complete")

    def _populate_tree(self, node_dict: Dict, parent_item, parent_path: str):
        """
        Recursively append node_dict to parent_item (parent_item can be a TreeWidget or QTreeWidgetItem).
        parent_path: The full path of the parent node ('' represents the root), used to construct the full path of the current item, e.g. '/home' '/home/bee'        """
        def sort_key(kv):
            name, val = kv
            is_file = (val == "is_file")
            return (is_file, name.lower())

        for name, val in sorted(node_dict.items(), key=sort_key):
            if parent_path:
                full_path = parent_path.rstrip('/') + '/' + name
            else:
                full_path = '/' + name

            item = QTreeWidgetItem(parent_item, [name])
            item.setData(0, Qt.UserRole, full_path)

            if val == "is_file":
                icon = self.style().standardIcon(QStyle.SP_FileIcon)
                item.setIcon(0, icon)
            else:
                icon = self.style().standardIcon(QStyle.SP_DirIcon)
                item.setIcon(0, icon)
                if isinstance(val, dict) and val:
                    self._populate_tree(val, item, full_path)

    # ------------------------
    # Data model operations (add/remove)
    # ------------------------
    def add_path(self, path: str, typ: str = 'file'):
        """
        Adds path to the internal file_tree.\n
        typ: 'file'/'is_file' for files, 'dir'/'directory' for directories.\n
        Intermediate directories are automatically created (if an intermediate node was previously marked 'is_file', it will be overwritten as a directory).        """
        if not path:
            return

        parts = _parse_linux_path(path)
        if not parts:
            # path == '/'
            if '' not in self.file_tree:
                self.file_tree[''] = {}
            self.refresh_tree()
            return

        t = typ.lower()
        is_file = t in ('file', 'is_file', 'f')
        final_value = "is_file" if is_file else {}

        if '' not in self.file_tree:
            self.file_tree[''] = {}

        node = self.file_tree['']
        for i, part in enumerate(parts):
            last = (i == len(parts) - 1)
            if last:
                node[part] = final_value
            else:
                if part not in node or node[part] == "is_file":
                    node[part] = {}
                node = node[part]

        self.refresh_tree()

    def remove_path(self, path: str):
        """
        Delete the specified path (file or directory). If path=="/", the root is cleared
        """
        if not path:
            return

        parts = _parse_linux_path(path)
        if not parts:
            self.file_tree[''] = {}
            self.refresh_tree()
            return

        node = self.file_tree.get('', {})
        parents = []
        for part in parts[:-1]:
            if isinstance(node, dict) and part in node:
                parents.append((node, part))
                node = node[part]
            else:
                return

        last = parts[-1]
        if isinstance(node, dict) and last in node:
            del node[last]
            self.refresh_tree()
        else:
            return

    def get_model(self) -> Dict:
        """Returns the current internal file_tree reference"""
        return self.file_tree

    def contextMenuEvent(self, e) -> None:
        self.menu = RoundMenu(parent=self)
        self.menu.addActions([self.refresh])
        self.menu.addSeparator()
        self.menu.exec(e.globalPos())

    def switch_to(self, path: str):
        """
        Expand and select the specified path (must exist in the file_tree model)
        """
        if not path or path == "/":
            return

        parts = _parse_linux_path(path)
        if not parts:
            return

        root = self.tree.invisibleRootItem()
        current_item = None
        current_path = ""

        for i, part in enumerate(parts):
            if current_path:
                current_path = current_path.rstrip("/") + "/" + part
            else:
                current_path = "/" + part

            found = None
            parent = root if current_item is None else current_item
            for j in range(parent.childCount()):
                child = parent.child(j)
                child_path = child.data(0, Qt.UserRole)
                if child_path == current_path:
                    found = child
                    break

            if found is None:
                print(f"switch_to: {current_path} not found in tree")
                return  # Exit early if not found

            # Expand the directory (if it is not the last level)

            found.setExpanded(True)

            current_item = found

        # Finally select the target node
        if current_item is not None:
            self.tree.setCurrentItem(current_item)
            self.tree.scrollToItem(current_item)
            current_item.setSelected(True)

    def _on_item_double_clicked(self, item, column):
        """When you double-click an item, if it is a directory, a signal is emitted"""
        path = item.data(0, Qt.UserRole)
        if not path:
            return

        # Find the type of the path in the internal model
        node = self.file_tree.get('', {})
        parts = _parse_linux_path(path)
        for part in parts:
            if isinstance(node, dict) and part in node:
                node = node[part]
            else:
                return

        # If it is a directory (dict type), emit a signal
        if isinstance(node, dict):
            print(f"文件树被选择：{path}")
            self.directory_selected.emit(path)
</file>

<file path="widgets/files_widgets.py">
from PyQt5.QtWidgets import (QApplication, QWidget, QLayout, QSizePolicy,
                             QRubberBand,  QVBoxLayout, QTableView, QHeaderView, QAbstractItemDelegate, QStyledItemDelegate, QStyle, QFileDialog)
from PyQt5.QtGui import QFont, QPainter, QColor, QStandardItemModel, QStandardItem
from PyQt5.QtCore import Qt, QRect, QSize, QPoint, pyqtSignal
from qfluentwidgets import RoundMenu, Action, FluentIcon as FIF, LineEdit, ScrollArea, TableView, CheckableMenu
import os
from qfluentwidgets import isDarkTheme
from tools.setting_config import SCM

configer = SCM()


def _format_size(size_bytes):
    """Format size in bytes to a human-readable string."""
    try:
        # Convert to int, treating None, empty string, etc. as 0
        if size_bytes is None or size_bytes == '':
            size_bytes = 0
        else:
            size_bytes = int(size_bytes)

        if size_bytes == 0:
            return "0 B"

        size_names = ("B", "KB", "MB", "GB", "TB")
        i = 0
        while size_bytes >= 1024 and i < len(size_names) - 1:
            size_bytes /= 1024.0
            i += 1
        return f"{round(size_bytes, 2)} {size_names[i]}"
    except (ValueError, TypeError):
        return "0 B"  # Return "0 B" for any conversion errors


def _normalize_files_data(files):
    """Normalize different input formats to a standard list of tuples."""
    entries = []
    if not files:
        return entries

    if isinstance(files, dict):
        # Assuming dict provides {name: is_dir}
        for name, val in files.items():
            is_dir = True if (
                val is True or isinstance(val, dict)) else False
            entries.append(
                (str(name), is_dir, '', '', '', ''))
    elif isinstance(files, (list, tuple)):
        for entry in files:
            if isinstance(entry, dict):
                name = entry.get("name", "")
                is_dir = entry.get("is_dir", False)
                size = entry.get("size", 0)
                mod_time = entry.get("mtime", "")
                perms = entry.get("perms", "")
                owner = entry.get("owner", "")
                entries.append(
                    (name, is_dir, size, mod_time, perms, owner))
            elif isinstance(entry, (list, tuple)) and len(entry) >= 2:
                # Basic ("name", is_dir) provided
                name, is_dir = entry[0], bool(entry[1])
                entries.append(
                    (str(name), is_dir, '', '', '', ''))
    return entries


# ---------------- FlowLayout ----------------


class FlowLayout(QLayout):

    def __init__(self, parent=None, margin=10, spacing=20):
        super().__init__(parent)
        self.itemList = []
        self.setContentsMargins(margin, margin, margin, margin)
        self.setSpacing(spacing)

    def addItem(self, item):
        self.itemList.append(item)

    def count(self):
        return len(self.itemList)

    def itemAt(self, index):
        return self.itemList[index] if 0 <= index < len(self.itemList) else None

    def takeAt(self, index):
        return self.itemList.pop(index) if 0 <= index < len(self.itemList) else None

    def expandingDirections(self):
        return Qt.Orientations(Qt.Orientation(0))

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        return self.doLayout(QRect(0, 0, width, 0), True)

    def setGeometry(self, rect):
        super().setGeometry(rect)
        self.doLayout(rect, False)

    def sizeHint(self):
        return QSize(400, 300)

    def doLayout(self, rect, testOnly):
        x, y = rect.x(), rect.y()
        lineHeight = 0
        for item in self.itemList:
            wid = item.widget()
            spaceX = self.spacing()
            spaceY = self.spacing()
            nextX = x + wid.sizeHint().width() + spaceX
            if nextX - spaceX > rect.right() and lineHeight > 0:
                x = rect.x()
                y = y + lineHeight + spaceY
                nextX = x + wid.sizeHint().width() + spaceX
                lineHeight = 0
            if not testOnly:
                item.setGeometry(QRect(QPoint(x, y), wid.sizeHint()))
            x = nextX
            lineHeight = max(lineHeight, wid.sizeHint().height())
        return y + lineHeight - rect.y()


class FileActionsManager:
    """Manages the creation and connection of file operation actions."""

    def __init__(self, action_emitter, rename_handler, action_factory):
        """
        Initializes the action manager.

        Args:
            action_emitter (callable): A function to call when an action is triggered.
                                     It should accept action_type and an optional parameter.
            rename_handler (callable): A specific function to call for the rename action.
            action_factory (callable): A function that returns a dictionary of new QActions.
        """
        self.actions = action_factory()
        self.pick = self.actions["pick"]
        self.copy = self.actions["copy"]
        self.delete = self.actions["delete"]
        self.cut = self.actions["cut"]
        self.download = self.actions["download"]
        self.download_compression = self.actions["download_compression"]
        self.copy_path = self.actions["copy_path"]
        self.info = self.actions["info"]
        self.rename = self.actions["rename"]

        self.pick.triggered.connect(lambda: action_emitter('pick'))
        self.copy.triggered.connect(lambda: action_emitter('copy'))
        self.delete.triggered.connect(lambda: action_emitter('delete'))
        self.cut.triggered.connect(lambda: action_emitter('cut'))
        self.download.triggered.connect(lambda: action_emitter('download'))
        self.download_compression.triggered.connect(
            lambda: action_emitter('download', True))
        self.copy_path.triggered.connect(
            lambda: action_emitter('copy_path'))
        self.info.triggered.connect(lambda: action_emitter('info'))
        self.rename.triggered.connect(rename_handler)

    def get_all_actions(self):
        """Returns a list of all managed actions for menu creation."""
        return [
            self.pick,
            self.copy,
            self.cut,
            self.delete,
            self.download,
            self.download_compression,
            self.copy_path,
            self.info,
            self.rename
        ]
# ---------------- FileItem ----------------

# Icons mode


class FileItem(QWidget):
    WIDTH, HEIGHT = 80, 100
    selected_sign = pyqtSignal(dict)
    # Operation type, file name, directory or not,parameter (download_compression)
    action_triggered = pyqtSignal(str, object, bool, object)
    # Operation type, original file name, new file name, whether it is a directory
    rename_action = pyqtSignal(str, str, str, str)
    # new_dir_name
    mkdir_action = pyqtSignal(str)

    def __init__(self, name, is_dir, parent=None, explorer=None):
        super().__init__(parent)
        self.name = name
        self.is_dir = is_dir
        self.selected = False
        self.parent_explorer = explorer
        self.mkdir = False
        icons = self._get_icons()
        self.icon = icons.Folder_Icon if is_dir else icons.File_Icon
        self.setMinimumSize(self.WIDTH, self.HEIGHT)

        self._update_style()
        self.rename_edit = LineEdit(self)
        self.rename_edit.setText(self.name)
        self.rename_edit.setAlignment(Qt.AlignCenter)
        self.rename_edit.hide()
        # self.rename_edit.returnPressed.connect(self._apply_rename)
        self.rename_edit.editingFinished.connect(self._apply_rename)
        self._rename_applied = False
        self._init_actions()

    def _get_icons(self):
        parent = self.parent()
        while parent:
            if hasattr(parent, 'icons'):
                return parent.icons
            parent = parent.parent()

    def _update_style(self):
        """Update styles based on the theme"""
        if isDarkTheme():
            self.setStyleSheet("""
                FileItem {
                    color: white;
                    background: transparent;
                }
                FileItem:hover {
                    background: rgba(255, 255, 255, 0.1);
                }
            """)
        else:
            self.setStyleSheet("""
                FileItem {
                    color: black;
                    background: transparent;
                }
                FileItem:hover {
                    background: rgba(0, 0, 0, 0.05);
                }
            """)

    def sizeHint(self):
        return QSize(self.WIDTH, self.HEIGHT)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        if self.selected:
            painter.setBrush(QColor("#cce8ff"))
            painter.setPen(Qt.NoPen)
            painter.drawRoundedRect(self.rect(), 5, 5)

        painter.drawPixmap(
            (self.width() - self.icon.width()) // 2, 5, self.icon)

        font = QFont("Segoe UI", 8)
        painter.setFont(font)

        metrics = painter.fontMetrics()
        text_width = metrics.width(self.name)
        available_width = self.width() - 10

        display_text = self.name
        if text_width > available_width:

            display_text = metrics.elidedText(
                self.name, Qt.ElideMiddle, available_width)

        if isDarkTheme():
            painter.setPen(QColor(255, 255, 255))
        else:
            painter.setPen(QColor(0, 0, 0))

        painter.drawText(QRect(5, 70, self.width()-10, 30),
                         Qt.AlignCenter, display_text)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            ctrl = QApplication.keyboardModifiers() & Qt.ControlModifier
            self.parent_explorer.select_item(self, ctrl)

    def mouseDoubleClickEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.selected_sign.emit({self.name: self.is_dir})
            print(f"Double-click to open: {self.name}")

    def _init_actions(self):
        self.actions_manager = FileActionsManager(
            action_emitter=self._emit_action,
            rename_handler=self._start_rename,
            action_factory=self.parent_explorer._create_file_op_actions
        )

    def _create_context_menu(self):
        """Creates and returns the context menu for the file item."""
        menu = RoundMenu(parent=self)
        menu.addActions(self.actions_manager.get_all_actions())
        return menu

    def contextMenuEvent(self, e):
        # Ensure the item is selected before showing the context menu
        if not self.selected:
            self.parent_explorer.select_item(self)

        menu = self._create_context_menu()
        menu.exec(e.globalPos())

    def _emit_action(self, action_type, parameter=None):
        if action_type == "rename":
            self._start_rename()
        else:
            copy_cut_paths = []
            if self.parent_explorer:
                for item in self.parent_explorer.selected_items:
                    if action_type in ("copy", "cut") or action_type == "download" and parameter:
                        copy_cut_paths.append(item.name)
                    else:
                        self.action_triggered.emit(
                            action_type, item.name, item.is_dir, parameter
                        )
            if copy_cut_paths:
                if action_type != "download":
                    self.action_triggered.emit(
                        action_type, copy_cut_paths, False, parameter
                    )
                else:
                    # if action_type == "download" and parameter:
                    self.action_triggered.emit(
                        action_type, copy_cut_paths, False, parameter)
                    return

    def _start_rename(self):
        self._rename_applied = False
        self.rename_edit.setText(self.name)
        self.rename_edit.setGeometry(5, 70, self.width()-10, 25)
        self.rename_edit.show()
        self.rename_edit.setFocus()
        self.rename_edit.selectAll()

    def _apply_rename(self):
        print("Apply rename")
        if self._rename_applied:
            return

        self._rename_applied = True
        new_name = self.rename_edit.text().strip()
        if self.mkdir:
            self.mkdir_action.emit(new_name)
            self.mkdir = False
            self.rename_edit.hide()
            self.update()
        else:

            if new_name and new_name != self.name:
                self.rename_action.emit(
                    "rename", self.name, new_name, str(self.is_dir))
            self.rename_edit.hide()
            self.update()


class NameDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        if option.state & QStyle.State_HasFocus:
            option.state = option.state ^ QStyle.State_HasFocus
        # Add 5px left padding
        option.rect.adjust(5, 0, 0, 0)
        super().paint(painter, option, index)


class CenteredDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        if option.state & QStyle.State_HasFocus:
            option.state = option.state ^ QStyle.State_HasFocus
        option.displayAlignment = Qt.AlignCenter | Qt.AlignVCenter
        super().paint(painter, option, index)


# Detail Mode


class DetailItem(QWidget):
    # type , file_name/file_names, is_dir , new_name/compression
    action_triggered = pyqtSignal(str, object, bool, object)

    def __init__(self, parent=None):
        super().__init__(parent)
        # Details view
        self.details_model = QStandardItemModel(self)
        self.details_view = TableView(self)
        self.details_view.setAlternatingRowColors(False)
        self.details_view.verticalHeader().setDefaultSectionSize(24)
        self.details_view.setModel(self.details_model)
        self.details_view.setVisible(False)  # Default hidden
        self.details_view.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.details_view.setEditTriggers(QTableView.NoEditTriggers)
        self.details_view.setSelectionBehavior(QTableView.SelectRows)
        self.details_view.setSelectionMode(QTableView.ExtendedSelection)
        self.details_view.setContextMenuPolicy(Qt.CustomContextMenu)
        self.details_view.setItemDelegateForColumn(0, NameDelegate(self))
        centered_delegate = CenteredDelegate(self)
        self.details_view.setItemDelegateForColumn(1, centered_delegate)
        self.details_view.setItemDelegateForColumn(2, centered_delegate)
        self.details_view.setItemDelegateForColumn(3, centered_delegate)
        self.details_view.setItemDelegateForColumn(4, centered_delegate)

        self.details_view.customContextMenuRequested.connect(
            self._show_context_menu)
        self.details_view.doubleClicked.connect(
            self._on_row_double_click)
        self.details_view.verticalHeader().setVisible(False)
        self.details_model.setHorizontalHeaderLabels([
            self.tr('Name'),
            self.tr('Size'),
            self.tr('Modified Time'),
            self.tr('Permissions'),
            self.tr('User/Group')
        ])

        if isDarkTheme():
            self.details_view.setStyleSheet("""
                QTableView {
                    color: white;
                    background-color: transparent;
                    border: none;
                    gridline-color: #454545;
                }
                QTableView::item {
                    border-bottom: 1px solid #454545;
                }
                QTableView::item:selected {
                    background-color: #6A5ACD;
                    color: white;
                }
                QHeaderView::section {
                    background-color: transparent;
                    color: white;
                    border: none;
                    border-bottom: 1px solid #555;
                }
            """)
        else:
            self.details_view.setStyleSheet("""
                QTableView {
                    color: black;
                    background-color: transparent;
                    border: none;
                    gridline-color: #DCDCDC;
                }
                QTableView::item {
                     border-bottom: 1px solid #DCDCDC;
                }
                QTableView::item:selected {
                    background-color: #cce8ff;
                    color: black;
                }
                QHeaderView::section {
                    background-color: transparent;
                    color: black;
                    border: none;
                    border-bottom: 1px solid #ccc;
                }
            """)

        self.actions_manager = FileActionsManager(
            action_emitter=self._emit_action,
            rename_handler=self.rename_selected_item,
            action_factory=self.parent()._create_file_op_actions
        )
        self.details_model.dataChanged.connect(self._on_data_changed)
        self._rename_old_name = None
        self.is_mkdir = False
        self._editing_index = None
        self.details_view.itemDelegate().closeEditor.connect(
            lambda editor, hint: self._on_editor_closed(editor, hint))

    def _emit_action(self, action_type, parameter=None):
        indexes = self.details_view.selectionModel().selectedRows()
        if not indexes:
            return

        copy_cut_paths = []  # maybe its download list
        for index in indexes:
            name_item = self.details_model.item(index.row(), 0)
            file_name = name_item.text()
            is_dir = name_item.data(Qt.UserRole)

            # download_compression
            if action_type in ("copy", "cut",) or action_type == "download" and parameter:
                copy_cut_paths.append(file_name)
            else:
                self.action_triggered.emit(action_type, file_name, is_dir, "")

        if copy_cut_paths:
            if action_type != "download":
                self.action_triggered.emit(
                    action_type, copy_cut_paths, False, "")
            else:
                # if action_type == "download" and parameter:
                self.action_triggered.emit(
                    action_type, copy_cut_paths, False, parameter)
                return

    def _on_row_double_click(self, index):
        if not index.isValid():
            return
        name_item = self.details_model.item(index.row(), 0)
        file_name = name_item.text()
        is_dir = name_item.data(Qt.UserRole)
        self.action_triggered.emit("open", file_name, is_dir, "")
        print(file_name, "mode", is_dir)

    def _show_context_menu(self, pos):
        index = self.details_view.indexAt(pos)
        if index.isValid():
            self._show_item_context_menu(pos, index)
        else:
            # Show the general context menu for blank areas, provided by the parent
            menu = self.parent()._get_menus()
            menu.exec_(self.details_view.viewport().mapToGlobal(pos))

    def _show_item_context_menu(self, pos, index):
        """Show context menu for a specific item in the details view."""
        selection_model = self.details_view.selectionModel()

        if not selection_model.isSelected(index):
            selection_model.clearSelection()
            selection_model.select(
                index,
                selection_model.Select | selection_model.Rows
            )

        menu = self._get_details_menus()
        menu.exec_(self.details_view.viewport().mapToGlobal(pos))

    def _get_details_menus(self):
        menu = RoundMenu(parent=self)
        menu.addActions(self.actions_manager.get_all_actions())
        return menu

    def _add_files_to_details_view(self, files, clear_old=True):
        self.details_model.setRowCount(0)
        entries = _normalize_files_data(files)
        # Sort by name, with directories first
        entries.sort(key=lambda x: (not x[1], x[0].lower()))

        for name, is_dir, size, mod_time, perms, owner in entries:
            # For files, always format size (even if 0 or empty)
            # For directories, show empty string
            size_str = _format_size(size) if not is_dir else ""
            item_name = QStandardItem(name)
            # Store is_dir flag in the item itself for later retrieval
            item_name.setData(is_dir, Qt.UserRole)

            row = [
                item_name,
                QStandardItem(size_str),
                QStandardItem(mod_time),
                QStandardItem(perms),
                QStandardItem(owner)
            ]

            self.details_model.appendRow(row)

    def rename_selected_item(self):
        """Make the selected file name editable"""
        indexes = self.details_view.selectionModel().selectedRows()
        if not indexes:
            return

        index = indexes[0]  # Only rename the first selected item
        name_item = self.details_model.item(index.row(), 0)

        self._rename_old_name = name_item.text()  # Record old name
        self._editing_index = index
        name_item.setEditable(True)

        self.details_view.edit(index)

    def _on_data_changed(self, topLeft, bottomRight, roles):
        """Fired when the user finishes editing"""
        if roles and Qt.EditRole not in roles:
            return

        if topLeft.column() != 0:
            return

        row = topLeft.row()
        model = self.details_model
        item = model.item(row, 0)
        if not item:
            return

        new_name = item.text().strip()
        old_name = self._rename_old_name

        # Always finish editing first
        item.setEditable(False)
        self._rename_old_name = None

        if self.is_mkdir:
            self.is_mkdir = False
            model.removeRow(row)
            if new_name:
                self.action_triggered.emit("mkdir", new_name, True, "")
        elif old_name and new_name and new_name != old_name:
            is_dir = item.data(Qt.UserRole)
            self.apply_rename(old_name, new_name, is_dir)

    def apply_rename(self, old_name, new_name, is_dir):
        print(f"Rename: {old_name} -> {new_name}")
        self.action_triggered.emit("rename", old_name, is_dir, new_name)
        self.details_view.clearSelection()

    def _on_editor_closed(self, editor, hint):
        """Handle editor closing, for mkdir when name is not changed."""
        if not self._editing_index or not self.is_mkdir:
            return

        index_row = self._editing_index.row()
        self._editing_index = None  # Reset

        # On cancel (ESC)
        if hint == QAbstractItemDelegate.RevertModelCache:
            self.details_model.removeRow(index_row)
            self.is_mkdir = False
            return

        # Handle submit when name is unchanged (dataChanged won't fire)
        item = self.details_model.item(index_row, 0)
        if not item:
            return

        new_name = editor.text().strip()
        old_name = item.text()

        if new_name == old_name:
            self.details_model.removeRow(index_row)
            self.is_mkdir = False
            if new_name:
                self.action_triggered.emit("mkdir", new_name, True, "")

    # def _show_general_context_menu_on_blank(self, pos):
    #     """Show general context menu when clicking on a blank area of the details view."""
    #     # Check if the click is on an item. If so, do nothing.
    #     if self.details_view.indexAt(pos).isValid():
    #         return

    #     menu = RoundMenu(parent=self)
    #     menu.addActions([
    #         self.paste, self.make_dir, self.refreshaction, self.uploads, self.upload,
    #     ])
    #     menu.addSeparator()
    #     menu.addActions([self.details_view_action, self.icon_view_action])
    #     menu.exec_(self.details_view.viewport().mapToGlobal(pos))

# ---------------- FileExplorer ----------------


class FileExplorer(QWidget):
    selected = pyqtSignal(dict)
    # action type , path , copy_to path , cut?/ download_compression
    file_action = pyqtSignal(str, object, str, bool)
    # Source path , Target path , compression
    upload_file = pyqtSignal(object, str, bool)
    refresh_action = pyqtSignal()

    def __init__(self, parent=None, path=None):
        super().__init__(parent)
        self.view_mode = "icon"  # "icon" or "details"
        self.copy_file_path = None
        self.cut_ = False
        self.path = path
        self._is_loading = False

        # Icon view
        self.scroll_area = ScrollArea(self)
        self.scroll_area.setWidgetResizable(True)
        self.container = QWidget()
        self.flow_layout = FlowLayout(self.container)
        self.container.setLayout(self.flow_layout)
        self.scroll_area.setWidget(self.container)

        # detaile
        self.details = DetailItem(self)
        self.details.action_triggered.connect(
            lambda type_, name, is_dir, new_name: self._handle_file_action(type_, name, is_dir, new_name=new_name))

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(self.scroll_area)
        main_layout.addWidget(self.details.details_view)
        self.setLayout(main_layout)
        self.selected_items = set()
        self.rubberBand = QRubberBand(QRubberBand.Rectangle, self)
        self.dragging = False
        self.start_pos = None
        self.setMouseTracking(True)
        self.setAcceptDrops(True)

        # self.make_dir.triggered.connect(
        #     lambda: self._handle_file_action("mkdir", "", ""))
        self._init_actions()

    def _request_directory_change(self, item_info):
        print(item_info)
        is_dir = list(item_info.values())[0]
        if not is_dir:
            self.selected.emit(item_info)
            return

        if self._is_loading:
            return
        self._is_loading = True
        self.selected.emit(item_info)

    def _handle_mkdir(self):
        """Create a new folder placeholder and enter rename mode."""
        new_folder_name = "NewFolder"

        if self.view_mode == "icon":
            existing_names = {self.flow_layout.itemAt(
                i).widget().name for i in range(self.flow_layout.count())}
            counter = 1
            candidate_name = new_folder_name
            while candidate_name in existing_names:
                candidate_name = f"{new_folder_name} ({counter})"
                counter += 1

            self.add_files([(candidate_name, True)], clear_old=False)

            new_item = self.flow_layout.itemAt(
                self.flow_layout.count() - 1).widget()

            self.select_item(new_item)
            new_item.mkdir = True
            new_item._start_rename()
        else:  # Details view
            model = self.details.details_model
            existing_names = {model.item(
                i, 0).text() for i in range(model.rowCount())}
            counter = 1
            candidate_name = new_folder_name
            while candidate_name in existing_names:
                candidate_name = f"{new_folder_name} ({counter})"
                counter += 1

            item_name = QStandardItem(candidate_name)
            item_name.setData(True, Qt.UserRole)  # is_dir = True

            row_items = [
                item_name, QStandardItem(""), QStandardItem(""),
                QStandardItem(""), QStandardItem("")
            ]

            # Maintain sort order: insert at the correct position
            entries = []
            for r in range(model.rowCount()):
                name = model.item(r, 0).text()
                is_dir = model.item(r, 0).data(Qt.UserRole)
                entries.append((name, is_dir))

            entries.append((candidate_name, True))
            entries.sort(key=lambda x: (not x[1], x[0].lower()))
            new_row_index = entries.index((candidate_name, True))

            model.insertRow(new_row_index, row_items)
            new_item_index = model.index(new_row_index, 0)

            # Select and scroll to the new item
            selection_model = self.details.details_view.selectionModel()
            selection_model.clearSelection()
            selection_model.select(
                new_item_index, selection_model.Select | selection_model.Rows)
            self.details.details_view.scrollTo(new_item_index)

            # Start the renaming process
            self.details.is_mkdir = True
            self.details.rename_selected_item()

    def _create_file_op_actions(self):
        """Creates a dictionary of file operation actions."""
        return {
            "pick": Action(FIF.EDIT, self.tr("Pick app to open")),
            "copy": Action(FIF.COPY, self.tr("Copy")),
            "delete": Action(FIF.DELETE, self.tr("Delete")),
            "cut": Action(FIF.CUT, self.tr("Cut")),
            "download": Action(FIF.DOWNLOAD, self.tr("Download")),
            "download_compression": Action(
                FIF.DOWNLOAD, self.tr("Download (compression)")
            ),
            "copy_path": Action(FIF.FLAG, self.tr("Copy Path")),
            "info": Action(FIF.INFO, self.tr("File Info")),
            "rename": Action(FIF.LABEL, self.tr("Rename")),
        }

    def switch_view(self, view_type):
        """Switch between icon and details view."""
        if view_type == "icon":
            self.view_mode = "icon"
            self.scroll_area.setVisible(True)
            self.details.details_view.setVisible(False)
        elif view_type == "details":
            self.view_mode = "details"
            self.scroll_area.setVisible(False)
            self.details.details_view.setVisible(True)
        # Refresh the view with current files
        self.refresh_action.emit()

    def add_files(self, files, clear_old=True):
        """
    Accepts:
    - dict: {name: bool_or_marker} (True for directories, False for files)
    - list: [{"name": ..., "is_dir": True/False}, ...]
    - list of tuples: [("name", True), ...]
    Sorts directories first, files last, in ascending order by name (case-insensitive).
        """
        if self.view_mode == "icon":
            self._add_files_to_icon_view(files, clear_old)
        else:
            self.details._add_files_to_details_view(files, clear_old)
        self._is_loading = False

    def _add_files_to_icon_view(self, files, clear_old=True):
        self.container.setUpdatesEnabled(False)
        if clear_old:
            while self.flow_layout.count():
                item = self.flow_layout.takeAt(0)
                if item and item.widget():
                    item.widget().deleteLater()
            self.selected_items.clear()

        entries = _normalize_files_data(files)
        entries.sort(key=lambda x: (not x[1], x[0].lower()))

        for name, is_dir, *_ in entries:
            item_widget = FileItem(
                name, is_dir, parent=self.container, explorer=self)
            item_widget.selected_sign.connect(self._request_directory_change)
            item_widget.action_triggered.connect(self._handle_file_action)
            item_widget.rename_action.connect(
                lambda type_, name, new_name, is_dir: self._handle_file_action(
                    action_type=type_, file_name=name, is_dir=is_dir, new_name=new_name))
            item_widget.mkdir_action.connect(
                lambda new_dir_name: self._handle_file_action(
                    action_type="mkdir", file_name=new_dir_name))
            item_widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            self.flow_layout.addWidget(item_widget)

        self.container.setUpdatesEnabled(True)
        self.container.update()

    def select_item(self, item, ctrl=False):
        if ctrl:
            if item in self.selected_items:
                self.selected_items.remove(item)
                item.selected = False
            else:
                self.selected_items.add(item)
                item.selected = True
        else:
            for i in self.selected_items:
                i.selected = False
                i.update()
            self.selected_items = {item}
            item.selected = True
        item.update()

    # new_name/compression
    def _handle_file_action(self, action_type, file_name, is_dir=None, new_name=None):
        # try:
        #     file_name = list(file_name)  # Check if it's iterable
        #     if not len(file_name) > 1:
        #         KeyError
        #     full_path = []
        #     more_than_one = True
        # except Exception:
        #     more_than_one = False
        full_path = []
        if isinstance(file_name, list):
            for name in file_name:
                full_path_ = self._get_full_path(name)
                full_path.append(full_path_)
        else:
            full_path = self._get_full_path(file_name)

        if action_type == "pick":
            app_path = self.handle_pick_app()
            if app_path:
                configer.revise_config("external_editor", app_path)
                self._request_directory_change({file_name: is_dir})
                return

        if action_type == "download" and new_name == True:
            self.file_action.emit(action_type, full_path, "", True)
            return
        # Only for detail mode
        if action_type == "open":
            self._request_directory_change({file_name: is_dir})
            return

        if action_type == "paste":
            if self.copy_file_path:  # A list of paths copied/cut earlier
                if isinstance(self.copy_file_path, list):
                    for path in self.copy_file_path:
                        self.file_action.emit(
                            action_type, path, self.path, self.cut_)
                else:
                    self.file_action.emit(
                        action_type, self.copy_file_path, self.path, self.cut_)

                self.cut_ = False
                self.copy_file_path = []  # Reset after paste
            return

        if action_type in ["rename", "mkdir"]:
            full_path = full_path
            if action_type == "rename" and new_name:
                self.file_action.emit(action_type, full_path, new_name, False)
            elif action_type == "mkdir" and file_name:
                self.file_action.emit(action_type, full_path, "", False)
            return
        print(action_type, full_path, new_name, )
        if action_type == "copy":
            self.copy_file_path = full_path
            self.cut_ = False
        elif action_type == "cut":
            self.copy_file_path = full_path
            self.cut_ = True
        else:  # Covers "delete", "download", "info", "copy_path", etc.
            self.file_action.emit(action_type, full_path, "", False)

    def _show_details_view_context_menu(self, pos):
        index = self.details_view.indexAt(pos)
        if not index.isValid():
            # Clicked on empty space, show the general context menu
            menu = self._create_general_context_menu()
            menu.exec_(self.details_view.viewport().mapToGlobal(pos))
            return

        selection_model = self.details_view.selectionModel()
        # If the clicked item is not already part of the selection,
        # clear the previous selection and select only the clicked item.
        if not selection_model.isSelected(index):
            selection_model.clearSelection()
            selection_model.select(
                index, self.details_view.selectionModel().Select | self.details_view.selectionModel().Rows)

        # Now the selection is correct, proceed to show the menu.
        name_item = self.details_model.item(index.row(), 0)
        file_name = name_item.text()
        is_dir = name_item.data(Qt.UserRole)

        # Create a temporary FileItem to generate and show the context menu
        # This reuses the menu logic and now _emit_action handles multi-select
        # temp_item = FileItem(
        #     file_name, is_dir, explorer=self, icons=self.icons)
        # # Connect the signal from the temporary item to the actual handler
        # temp_item.action_triggered.connect(self._handle_file_action)
        menu = self.details_context_menu()
        menu.exec_(self.details_view.viewport().mapToGlobal(pos))

    def mousePressEvent(self, event):
        # This event is for the icon view's rubber band selection
        if self.view_mode == 'details':
            super().mousePressEvent(event)
            return
        if event.button() == Qt.LeftButton:
            ctrl = QApplication.keyboardModifiers() & Qt.ControlModifier
            in_item = False
            for i in range(self.flow_layout.count()):
                widget = self.flow_layout.itemAt(i).widget()
                if widget.geometry().contains(event.pos()):
                    in_item = True
                    break
            if not in_item:
                self.dragging = True
                self.start_pos = event.pos()
                if not ctrl:
                    for item in self.selected_items:
                        item.selected = False
                        item.update()
                    self.selected_items.clear()
                self.rubberBand.setGeometry(QRect(self.start_pos, QSize()))
                self.rubberBand.show()

    def mouseMoveEvent(self, event):
        if self.dragging:
            rect = QRect(self.start_pos, event.pos()).normalized()
            self.rubberBand.setGeometry(rect)
            for i in range(self.flow_layout.count()):
                widget = self.flow_layout.itemAt(i).widget()
                if rect.intersects(widget.geometry()):
                    if widget not in self.selected_items:
                        self.selected_items.add(widget)
                        widget.selected = True
                        widget.update()
                else:
                    if widget in self.selected_items and not (Qt.ControlModifier & QApplication.keyboardModifiers()):
                        self.selected_items.remove(widget)
                        widget.selected = False
                        widget.update()

    def mouseReleaseEvent(self, event):
        if self.dragging:
            self.dragging = False
            self.rubberBand.hide()

    # ---------------- Drag-in file event ----------------
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event):
        urls = event.mimeData().urls()
        file_paths = [url.toLocalFile() for url in urls]
        # file_dict = {}
        # for url in urls:
        #     path = url.toLocalFile()
        #     print("Drag in the file path:", path)
        #     is_dir = os.path.isdir(path)
        #     filename = os.path.basename(path)
        #     file_dict[filename] = is_dir
        if file_paths:
            # print(file_paths, type(file_paths))
            self.upload_file.emit(
                file_paths, self.path, configer.read_config()["compress_upload"])
        event.acceptProposedAction()

    def _init_actions(self):
        config = configer.read_config()
        self.refreshaction = Action(FIF.UPDATE, self.tr('Refresh the page'))
        self.details_view_action = Action(FIF.VIEW, self.tr('Details View'))
        self.icon_view_action = Action(FIF.APPLICATION, self.tr('Icon View'))
        self.paste = Action(FIF.PASTE, self.tr("Paste"))
        self.make_dir = Action(FIF.FOLDER_ADD, self.tr("New Folder"))
        self.upload_mode_switch = Action(
            FIF.UP, self.tr("Upload files(compression mode)"), checkable=True)
        self.upload_mode_switch.setChecked(
            config["compress_upload"])

        self.open_external = Action(
            FIF.TAG, self.tr("External"), checkable=True)
        self.open_internal = Action(
            FIF.REMOVE, self.tr("Internal"), checkable=True)
        self.switch_open_mode(config["open_mode"])
        self.open_external.triggered.connect(
            lambda: self.switch_open_mode(True))
        self.open_internal.triggered.connect(
            lambda: self.switch_open_mode(False))

        self.refreshaction.triggered.connect(
            lambda: self.refresh_action.emit())
        self.details_view_action.triggered.connect(
            lambda: self.switch_view("details"))
        self.icon_view_action.triggered.connect(
            lambda: self.switch_view("icon"))
        self.paste.triggered.connect(
            lambda: self._handle_file_action("paste", "", ""))
        self.make_dir.triggered.connect(self._handle_mkdir)
        self.upload_mode_switch.toggled.connect(lambda checked:
                                                configer.revise_config("compress_upload", checked))

    def switch_open_mode(self, external: bool):
        """Switches the open mode actions based on the external flag."""
        self.open_external.setChecked(external)
        self.open_internal.setChecked(not external)
        configer.revise_config("open_mode", external)

    def _get_menus(self):
        menu = CheckableMenu(parent=self)
        menu.addActions(
            [self.refreshaction, self.paste, self.make_dir, self.upload_mode_switch])

        submenu = CheckableMenu(self.tr("Open mode"), self)
        submenu.setIcon(FIF.SEND)
        submenu.addActions([self.open_external, self.open_internal])
        menu.addMenu(submenu)

        menu.addSeparator()
        menu.addActions(
            [self.details_view_action, self.icon_view_action])
        return menu

    def contextMenuEvent(self, e):
        # This event now only handles the icon view's empty space.
        # Details view empty space is handled in _show_details_view_context_menu.
        if self.view_mode == 'icon':
            menu = self._get_menus()
            menu.exec_(e.globalPos())

    def _get_full_path(self, file_name):
        path = os.path.join(self.path, file_name)
        return os.path.normpath(path).replace('\\', '/')

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Delete:
            selected_names = []
            if self.view_mode == 'icon':
                if not self.selected_items:
                    return
                selected_names = [item.name for item in self.selected_items]

            elif self.view_mode == 'details':
                indexes = self.details.details_view.selectionModel().selectedRows()
                if not indexes:
                    return
                selected_names = [self.details.details_model.item(
                    index.row(), 0).text() for index in indexes]

            if selected_names:
                self._handle_file_action('delete', selected_names, False, None)

        elif event.key() == Qt.Key_F2:
            # F2 rename should only work for a single selection
            if self.view_mode == 'icon' and len(self.selected_items) == 1:
                item = list(self.selected_items)[0]
                item._start_rename()
            elif self.view_mode == 'details' and len(self.details.details_view.selectionModel().selectedRows()) == 1:
                self.details.rename_selected_item()
        elif event.key() == Qt.Key_F5:
            self.refresh_action.emit()
        elif event.key() == Qt.Key_Backspace:
            self.selected.emit({'..': True})
        elif event.key() == Qt.Key_A and (event.modifiers() & Qt.ControlModifier):
            if self.view_mode == 'icon':
                self.selected_items.clear()
                for i in range(self.flow_layout.count()):
                    widget = self.flow_layout.itemAt(i).widget()
                    widget.selected = True
                    widget.update()
                    self.selected_items.add(widget)
        else:
            super().keyPressEvent(event)

    def handle_pick_app(self):
        file_path, _ = QFileDialog.getOpenFileName(
            None,
            self.tr("Select executable program"),
            self.tr("C:\\Program Files"),
            self.tr("Executable files (*.exe);;All files (*.*)")
        )
        return file_path
</file>

<file path="widgets/setting_page.py">
# setting_page.py
import logging
import os
from PyQt5.QtCore import Qt, pyqtSignal, QCoreApplication, QTimer, QThread
from PyQt5.QtGui import QFontDatabase, QFont, QColor, QPalette, QKeySequence, QIntValidator
from PyQt5.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QListWidget, QListWidgetItem, QLabel, QPushButton, QShortcut,
    QSizePolicy, QFrame, QFileDialog
)

from qfluentwidgets import (
    FluentIcon, ComboBoxSettingCard, OptionsConfigItem, SearchLineEdit, ScrollArea,
    SwitchSettingCard, PushSettingCard, QConfig, InfoBar, InfoBarPosition,
    LineEdit, RangeConfigItem, RangeValidator, RangeSettingCard, ExpandGroupSettingCard, BodyLabel, ComboBox, SwitchButton, IndicatorPosition,
    OptionsValidator, ColorDialog, SettingCard
)

from tools.font_config import font_config
from tools.setting_config import SCM
from tools.image_color_extractor import ImageColorExtractor


logger = logging.getLogger(__name__)

configer = SCM()

llm_models = {
    "ChatGPT": 0,
    "DeepSeek": 1,
    "Local ollama": 2
}


class Config(QConfig):
    background_color = OptionsConfigItem(
        "MainWindow", "Color",
        QCoreApplication.translate("Config", "Follow system settings"),
        OptionsValidator([
            QCoreApplication.translate("Config", "Light"),
            QCoreApplication.translate("Config", "Dark"),
            QCoreApplication.translate("Config", "Follow system settings")
        ]),
        restart=True
    )
    sizes = OptionsConfigItem(
        "MainWindow", "Sizes", "15",
        OptionsValidator([str(i) for i in range(12, 31)]),
        restart=True
    )
    opacity = RangeConfigItem("MainWindow", "Opacity",
                              100, RangeValidator(0, 100))

    language = OptionsConfigItem(
        "MainWindow", "Language",
        QCoreApplication.translate("Config", "English"),
        OptionsValidator([
            QCoreApplication.translate("Config", "English"),
            QCoreApplication.translate("Config", "简体中文"),
            QCoreApplication.translate("Config", "繁體中文"),
            QCoreApplication.translate("Config", "日本語"),
            QCoreApplication.translate("Config", "Русский")
        ]),
        restart=True
    )

    default_view = OptionsConfigItem(
        "Files", "DefaultView", "Icon", OptionsValidator(["Icon", "Info"]), restart=False
    )


class aigc_config(ExpandGroupSettingCard):

    def __init__(self, parent=None):
        super().__init__(
            FluentIcon.EDIT,
            "AI Model API Settings",
        )

        self.open_switch = BodyLabel(self.tr("Enable AI Model"))
        self.open_switchButton = SwitchButton(
            "Close", self, IndicatorPosition.RIGHT)
        self.open_switchButton.setOnText("Open")

        self.ModelLabel = BodyLabel(self.tr("AI Model API selection"))
        self.ModelComboBox = ComboBox()
        self.ModelComboBox.addItems(["ChatGPT", "DeepSeek", "Local ollama"])
        self.ModelComboBox.setCurrentIndex(1)

        self.ApiLabel = BodyLabel(self.tr("API Key"))
        self.ApiEdit = LineEdit()
        self.ApiEdit.setPlaceholderText(
            self.tr("Please enter your API key here"))
        self.ApiEdit.setClearButtonEnabled(True)

        self.Max_length = BodyLabel(self.tr("Max length of history messages"))
        self.Max_lengthEdit = LineEdit()
        self.Max_lengthEdit.setPlaceholderText(
            self.tr("1-100,the larger the number, the more tokens are consumed"))
        self.Max_lengthEdit.setValidator(QIntValidator(1, 2147483647))

        self.viewLayout.setContentsMargins(0, 0, 0, 0)
        self.viewLayout.setSpacing(0)

        self.add_row(self.open_switch, self.open_switchButton)
        self.add_row(self.ModelLabel, self.ModelComboBox)
        self.add_row(self.ApiLabel, self.ApiEdit)
        self.add_row(self.Max_length, self.Max_lengthEdit)

    def add_row(self, label, widget):
        w = QWidget()
        w.setFixedHeight(60)

        layout = QHBoxLayout(w)
        layout.setContentsMargins(48, 12, 48, 12)
        layout.setSpacing(10)

        layout.addWidget(label)
        layout.addStretch(1)
        layout.addWidget(widget)

        self.addGroupWidget(w)


class FontSelectorDialog(QDialog):
    """
    Robust FontSelectorDialog that force-paints its own visible content area
    to avoid being turned into a 'black box' by global QSS.
    Replace your old FontSelectorDialog with this one.
    """
    fontSelected = pyqtSignal(str)

    def __init__(self, parent=None,
                 title=QCoreApplication.translate(
                     "FontSelectorDialog", "Select Font"),
                 prompt=QCoreApplication.translate("FontSelectorDialog", "Choose a system font")):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.selected_font = None
        self.setModal(True)
        self.resize(760, 520)

        # ---------------------------
        # Force window-level safe flags (avoid translucent backgrounds)
        # ---------------------------
        try:
            # ensure window isn't transparent due to global flags
            self.setAttribute(Qt.WA_TranslucentBackground, False)
            self.setWindowOpacity(1.0)
        except Exception:
            pass

        # ---------------------------
        # Build a content frame that we fully control the painting for.
        # We'll put all UI into `self.content` and force its palette/QSS.
        # ---------------------------
        self.content = QFrame(self)
        self.content.setObjectName("font_selector_content")
        self.content.setAutoFillBackground(True)
        self.content.setAttribute(Qt.WA_StyledBackground, True)

        # Choose explicit bg/text colors (white bg, dark text)
        self._bg = QColor("#ffffff")
        self._text = QColor("#111111")

        # Apply palette to content to ensure it paints background
        pal = self.content.palette()
        pal.setColor(QPalette.Window, self._bg)
        pal.setColor(QPalette.WindowText, self._text)
        pal.setColor(QPalette.Base, self._bg)
        pal.setColor(QPalette.Text, self._text)
        self.content.setPalette(pal)

        # Locally scoped stylesheet to further ensure visibility (targets only our content subtree)
        content_qss = f"""
        QFrame#font_selector_content {{ background: {self._bg.name()}; color: {self._text.name()}; }}
        QLineEdit {{ background: #ffffff; color: #000000; border: 1px solid rgba(0,0,0,0.12); border-radius:6px; }}
        QListWidget {{ background: #ffffff; color: #000000; }}
        QLabel {{ color: #000000; }}
        """
        # apply to the content frame only (this will style its children that inherit)
        self.content.setStyleSheet(content_qss)

        # main layout attaches the content frame
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(self.content)

        # content layout
        content_layout = QVBoxLayout(self.content)
        content_layout.setContentsMargins(14, 14, 14, 14)
        content_layout.setSpacing(10)

        # ---------------------------
        # Search box (prefer SearchLineEdit, fallback to LineEdit)
        # ---------------------------
        try:
            if 'SearchLineEdit' in globals() and SearchLineEdit is not None:
                self.search_box = SearchLineEdit(self.content)
            else:
                raise Exception()
        except Exception:
            # LineEdit imported in your module header earlier
            self.search_box = LineEdit(self.content)
            self.search_box.setPlaceholderText(self.tr("Search fonts..."))

        self.search_box.setFixedHeight(36)
        # enforce background/placeholder/text visibility
        self.search_box.setAutoFillBackground(True)
        self.search_box.setAttribute(Qt.WA_StyledBackground, True)
        # Palette
        sp = self.search_box.palette()
        sp.setColor(QPalette.Base, QColor("#ffffff"))
        sp.setColor(QPalette.Text, QColor("#000000"))
        try:
            sp.setColor(QPalette.PlaceholderText, QColor("#777777"))
        except Exception:
            pass
        self.search_box.setPalette(sp)
        # add explicit stylesheet to avoid global QSS interference
        self.search_box.setStyleSheet("""
            QLineEdit { background: #ffffff; color: #000000; border: 1px solid rgba(0,0,0,0.12); padding:6px; border-radius:6px; }
            QLineEdit:focus { border: 1px solid #168be6; }
        """)
        content_layout.addWidget(self.search_box)

        # ---------------------------
        # Central area: list + preview
        # ---------------------------
        hbox = QHBoxLayout()
        hbox.setSpacing(10)

        # font list
        self.list_widget = QListWidget(self.content)
        self.list_widget.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.list_widget.setAutoFillBackground(True)
        self.list_widget.setAttribute(Qt.WA_StyledBackground, True)

        # ensure viewport paints background
        try:
            vp = self.list_widget.viewport()
            vp.setAutoFillBackground(True)
            vpal = vp.palette()
            vpal.setColor(QPalette.Base, QColor("#ffffff"))
            vpal.setColor(QPalette.Text, QColor("#000000"))
            vp.setPalette(vpal)
        except Exception:
            pass

        hbox.addWidget(self.list_widget, 3)

        # preview
        preview_frame = QFrame(self.content)
        preview_frame.setAutoFillBackground(True)
        preview_frame.setAttribute(Qt.WA_StyledBackground, True)
        preview_layout = QVBoxLayout(preview_frame)
        preview_layout.setContentsMargins(8, 8, 8, 8)
        preview_layout.setSpacing(8)

        preview_label_title = QLabel(self.tr("Preview"), preview_frame)
        preview_label_title.setAlignment(Qt.AlignCenter)
        preview_layout.addWidget(preview_label_title)

        self.preview_label = QLabel(
            "The quick brown fox jumps over the lazy dog 0123456789", preview_frame)
        self.preview_label.setWordWrap(True)
        self.preview_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        self.preview_label.setMinimumWidth(260)
        self.preview_label.setMinimumHeight(140)
        self.preview_label.setStyleSheet(
            "color: #000000; background: transparent;")
        preview_layout.addWidget(self.preview_label, 1)

        self.size_label = QLabel(self.tr("Preview size: 14"), preview_frame)
        self.size_label.setStyleSheet("color: #000000;")
        preview_layout.addWidget(self.size_label)
        hbox.addWidget(preview_frame, 2)

        content_layout.addLayout(hbox)

        # ---------------------------
        # Bottom controls: circular OK/Cancel (right aligned)
        # ---------------------------
        bottom_widget = QWidget(self.content)
        bottom_layout = QHBoxLayout(bottom_widget)
        bottom_layout.setContentsMargins(0, 0, 0, 0)
        bottom_layout.addStretch(1)

        # OK circular button
        self.ok_btn = QPushButton("✓", bottom_widget)
        self.ok_btn.setToolTip(self.tr("OK (Enter)"))
        self.ok_btn.setCursor(Qt.PointingHandCursor)
        self.ok_btn.clicked.connect(self._on_ok)
        self.ok_btn.setDefault(True)
        self.ok_btn.setAutoDefault(True)
        self.ok_btn.setFixedSize(48, 48)
        self.ok_btn.setStyleSheet("""
            QPushButton {
                border-radius: 24px;
                background: qlineargradient(x1:0,y1:0,x2:0,y2:1, stop:0 #39a0ff, stop:1 #0078d4);
                color: white; font-weight:700; font-size:18px;
            }
            QPushButton:hover { background: qlineargradient(x1:0,y1:0,x2:0,y2:1, stop:0 #4db3ff, stop:1 #168be6); }
            QPushButton:pressed { background: #006bb3; }
        """)
        bottom_layout.addWidget(self.ok_btn)
        bottom_layout.addSpacing(12)

        # Cancel circular button
        self.cancel_btn = QPushButton("✕", bottom_widget)
        self.cancel_btn.setToolTip(self.tr("Cancel (Esc)"))
        self.cancel_btn.setCursor(Qt.PointingHandCursor)
        self.cancel_btn.clicked.connect(self._on_cancel)
        self.cancel_btn.setFixedSize(48, 48)
        self.cancel_btn.setStyleSheet("""
            QPushButton {
                border-radius: 24px;
                background: transparent;
                border: 2px solid rgba(0,0,0,0.12);
                color: #222222; font-weight:700; font-size:16px;
            }
            QPushButton:hover { background: rgba(0,0,0,0.04); }
        """)
        bottom_layout.addWidget(self.cancel_btn)

        content_layout.addWidget(bottom_widget)

        # ---------------------------
        # Initialize fonts & signals
        # ---------------------------
        self._preview_size = 14
        self._load_system_fonts()
        self._apply_preview_font()

        self.search_box.textChanged.connect(self._filter_fonts)
        self.list_widget.currentItemChanged.connect(self._on_selection_changed)
        self.list_widget.itemDoubleClicked.connect(
            self._on_item_double_clicked)

        # Esc shortcut
        try:
            self.cancel_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)
            self.cancel_shortcut.activated.connect(self._on_cancel)
        except Exception:
            pass

    # ---------------------------
    # font list helpers
    # ---------------------------
    def _load_system_fonts(self):
        db = QFontDatabase()
        families = db.families()
        families = sorted(families, key=lambda s: s.lower())
        self.all_families = families
        self._populate_list(self.all_families)

    def _populate_list(self, families):
        self.list_widget.clear()
        for fam in families:
            item = QListWidgetItem(fam)
            # explicitly set visible foreground
            item.setForeground(QColor("#000000"))
            self.list_widget.addItem(item)

    def _filter_fonts(self, text):
        if not text:
            self._populate_list(self.all_families)
            return
        lowered = text.lower()
        filtered = [f for f in self.all_families if lowered in f.lower()]
        self._populate_list(filtered)

    # ---------------------------
    # interaction
    # ---------------------------
    def _on_selection_changed(self, current, previous=None):
        if current:
            self._update_preview(current.text())

    def _on_item_double_clicked(self, item):
        if item:
            self.selected_font = item.text()
            try:
                self.fontSelected.emit(self.selected_font)
            except Exception:
                pass
            self.accept()

    def _update_preview(self, family):
        try:
            font = QFont(family, self._preview_size)
            self.preview_label.setFont(font)
            self.size_label.setText(
                self.tr(f"Preview font size: {self._preview_size}"))
        except Exception:
            pass

    def _apply_preview_font(self):
        cur = self.list_widget.currentItem()
        if cur:
            self._update_preview(cur.text())
        else:
            if self.list_widget.count() > 0:
                self.list_widget.setCurrentRow(0)
                self._update_preview(self.list_widget.item(0).text())

    def _on_ok(self):
        cur = self.list_widget.currentItem()
        if cur:
            self.selected_font = cur.text()
            try:
                self.fontSelected.emit(self.selected_font)
            except Exception:
                pass
        self.accept()

    def _on_cancel(self):
        self.selected_font = None
        self.reject()


class ColorExtractionWorker(QThread):
    finished = pyqtSignal(dict)
    error = pyqtSignal(str)
    
    def __init__(self, image_path: str, num_colors: int = 5):
        super().__init__()
        self.image_path = image_path
        self.num_colors = num_colors
    
    def run(self):
        try:
            from tools.image_color_extractor import ImageColorExtractor
            extractor = ImageColorExtractor()
            color_info = extractor.get_color_info(self.image_path, self.num_colors)
            if color_info:
                self.finished.emit(color_info)
            else:
                self.error.emit("无法提取颜色信息")
        except ImportError as e:
            self.error.emit(f"缺少必要的库: {str(e)}")
        except Exception as e:
            self.error.emit(f"提取颜色时出错: {str(e)}")


class SettingPage(ScrollArea):
    themeChanged = pyqtSignal(str)
    themeColorChanged = pyqtSignal(str)  # Signal to emit the new theme color

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("Setting")
        self.logger = logging.getLogger("setting")
        # configer = SCM()
        self.config = configer.read_config()
        self.font_ = font_config()
        self.cfg = Config()
        self.parent_class = parent
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setAlignment(Qt.AlignTop)
        self.init_window_size = False

        # ----------------- Search box (NEW) -----------------
        self.search_box = LineEdit()
        self.search_box.setPlaceholderText(self.tr("Search settings..."))
        self.search_box.setClearButtonEnabled(True)
        self.search_box.textChanged.connect(self._on_search_text_changed)
        self.search_box.returnPressed.connect(self._jump_to_first_match)
        layout.addWidget(self.search_box)

        self._no_results_label = QLabel(self.tr("No matching settings"))
        self._no_results_label.setVisible(False)
        layout.addWidget(self._no_results_label)

        # internal structure to hold searchable items
        # each item: { 'widget': QWidget, 'title': str, 'keywords': [str] }
        self._search_items = []

        # helpers for highlight timer
        self._highlight_timers = {}

        # ----------------- Original settings -----------------
        self.language_card = ComboBoxSettingCard(
            configItem=self.cfg.language,
            icon=FluentIcon.GLOBE,
            title=self.tr("Language"),
            content=self.tr("Change application language (need to restart)"),
            texts=[
                self.tr("System Default"),
                "English",
                "简体中文",
                "日本語",
                "Русский"
            ]
        )
        self.language_card.comboBox.currentIndexChanged.connect(
            self._change_language)
        layout.addWidget(self.language_card)

        self._register_searchable(self.language_card, self.tr("Language"),
                                  ["language", "语言", "lang", "system default", "english", "中文", "简体中文", "日本語", "русский"])

        self.aigc = aigc_config()
        self.aigc.open_switchButton.checkedChanged.connect(
            lambda checked: configer.revise_config("aigc_open", checked))
        self.aigc.ModelComboBox.currentIndexChanged.connect(lambda index: configer.revise_config(
            "aigc_model", self.aigc.ModelComboBox.currentText()))
        self.aigc.ApiEdit.textEdited.connect(
            lambda text: configer.revise_config("aigc_api_key", text.strip()))

        self.aigc.Max_lengthEdit.editingFinished.connect(
            lambda: print("Max length changed"))
        self.aigc.Max_lengthEdit.editingFinished.connect(
            self.check_max_length_and_save)
        layout.addWidget(self.aigc)
        _register_searchable = self._register_searchable
        _register_searchable(self.aigc, "AI Model API Settings", [
            "AI", "Model", "API", "Settings", "ChatGPT", "DeepSeek", "Ollama", "Local"
        ])

        self.Color_card = ComboBoxSettingCard(
            configItem=self.cfg.background_color,
            icon=FluentIcon.BRUSH,
            title=self.tr("Background Color"),
            content=self.tr("Adjust background color"),
            texts=[self.tr("Light"), self.tr("Dark"),
                   self.tr("Follow system settings")]
        )
        layout.addWidget(self.Color_card)
        self._register_searchable(self.Color_card, self.tr("Background Color"), [
                                  "background", "color", "theme", "light", "dark"])

        self.bgCard = PushSettingCard(
            self.tr("Choose Background Image"),
            FluentIcon.PHOTO,
            self.tr("Custom Background"),
            self.tr("Set a custom background image"),
        )

        self.bgCard.clicked.connect(self._pick_bg)
        layout.addWidget(self.bgCard)
        self._register_searchable(self.bgCard, self.tr("Choose Background Image"), [
                                  "background", "image", "photo", "custom background"])

        self.opacityEdit = RangeSettingCard(
            self.cfg.opacity,
            FluentIcon.TRANSPARENT,
            title=self.tr("Background Opacity"),
            content=self.tr("Adjust background image opacity")
        )

        self.opacityEdit.valueChanged.connect(self._save_opacity_value)
        layout.addWidget(self.opacityEdit)
        self._register_searchable(self.opacityEdit, self.tr(
            "Background Opacity"), ["opacity", "transparent", "alpha"])

        self.clearBgCard = PushSettingCard(
            self.tr("Clear Background"),
            FluentIcon.DELETE,
            self.tr("Remove Custom Background"),
            self.tr("Restore default theme background"),
        )

        self.clearBgCard.clicked.connect(
            self.parent_class.clear_global_background)
        self.clearBgCard.clicked.connect(self._clear_bg_pic_to_config)
        layout.addWidget(self.clearBgCard)
        self._register_searchable(self.clearBgCard, self.tr("Clear Background"), [
                                  "clear", "remove", "background", "restore"])

        self.lock_ratio_card = SwitchSettingCard(
            icon=FluentIcon.LINK,
            title=self.tr("Lock Aspect Ratio"),
            content=self.tr("Affects the proportion of background image"),
            parent=self
        )

        self.lock_ratio_card.checkedChanged.connect(self.on_lock_ratio_changed)
        layout.addWidget(self.lock_ratio_card)
        self._register_searchable(self.lock_ratio_card, self.tr(
            "Lock Aspect Ratio"), ["lock", "ratio", "aspect", "比例"])

        self.cd_follow = SwitchSettingCard(
            icon=FluentIcon.ACCEPT,
            title=self.tr("Follow CD Directory"),
            content=self.tr(
                "When enabled, file manager follows new CD directory (Beta)"),
            parent=self
        )
        self.cd_follow.checkedChanged.connect(self._set_cd_follow)
        layout.addWidget(self.cd_follow)
        self._register_searchable(self.cd_follow, self.tr("Follow CD Directory"), [
                                  "cd", "directory", "follow", "file manager"])

        self.font_select = PushSettingCard(
            self.tr("Set Font"),
            FluentIcon.FONT,
            self.tr("Change terminal font (requires restart)"),
        )
        self.font_select.clicked.connect(self._select_font)
        layout.addWidget(self.font_select)
        self._register_searchable(self.font_select, self.tr(
            "Set Font"), ["font", "terminal", "typeface"])

        self.font_size = ComboBoxSettingCard(
            configItem=self.cfg.sizes,
            icon=FluentIcon.FONT_SIZE,
            title=self.tr("Font Size"),
            content=self.tr("Change terminal font size (requires restart)"),
            texts=[str(i) for i in range(12, 31)]
        )
        self.font_size.comboBox.currentIndexChanged.connect(
            self._set_font_size)
        layout.addWidget(self.font_size)
        self._register_searchable(self.font_size, self.tr(
            "Font Size"), ["size", "fontsize", "字号"])

        self.setWidget(container)
        self.setWidgetResizable(True)
        self.setStyleSheet("border: none;")

        self.cfg.background_color.valueChanged.connect(self._on_card_changed)

        self.default_view_card = ComboBoxSettingCard(
            configItem=self.cfg.default_view,
            icon=FluentIcon.VIEW,
            title=self.tr("Default file manager view"),
            content=self.tr("Set the default view of the file manager"),
            texts=[self.tr("Icon"), self.tr("Info")]
        )
        self.default_view_card.comboBox.currentIndexChanged.connect(
            self._on_default_view_changed)
        layout.addWidget(self.default_view_card)
        self._register_searchable(self.default_view_card, self.tr("Default file manager view"), [
                                  "view", "default view", "file manager", "icon", "info"])

        self.choose_color = PushSettingCard(
            self.tr("Open Color Picker"),
            FluentIcon.PENCIL_INK,
            self.tr("Set Font Color"),
            self.tr("Set SSH session font color (global)")
        )
        self.choose_color.clicked.connect(self._open_color_dialog)
        layout.addWidget(self.choose_color)
        self._register_searchable(self.choose_color, self.tr("Open Color Picker"), [
                                  "color", "picker", "font color", "ssh"])

        self.unbelievable_button = PushSettingCard(
            self.tr("Click me to delay school"),
            FluentIcon.FONT,
            self.tr("Literal meaning")
        )
        self.unbelievable_button.clicked.connect(self._unbelievable)
        layout.addWidget(self.unbelievable_button)
        self._register_searchable(self.unbelievable_button, self.tr(
            "Click me to delay school"), ["delay", "school", "click me"])

        # Create a custom setting card with a LineEdit for direct input
        self.transfer_card = SettingCard(
            FluentIcon.SPEED_HIGH,
            self.tr("Max Concurrent Transfers"),
            self.tr(
                "Set the maximum number of concurrent uploads/downloads (must be > 0 and ≤ 50000)"),
        )
        self.transfer_edit = LineEdit(self.transfer_card)
        self.transfer_edit.setValidator(QIntValidator(1, 50000))
        self.transfer_edit.setFixedWidth(150)
        self.transfer_edit.editingFinished.connect(
            self._save_transfer_value_from_edit)
        self.transfer_card.hBoxLayout.addWidget(
            self.transfer_edit, 0, Qt.AlignRight)
        layout.addWidget(self.transfer_card)

        self._register_searchable(self.transfer_card, self.tr("Max Concurrent Transfers"), [
                                  "transfer", "concurrent", "uploads", "downloads", "concurrency"])

        # External Editor Setting Card
        self.external_editor_card = SettingCard(
            FluentIcon.EDIT,
            self.tr("External Editor"),
            self.tr("Set the path to external editor executable (e.g., C:\\Program Files\\Notepad++\\notepad++.exe)"),
        )
        self.external_editor_edit = LineEdit(self.external_editor_card)
        self.external_editor_edit.setPlaceholderText(
            self.tr("Enter the full path to external editor executable"))
        self.external_editor_edit.setClearButtonEnabled(True)
        self.external_editor_edit.setMinimumWidth(300)
        self.external_editor_edit.editingFinished.connect(
            self._save_external_editor)
        self.external_editor_card.hBoxLayout.addWidget(
            self.external_editor_edit, 0, Qt.AlignRight)
        layout.addWidget(self.external_editor_card)
        self._register_searchable(self.external_editor_card, self.tr("External Editor"), [
                                  "external", "editor", "外置编辑器", "编辑器", "vscode", "notepad"])

        self._restore_saved_settings()

    # ----------------- Search helpers -----------------
    def _register_searchable(self, widget: QWidget, title: str, keywords=None):
        keywords = keywords or []
        self._search_items.append({
            'widget': widget,
            'title': title,
            'keywords': [k.lower() for k in keywords]
        })

    def _on_search_text_changed(self, text: str):
        q = text.strip().lower()
        any_visible = False
        if q == "":
            # show all
            for it in self._search_items:
                it['widget'].setVisible(True)
            self._no_results_label.setVisible(False)
            return

        for it in self._search_items:
            title = it['title'].lower() if it['title'] else ""
            kws = it['keywords']
            widget = it['widget']
            matched = q in title or any(q in kw for kw in kws)
            widget.setVisible(matched)
            if matched:
                any_visible = True
        self._no_results_label.setVisible(not any_visible)

    def _jump_to_first_match(self):
        # Scroll to first visible matching widget
        for it in self._search_items:
            if it['widget'].isVisible():
                target = it['widget']
                try:
                    self.ensureWidgetVisible(target)
                except Exception:
                    # fallback: try parent
                    target.parent().setFocus()
                # briefly highlight the widget
                self._highlight_widget(target)
                return

    def _highlight_widget(self, widget: QWidget, duration_ms: int = 1500):
        # apply temporary stylesheet to highlight a widget, then restore
        old = widget.styleSheet()
        highlight_ss = "border: 2px solid #0078d4; border-radius: 6px;"
        widget.setStyleSheet(old + "\n" + highlight_ss)

        # clear any previous timer
        if widget in self._highlight_timers:
            try:
                self._highlight_timers[widget].stop()
            except Exception:
                pass

        timer = QTimer(self)
        timer.setSingleShot(True)
        timer.timeout.connect(lambda: widget.setStyleSheet(old))
        timer.start(duration_ms)
        self._highlight_timers[widget] = timer

    # ----------------- rest of your existing methods (unchanged) -----------------
    def _save_opacity_value(self, value: int):
        configer.revise_config("background_opacity", value)

    def _save_transfer_value_from_edit(self):
        text = self.transfer_edit.text()
        if text.isdigit():
            value = int(text)
            if value > 0:
                configer.revise_config("max_concurrent_transfers", value)

    def _on_default_view_changed(self, index: int):
        view_map = {0: ("icon", "图标"), 1: ("details", "详情")}
        value_to_save, display_name = view_map.get(index, ("icon", "图标"))
        configer.revise_config("default_view", value_to_save)

    def _unbelievable(self):
        InfoBar.error(
            title=self.tr('What are you thinking'),
            content=self.tr(
                "Failed to set date \n date.set(month=7,day=1) \n Permissions error: Insufficient permissions"
            ),
            orient=Qt.Horizontal,
            isClosable=True,
            position=InfoBarPosition.TOP_RIGHT,
            duration=10000,
            parent=self
        )

    def _change_language(self, lang: str):
        if lang == 0:
            lang = "system"
        elif lang == 1:
            lang = "EN"
        elif lang == 2:
            lang = "CN"
        elif lang == 3:
            lang = "JP"
        elif lang == 4:
            lang = "RU"

        print(f"Selected language: {lang}")
        configer.revise_config("language", lang)

    def _set_cd_follow(self):
        self.follow_ = self.cd_follow.switchButton.isChecked()
        configer.revise_config("follow_cd", self.follow_)

    def _clear_bg_pic_to_config(self):
        configer.revise_config("bg_pic", None)
        configer.revise_config("bg_theme_color", None)
        default_color = "#cccccc"
        self.themeColorChanged.emit(default_color)

    def on_lock_ratio_changed(self):
        self._lock_ratio = self.lock_ratio_card.switchButton.isChecked()
        configer.revise_config("locked_ratio", self._lock_ratio)

    def _get_language_from_config(self):
        lang = self.config["language"]
        if lang == "system":
            return 0
        elif lang == "EN":
            return 1
        elif lang == "CN":
            return 2
        elif lang == "JP":
            return 3
        elif lang == "RU":
            return 4
        else:
            return 0

    def check_max_length_and_save(self):
        text = self.aigc.Max_lengthEdit.text()
        # print("editingFinished text:", text)
        if text.isdigit():
            value = int(text)
            if value > 100:
                self.aigc.Max_lengthEdit.setText("100")
            elif value < 1:
                self.aigc.Max_lengthEdit.setText("1")
        else:
            self.aigc.Max_lengthEdit.setText("10")

        configer.revise_config(
            "aigc_history_max_length",
            int(self.aigc.Max_lengthEdit.text())
        )

    def _restore_saved_settings(self):

        # Change interface value
        self.language_card.comboBox.setCurrentIndex(
            self._get_language_from_config())
        self.cfg.background_color.value = self.config["bg_color"]
        self.cfg.sizes.value = self.config["font_size"]
        self.lock_ratio_card.setChecked(self.config["locked_ratio"])
        self.cd_follow.setChecked(self.config["follow_cd"])
        self.parent_class.set_global_background(self.config["bg_pic"])
        self.opacityEdit.setValue(self.config["background_opacity"])
        self.cfg.default_view.value = "Icon" if self.config.get(
            "default_view", "icon") == "icon" else "Info"
        self.transfer_edit.setText(
            str(self.config.get("max_concurrent_transfers", 4)))
        self.external_editor_edit.setText(
            self.config.get("external_editor", ""))
        # Achieve results
        self._lock_ratio = self.config["locked_ratio"]
        self._restore_background_opacity(self.config["background_opacity"])
        self._set_window_size(
            (self.config["window_last_width"], self.config["window_last_height"]))
        self.aigc.open_switchButton.setChecked(
            self.config.get("aigc_open", False))
        self.aigc.ModelComboBox.setCurrentIndex(
            llm_models[self.config.get("aigc_model", "DeepSeek")])
        self.aigc.ApiEdit.setText(self.config.get("aigc_api_key", ""))

        self.aigc.Max_lengthEdit.setText(
            str(self.config.get("aigc_max_length", 10)))
        # self._set_color
        # self.themeChanged.emit(color)

    def _restore_background_opacity(self, value):
        parent = self.parent()
        while parent:
            if hasattr(parent, "set_background_opacity"):
                parent.set_background_opacity(value)
                break
            parent = parent.parent()

    def _set_color(self, color: str):
        parent = self.parent()
        while parent:
            if hasattr(parent, "set_ssh_session_text_color"):
                parent.set_ssh_session_text_color(color)
                break
            parent = parent.parent()
        configer.revise_config("ssh_widget_text_color", color)
        InfoBar.success(
            title=self.tr('Color changed successfully'),
            content='',
            orient=Qt.Horizontal,
            isClosable=True,
            position=InfoBarPosition.TOP_RIGHT,
            duration=2000,
            parent=self
        )

    def _open_color_dialog(self):
        dlg = ColorDialog(QColor(0, 255, 255), self.tr("Choose Color"),
                          self.window(), enableAlpha=False)

        dlg.colorChanged.connect(lambda color: self._set_color(color.name()))
        dlg.exec_()

    def _on_card_changed(self, value):
        print(value)
        self.themeChanged.emit(value)
        configer.revise_config("bg_color", value)

    def _set_font_size(self, index: int):
        size = int(self.font_size.comboBox.currentText())
        # print("选择的字号:", size)
        self.font_.write_font(font_size=size)
        configer.revise_config("font_size", str(size))

    def _pick_bg(self):
        path, _ = QFileDialog.getOpenFileName(
            self,
            self.tr("Select a background image"),
            "",
            self.tr("Image files (*.png *.jpg *.jpeg *.bmp *.gif)")
        )
        print(f"Background file selected: {path}")
        if not path:
            return
        else:
            configer.revise_config("bg_pic", path)
            self.parent_class.set_global_background(path)
            self._extract_and_save_theme_colors(path)
    
    def _extract_and_save_theme_colors(self, image_path: str):
        self._color_worker = ColorExtractionWorker(image_path, num_colors=5)
        self._color_worker.finished.connect(self._on_color_extraction_finished)
        self._color_worker.error.connect(self._on_color_extraction_error)
        self._color_worker.start()
    
    def _on_color_extraction_finished(self, color_info: dict):
        try:
            dominant_hex = color_info['dominant_color']['hex']
            configer.revise_config("bg_theme_color", dominant_hex)
            self.themeColorChanged.emit(dominant_hex)
        except Exception as e:
            pass
        finally:
            self._color_worker.deleteLater()
    
    def _on_color_extraction_error(self, error_msg: str):
        if "缺少必要的库" in error_msg or "ImportError" in error_msg:
            content = self.tr('Please install required libraries:\npip install Pillow scikit-learn numpy')
        else:
            content = error_msg
        InfoBar.warning(
            title=self.tr('Color extraction failed'),
            content=content,
            orient=Qt.Vertical,
            isClosable=True,
            position=InfoBarPosition.TOP_RIGHT,
            duration=5000,
            parent=self
        )
        self._color_worker.deleteLater()

    def _save_external_editor(self):
        path = self.external_editor_edit.text().strip()
        if path:
            if not os.path.isfile(path):
                InfoBar.error(
                    title=self.tr('Invalid file path'),
                    content=self.tr('The specified file does not exist or is not a valid file'),
                    orient=Qt.Horizontal,
                    isClosable=True,
                    position=InfoBarPosition.TOP_RIGHT,
                    duration=3000,
                    parent=self
                )
                return
        configer.revise_config("external_editor", path)

    def _select_font(self):
        font_dialog = FontSelectorDialog(self)
        font_dialog.fontSelected.connect(self.on_font_selected)
        font_dialog.exec_()

    def on_font_selected(self, font_name):
        print(f"Selected font: {font_name}")
        self.font_.write_font(font_path=font_name)

    def save_window_size(self, sizes: tuple):
        width, height = sizes
        configer.revise_config("window_last_width", width)
        configer.revise_config("window_last_height", height)

    def _set_window_size(self, sizes: tuple):
        width, height = sizes
        self.parent().resize(width, height)
        self.init_window_size = True

    def _restart(self):
        pass
</file>

<file path="widgets/transfer_progress_widget.py">
from PyQt5.QtCore import Qt, QTimer, QPropertyAnimation, QEvent, pyqtSignal
from PyQt5.QtGui import QColor, QFont
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame, QScrollArea, QToolTip
from qfluentwidgets import FluentIcon as FIF, IconWidget, ToolButton
from tools.font_config import font_config


class TransferProgressWidget(QWidget):
    """ File Transfer Progress Widget """
    expansionChanged = pyqtSignal(bool)
    cancelRequested = pyqtSignal(str)
    open_file = pyqtSignal(str)  # file_id

    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setObjectName("transferProgressWidget")
        self.is_expanded = False
        self._animations = []
        self.transfer_items = {}
        self.completed_count = 0
        self.total_count = 0

        # Main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)

        # Header
        self.header = QWidget(self)
        self.header.setObjectName("header")
        self.header_layout = QHBoxLayout(self.header)
        self.header_layout.setContentsMargins(10, 5, 10, 5)
        self.header.setCursor(Qt.PointingHandCursor)

        self.title_label = QLabel("File Transfers", self.header)
        self.title_label.setObjectName("titleLabel")
        self.title_label.setWordWrap(True)

        self.count_label = QLabel("", self.header)
        self.count_label.setObjectName("countLabel")

        icon_widget = ToolButton(FIF.BROOM)
        icon_widget.setFixedSize(32, 32)
        icon_widget.setToolTip(self.tr("Clean finished"))
        icon_widget.clicked.connect(lambda: self.clear_completed_items())

        self.header_layout.addWidget(self.title_label, 0, Qt.AlignLeft)
        self.header_layout.addStretch(1)
        self.header_layout.addWidget(icon_widget)
        self.header_layout.addWidget(self.count_label, 0, Qt.AlignRight)

        self.header.installEventFilter(self)

        # Content area (collapsible)
        # Content area (collapsible) with ScrollArea
        self.content_area = QFrame(self)
        self.content_area.setObjectName("contentArea")
        self.content_area_layout = QVBoxLayout(self.content_area)
        self.content_area_layout.setContentsMargins(0, 0, 0, 0)
        self.content_area_layout.setSpacing(3)

        self.scroll_area = QScrollArea(self.content_area)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setFrameShape(QFrame.NoFrame)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll_area.setStyleSheet("""
            QScrollArea {
                background-color: transparent;
            }
            QScrollBar:vertical {
                border: none;
                background: #2A2A2A;
                width: 8px;
                margin: 0px 0px 0px 0px;
            }
            QScrollBar::handle:vertical {
                background: #555555;
                min-height: 20px;
                border-radius: 4px;
            }
            QScrollBar::handle:vertical:hover {
                background: #666666;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                border: none;
                background: none;
            }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                background: none;
            }
        """)

        self.scroll_content = QWidget()
        self.content_layout = QVBoxLayout(self.scroll_content)
        self.content_layout.setContentsMargins(10, 5, 10, 5)
        self.content_layout.setSpacing(3)
        self.content_layout.addStretch(1)
        self.scroll_area.setWidget(self.scroll_content)
        self.content_area_layout.addWidget(self.scroll_area)

        # Initial state: collapsed
        self.content_area.setVisible(False)

        self.main_layout.addWidget(self.header)
        self.main_layout.addWidget(self.content_area)

        self._apply_stylesheet()
        self._update_title()

        font_ = font_config()
        self._font = font_.get_font()
        self.set_font_family(self._font)

    def add_transfer_item(self, file_id: str, data: dict):
        if not self.isVisible():
            self.setVisible(True)

        if file_id in self.transfer_items:
            # If item already exists, just update it
            self.update_transfer_item(file_id, data)
            return

        self.total_count += 1
        self._update_title()

        transfer_type = data.get("type", "upload")
        filename = data.get("filename", "Unknown File")
        progress = data.get("progress", 0)

        item_widget = QFrame()
        item_widget.setObjectName("itemWidget")
        item_widget.setFixedHeight(35)
        item_widget.setCursor(Qt.PointingHandCursor)
        item_widget.installEventFilter(self)
        item_layout = QHBoxLayout(item_widget)
        item_layout.setContentsMargins(8, 2, 8, 2)

        # --- Icon ---
        if transfer_type == "upload":
            icon, color = FIF.UP, QColor("#0078D4")
        else:
            icon, color = FIF.DOWN, QColor("#D83B01")

        status_icon = IconWidget(icon, item_widget)
        status_icon.setObjectName("statusIcon")
        status_icon.setFixedSize(16, 16)

        # --- Filename ---
        filename_label = QLabel(filename, item_widget)
        filename_label.setWordWrap(False)
        filename_label.setMinimumWidth(1)

        item_layout.addWidget(status_icon)
        item_layout.addSpacing(10)
        item_layout.addWidget(filename_label)
        item_layout.addStretch(1)

        # --- Progress Label ---
        progress_label = QLabel(f"{progress}%", item_widget)
        progress_label.setObjectName("progressLabel")
        item_layout.addWidget(progress_label)

        # --- Waiting Icon ---
        waiting_icon = IconWidget(FIF.HISTORY, item_widget)
        waiting_icon.setObjectName("waitingIcon")
        waiting_icon.setFixedSize(16, 16)
        waiting_icon.hide()
        item_layout.addWidget(waiting_icon)

        # --- Completed Icon ---
        completed_icon = IconWidget(FIF.ACCEPT, item_widget)
        completed_icon.setObjectName("completedIcon")
        completed_icon.setFixedSize(16, 16)
        completed_icon.setStyleSheet(
            f"color: {QColor('#107C10').name()}; background-color: transparent;")
        completed_icon.hide()
        item_layout.addWidget(completed_icon)

        # --- Open Folder Icon ---
        open_folder_icon = ToolButton(FIF.FOLDER, item_widget)
        open_folder_icon.setObjectName("openFolderIcon")
        open_folder_icon.setFixedSize(16, 16)
        open_folder_icon.setStyleSheet("color: #605E5C;")
        open_folder_icon.clicked.connect(lambda: self.open_file.emit(file_id))
        open_folder_icon.hide()
        item_layout.addWidget(open_folder_icon)

        # --- Cancel Icon (for hover) ---
        cancel_icon = ToolButton(FIF.DELETE, item_widget)
        cancel_icon.setObjectName("cancelIcon")
        cancel_icon.setFixedSize(16, 16)
        cancel_icon.setStyleSheet("color: #E81123;")
        cancel_icon.clicked.connect(lambda: self.stop_transmission(file_id))
        cancel_icon.hide()
        item_layout.addWidget(cancel_icon)

        # --- Store and add to layout ---
        item_widget.setProperty("transfer_type", transfer_type)
        # Add a property to track completion status to avoid double counting
        item_widget.setProperty("is_completed", False)
        self.transfer_items[file_id] = item_widget
        self.content_layout.insertWidget(0, item_widget)

        self.update_transfer_item(file_id, data)

    def stop_transmission(self, file_id):
        if file_id:
            self.cancelRequested.emit(file_id)
            return True

    def update_transfer_item(self, file_id: str, data: dict):
        item_widget = self.transfer_items.get(file_id)
        if not item_widget:
            return

        # Store data for hover state restoration
        item_widget.setProperty("last_data", data)
        transfer_type = data.get("type", "upload")
        progress = data.get("progress", 0)
        filename = data.get("filename", "")
        filename_label = item_widget.findChild(QLabel)
        bytes_so_far = data.get("bytes_so_far", 0)
        total_bytes = data.get("total_bytes", 0)
        status_icon = item_widget.findChild(IconWidget, "statusIcon")
        progress_label = item_widget.findChild(QLabel, "progressLabel")
        completed_icon = item_widget.findChild(IconWidget, "completedIcon")
        waiting_icon = item_widget.findChild(IconWidget, "waitingIcon")
        cancel_icon = item_widget.findChild(ToolButton, "cancelIcon")
        open_folder_icon = item_widget.findChild(ToolButton, "openFolderIcon")
        if not all([status_icon, progress_label, completed_icon, waiting_icon, cancel_icon]):
            return

        # Hide cancel icon unless it's being hovered
        if not item_widget.underMouse():
            cancel_icon.hide()
            open_folder_icon.hide()
        if filename_label:
            if total_bytes > 0:
                # Convert bytes to MB and format the string
                transferred_mb = bytes_so_far / (1024 * 1024)
                total_mb = total_bytes / (1024 * 1024)
                filename_label.setText(
                    f"{filename} ({transferred_mb:.2f}/{total_mb:.2f} MB)")
            elif filename:
                filename_label.setText(filename)
            item_widget.setToolTip(filename_label.text())

        # --- Update widgets based on transfer type ---
        if transfer_type == "completed":
            if not item_widget.property("is_completed"):
                item_widget.setProperty("is_completed", True)
                self.completed_count += 1
                self._update_title()

            color = QColor("#107C10")  # Green for completed
            progress_label.hide()
            waiting_icon.hide()
            completed_icon.show()

            # Keep original icon but update color to green
            original_type = item_widget.property("transfer_type")
            if original_type == "upload":
                status_icon.setIcon(FIF.UP)
            elif original_type == "download":
                status_icon.setIcon(FIF.DOWN)
            status_icon.setStyleSheet(
                f"color: {color.name()}; background-color: transparent;")

        elif progress == -1:  # Waiting state
            progress_label.hide()
            completed_icon.hide()
            waiting_icon.show()

            if transfer_type == "upload":
                color = QColor("#0078D4")
            else:  # download
                color = QColor("#D83B01")

            status_icon.setStyleSheet(
                f"color: {color.name()}; background-color: transparent;")
            waiting_icon.setStyleSheet(
                f"color: {color.name()}; background-color: transparent;")

        else:  # In-progress upload or download
            progress_label.show()
            completed_icon.hide()
            waiting_icon.hide()
            progress_label.setText(f"{progress}%")

            if transfer_type == "upload":
                color = QColor("#0078D4")
                if status_icon.icon != FIF.UP:
                    status_icon.setIcon(FIF.UP)
            elif transfer_type == "download":
                color = QColor("#D83B01")
                if status_icon.icon != FIF.DOWN:
                    status_icon.setIcon(FIF.DOWN)

            status_icon.setStyleSheet(
                f"color: {color.name()}; background-color: transparent;")

        # --- Update background style ---
        stop_pos = progress / 100.0
        base_bg = "#3C3C3C"
        hover_bg = "#5A5A5A"  # A brighter background for hover

        # Define styles for normal and hover states
        bg_style = ""
        hover_style = ""

        if progress < 0:  # Waiting state
            bg_style = f"background-color: {base_bg};"
            hover_style = f"background-color: {hover_bg};"
        elif stop_pos >= 1:  # Completed or 100%
            hover_color = QColor(color).lighter(120).name()
            bg_style = f"background-color: {color.name()};"
            hover_style = f"background-color: {hover_color};"
        else:  # In-progress
            bg_style = f"""
                background-color: qlineargradient(
                    x1:0, y1:0, x2:1, y2:0,
                    stop:{stop_pos} {color.name()}, stop:{stop_pos + 0.001} {base_bg}
                );
            """
            hover_style = f"""
                background-color: qlineargradient(
                    x1:0, y1:0, x2:1, y2:0,
                    stop:{stop_pos} {color.name()}, stop:{stop_pos + 0.001} {hover_bg}
                );
            """

        item_widget.setStyleSheet(f"""
            #itemWidget {{
                {bg_style}
                border-radius: 6px;
            }}
            #itemWidget:hover {{
                {hover_style}
            }}
            #itemWidget > QLabel, #itemWidget > IconWidget {{
                background-color: transparent;
            }}
        """)

    def remove_transfer_item(self, file_id: str):
        # import inspect
        # caller_frame = inspect.stack()[1]  # 1 表示上一级调用者
        # caller_filename = caller_frame.filename
        # caller_line_no = caller_frame.lineno
        # caller_func_name = caller_frame.function
        # print(
        #     f"Called from {caller_func_name} in {caller_filename}:{caller_line_no}")
        item_widget = self.transfer_items.pop(file_id, None)
        if item_widget:
            if item_widget.property("is_completed"):
                self.completed_count -= 1
            self.total_count -= 1
            self._update_title()
            item_widget.hide()
            QTimer.singleShot(0, item_widget.deleteLater)
        # Keep the widget visible even when the list is empty
        # if not self.transfer_items:
        #     self.setVisible(False)

    def toggle_view(self):
        """Toggle the expanded/collapsed state - notify parent to handle layout."""
        self.is_expanded = not self.is_expanded
        
        if self.is_expanded:
            self.content_area.setVisible(True)
            self.content_area.setMaximumHeight(16777215)
        else:
            self.content_area.setVisible(False)
            self.content_area.setMaximumHeight(0)
        
        self.expansionChanged.emit(self.is_expanded)

    def eventFilter(self, obj, event):
        if obj is self.header and event.type() == QEvent.MouseButtonPress:
            self.toggle_view()
            return True

        if "itemWidget" in str(obj.objectName()):
            # Find all relevant child widgets
            progress_label = obj.findChild(QLabel, "progressLabel")
            completed_icon = obj.findChild(IconWidget, "completedIcon")
            waiting_icon = obj.findChild(IconWidget, "waitingIcon")
            cancel_icon = obj.findChild(ToolButton, "cancelIcon")
            open_folder_icon = obj.findChild(ToolButton, "openFolderIcon")

            if event.type() == QEvent.Enter:
                if progress_label:
                    progress_label.hide()
                if completed_icon:
                    completed_icon.hide()
                if waiting_icon:
                    waiting_icon.hide()
                if cancel_icon:
                    cancel_icon.show()
                if open_folder_icon:
                    open_folder_icon.show()
                return True

            elif event.type() == QEvent.Leave:
                if cancel_icon:
                    cancel_icon.hide()
                # Restore the original state by re-calling update
                file_id = next(
                    (fid for fid, widget in self.transfer_items.items() if widget == obj), None)
                last_data = obj.property("last_data")
                if file_id and last_data:
                    self.update_transfer_item(file_id, last_data)
                return True

        return super().eventFilter(obj, event)

    def _update_title(self):
        """Updates the title label with the current transfer counts."""
        self.count_label.setText(
            f"({self.completed_count}/{self.total_count})")

    def _apply_stylesheet(self):
        self.setStyleSheet("""
            #transferProgressWidget {
                background-color: #2C2C2C;
                border-top: 1px solid #444444;
            }
            #header {
                background-color: transparent;
                border-bottom: 1px solid #444444;
            }
            #titleLabel, #countLabel {
                font-size: 14px;
                font-weight: bold;
                color: #FFFFFF;
                background-color: transparent;
            }
            #contentArea {
                background-color: transparent;
                border: none;
            }
            QLabel {
                color: #E0E0E0;
                background-color: transparent;
            }
        """)

    def set_font_family(self, font_family: str, font_size: int = 12):
        font = QFont(font_family)
        self.title_label.setFont(font)
        self.count_label.setFont(font)
        for item_widget in self.transfer_items.values():
            for child in item_widget.findChildren(QWidget):
                if isinstance(child, QLabel):
                    child.setFont(font)
                if isinstance(child, IconWidget):
                    child.setFont(font)

    def event(self, event):
        if event.type() == QEvent.ToolTip:
            # Find the item widget under the mouse
            pos = self.mapFromGlobal(event.globalPos())
            for item_widget in self.transfer_items.values():
                if item_widget.geometry().contains(pos):
                    QToolTip.showText(event.globalPos(),
                                      item_widget.toolTip(), self)
                    return True
        return super().event(event)

    def clear_completed_items(self):
        """清除所有已完成的传输项目"""
        completed_file_ids = []

        for file_id, item_widget in list(self.transfer_items.items()):
            if item_widget.property("is_completed"):
                completed_file_ids.append(file_id)

        for file_id in completed_file_ids:
            self.remove_transfer_item(file_id)

        self._update_title()

        print(f"清理了 {len(completed_file_ids)} 个已完成项目")
</file>

<file path="tools/setting_config.py">
from pathlib import Path
import json
import os
# Setting Config Manager


class SCM:
    def __init__(self):
        config_dir = Path.home() / ".config"
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)

        self.default_config = {
            "bg_color": "Dark",  # Dark or Light
            "bg_pic": None,  # Path or None
            "font_size": 12,  # 12-30
            "locked_ratio": True,  # Bool
            "ssh_widget_text_color": "#FFFFFF",  # color code
            "background_opacity": 100,  # int 0-100
            "window_last_width": 720,  # int
            "window_last_height": 680,  # int
            "follow_cd": False,  # bool
            "language": "system",  # system, EN, CN, JP, RU
            "default_view": "icon",  # icon or details
            "max_concurrent_transfers": 10,  # int 1-10
            "compress_upload": False,  # bool compress_upload
            "splitter_lr_ratio": [0.2, 0.8],  # proportion
            "splitter_tb_ratio": [0.6, 0.4],  # proportion
            "maximized": False,  # bool Restore the last maximized state
            "aigc_api_key": "",  # str Your API key for the AI model
            "aigc_open": False,  # bool Whether to enable the AI model feature
            "aigc_model": "DeepSeek",  # str The AI model to use
            "aigc_history_max_length": 10,  # int The max length of history messages
            "splitter_left_components": [0.18, 0.47, 0.35],
            "open_mode": False,  # bool  true:external editor, false: internal viewer
            "external_editor": "",
            # bool Auto-save editor files when focus is lost
            "editor_auto_save_on_focus_lost": False,
            "splitter_sizes": [500, 500],
            "splitter_lr_left_width": 300,
            "bg_theme_color": None
        }
        self.config_path = Path.home() / ".config" / "setting-config.json"
        if not os.path.exists(self.config_path):
            self.init_config()
            print("Config file created at:", self.config_path)
        else:
            self._check_and_repair_config(self.read_config())

    def write_config(self, config_data):
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, ensure_ascii=False, indent=4)
        except Exception as e:
            print(f"Failed to write config file: {e}")

    def _check_and_repair_config(self, config: dict) -> dict:

        repaired = False
        for key in self.default_config:
            if key not in config:
                config[key] = self.default_config[key]
                repaired = True
        if repaired:
            self.write_config(config)
        return config

    def init_config(self):
        self.write_config(self.default_config)

    def revise_config(self, key, value):
        config = self.read_config()
        config[key] = value
        # print(config)
        self.write_config(config)

    def read_config(self) -> dict:
        with open(self.config_path, mode="r", encoding="utf-8") as f:
            config_dict = json.load(f)
        return config_dict
</file>

<file path="widgets/ssh_widget.py">
from PyQt5.QtWidgets import (
    QWidget, QStackedWidget, QVBoxLayout, QHBoxLayout, QFrame,
    QLabel, QSizePolicy, QSplitter, QApplication
)
from PyQt5.QtCore import Qt, QPoint, pyqtSignal, QTimer, QSize
from PyQt5.QtGui import QIcon, QPixmap, QPainter, QColor, QPen, QPainterPath

from qfluentwidgets import SegmentedWidget, RoundMenu, Action, FluentIcon as FIF, ToolButton, Dialog

from tools.setting_config import SCM
from tools.llm_helper import LLMHelper
from widgets.ssh_webterm import WebTerminal
from widgets.network_detaile import NetProcessMonitor
from widgets.system_resources_widget import ProcessTable
from widgets.task_widget import Tasks
from widgets.file_tree_widget import File_Navigation_Bar, FileTreeWidget
from widgets.files_widgets import FileExplorer
from widgets.transfer_progress_widget import TransferProgressWidget
from widgets.command_input import CommandInput
from tools.session_manager import SessionManager
from widgets.task_detaile import ProcessMonitor
from widgets.disk_usage_item import DiskMonitor
CONFIGER = SCM()
session_manager = SessionManager()


class SSHPage(QWidget):
    # 定义信号：action 名称, session 名称
    menuActionTriggered = pyqtSignal(str, str)

    def __init__(self, parent=None):
        super().__init__(parent)

        self.vbox = QVBoxLayout(self)
        self.vbox.setContentsMargins(10, 10, 10, 10)
        self.vbox.setSpacing(5)

        # 上半部分：SSH 导航栏
        self.pivot = SegmentedWidget(self)
        self.vbox.addWidget(self.pivot, 0)

        # 下半部分：SSH 主窗口
        self.sshStack = QStackedWidget(self)
        self.vbox.addWidget(self.sshStack, 1)

        # 切换逻辑
        self.pivot.currentItemChanged.connect(
            lambda k: self.sshStack.setCurrentWidget(
                self.findChild(QWidget, k))
        )

        # 设置右键菜单策略
        self.pivot.setContextMenuPolicy(Qt.CustomContextMenu)
        self.pivot.customContextMenuRequested.connect(self.show_context_menu)

    def add_session(self, object_name: str, text: str, widget: QWidget):
        widget.setObjectName(object_name)
        if isinstance(widget, QLabel):
            widget.setAlignment(Qt.AlignCenter)

        self.sshStack.addWidget(widget)
        self.pivot.addItem(routeKey=object_name, text=text)
        QTimer.singleShot(0, lambda: self.pivot.setCurrentItem(object_name))
        self.sshStack.setCurrentWidget(widget)

    def get_current_route_key(self):
        """返回当前选中 tab 的 routeKey"""
        current_item = self.pivot.currentItem()
        if not current_item:
            return None
        for key, item in self.pivot.items.items():
            if item == current_item:
                return key
        return None

    def remove_session(self, routeKey: str):
        """删除指定的 session"""
        if routeKey not in self.pivot.items:
            return

        if self.pivot.currentItem() == self.pivot.items[routeKey]:
            remaining_keys = [k for k in self.pivot.items if k != routeKey]
            if remaining_keys:
                self.pivot.setCurrentItem(remaining_keys[0])
                self.sshStack.setCurrentWidget(
                    self.findChild(QWidget, remaining_keys[0])
                )
            else:
                self.pivot._currentRouteKey = None

        item = self.pivot.items.pop(routeKey)
        item.setParent(None)
        item.deleteLater()

        widget_to_remove = self.findChild(QWidget, routeKey)
        if widget_to_remove:
            self.sshStack.removeWidget(widget_to_remove)
            widget_to_remove.setParent(None)
            widget_to_remove.deleteLater()

    def show_context_menu(self, pos: QPoint):
        """在 pivot 上显示右键菜单，同时切换到鼠标所在的 tab"""
        child = self.pivot.childAt(pos)
        if not child:
            return

        route_key = None
        for key, item in self.pivot.items.items():  # items 是字典
            if item == child or item.isAncestorOf(child):
                route_key = key
                break

        # Switch to the tab where the right-click is located
        self.pivot.setCurrentItem(route_key)
        session_name = self.pivot.currentItem().text()
        # print(session_name)

        menu = RoundMenu(title="", parent=self)
        close_action = Action(self.tr("Close Session"))
        duplicate_action = Action(self.tr("Duplicate Session"))

        close_action.triggered.connect(
            lambda: self.menuActionTriggered.emit(
                "close", session_name)
        )
        duplicate_action.triggered.connect(
            lambda: self.menuActionTriggered.emit(
                "copy", session_name)
        )

        menu.addAction(close_action)
        menu.addAction(duplicate_action)

        global_pos = self.pivot.mapToGlobal(pos)
        menu.exec(global_pos)


class SSHWidget(QWidget):

    def __init__(self, name: str,  parent=None, font_name=None, user_name=None):
        super().__init__(parent=parent)
        self.file_manager = None
        config = CONFIGER.read_config()
        use_ai = config.get("aigc_open", False)
        self.setObjectName(name)
        self.router = name
        self.parentkey = name.split('-')[0].strip()
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.sys_info_msg = ""

        self.mainLayout = QVBoxLayout(self)
        self.mainLayout.setContentsMargins(0, 0, 0, 0)
        self.mainLayout.setSpacing(0)

        # --- Left Widget ---
        leftContainer = QFrame(self)
        leftContainer.setObjectName("leftContainer")
        leftContainer.setSizePolicy(
            QSizePolicy.Preferred, QSizePolicy.Expanding)

        leftLayout = QVBoxLayout(leftContainer)
        leftLayout.setContentsMargins(0, 0, 0, 0)
        leftLayout.setSpacing(0)

        self.leftSplitter = QSplitter(Qt.Vertical, leftContainer)
        self.leftSplitter.setObjectName("splitter_left_components")
        self.leftSplitter.setChildrenCollapsible(False)
        self.leftSplitter.setHandleWidth(2)
        # The stylesheet will be set dynamically later

        # sys_resources
        self.sys_resources = ProcessTable(self.leftSplitter)
        self.sys_resources.set_font_family(font_name)
        self.sys_resources.setObjectName("sys_resources")
        self.sys_resources.setMinimumHeight(80)
        self.sys_resources.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.sys_resources.setStyleSheet("""
            QFrame#sys_resources {
                background-color: rgba(200, 200, 200, 0.12);
                border: 1px solid rgba(0,0,0,0.12);
                border-radius: 6px;
            }
        """)

        # Task
        self.task = Tasks(self.leftSplitter)
        self.task.sysinfo_button.clicked.connect(self._sys_info_dialog)
        self.task.set_text_color(config["ssh_widget_text_color"])
        self.task.setObjectName("task")
        self.task.setMinimumHeight(80)
        self.task.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.task.setStyleSheet("""
            QFrame#task {
                background-color: rgba(220, 220, 220, 0.06);
                border: 1px solid rgba(0,0,0,0.06);
                border-radius: 6px;
            }
        """)

        self.disk_usage = DiskMonitor(self.leftSplitter)
        self.disk_usage.into_driver_path.connect(self._set_file_bar)
        self.disk_usage.setObjectName("disk_usage")
        self.disk_usage.setMinimumHeight(80)
        self.disk_usage.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.disk_usage.setStyleSheet("""
            QWidget#disk_usage {
                background-color: rgba(240,240,240,0.08);
                border: 1px solid rgba(0,0,0,0.04);
                border-radius: 6px;
            }
""")
        self.disk_usage.setAttribute(Qt.WA_StyledBackground, True)

        self.leftSplitter.addWidget(self.sys_resources)
        self.leftSplitter.addWidget(self.task)
        self.leftSplitter.addWidget(self.disk_usage)

        self.leftSplitter.setStretchFactor(0, 15)  # sys_resources
        self.leftSplitter.setStretchFactor(1, 40)  # task
        self.leftSplitter.setStretchFactor(2, 30)  # disk_usage

        self.leftSplitter.splitterMoved.connect(self.on_splitter_moved)

        leftLayout.addWidget(self.leftSplitter, 1)

        self.transfer_progress = TransferProgressWidget(leftContainer)
        self.transfer_progress.setObjectName("transfer_progress")
        self.transfer_progress.setSizePolicy( QSizePolicy.Expanding, QSizePolicy.Preferred)
        leftLayout.addWidget(self.transfer_progress, 0)
        
        self.transfer_progress.expansionChanged.connect(
            lambda expanded: self._on_transfer_expansion_changed(expanded, leftLayout, self.leftSplitter)
        )

        splitter_left_ratio = config.get("splitter_left_components", [0.18, 0.47, 0.35])
        if len(splitter_left_ratio) == 3:
            sizes = [int(r * 1000) for r in splitter_left_ratio]
            self.leftSplitter.setSizes(sizes)

        # --- Right Widgets
        rightContainer = QFrame(self)
        rightContainer.setObjectName("rightContainer")
        rightContainer.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Expanding)

        rightLayout = QVBoxLayout(rightContainer)
        rightLayout.setContentsMargins(0, 0, 0, 0)
        rightLayout.setSpacing(0)
        self.rsplitter = QSplitter(Qt.Vertical, rightContainer)
        self.rsplitter.setObjectName("splitter_tb_ratio")
        self.rsplitter.setChildrenCollapsible(False)
        self.rsplitter.setHandleWidth(1)
        
        # Top container for ssh_widget and command_bar
        top_container = QFrame(self.rsplitter)
        top_container_layout = QVBoxLayout(top_container)
        top_container_layout.setContentsMargins(0, 0, 0, 0)
        top_container_layout.setSpacing(0)

        # ssh_widget
        self.ssh_widget = WebTerminal(
            top_container,
            font_name=font_name,
            user_name=user_name,
            text_color=config["ssh_widget_text_color"]
        )
        self.ssh_widget.directoryChanged.connect(self._set_file_bar)
        self.ssh_widget.setObjectName("ssh_widget")
        self.ssh_widget.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.ssh_widget.setStyleSheet("""
            QFrame#ssh_widget {
                background-color: rgba(255, 255, 255, 0.02);
                border: 1px solid rgba(0,0,0,0.04);
                border-radius: 6px;
            }
        """)

        # command input bar
        self.command_bar = QFrame(top_container)
        self.command_bar.setObjectName("command_bar")
        # self.command_bar.setFixedHeight(42) # Remove fixed height

        self.command_bar.setStyleSheet("""
            QFrame#command_bar {
                background-color: rgba(30, 30, 30, 0.5);
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 8px;
            }
            QFrame#command_bar:focus-within {
                border: 1px solid rgba(0, 122, 255, 0.7);
            }
            ToolButton {
                background-color: transparent;
                border-radius: 4px;
            }
            ToolButton:hover {
                background-color: rgba(255, 255, 255, 0.1);
            }
            ToolButton:pressed {
                background-color: rgba(255, 255, 255, 0.05);
            }
        """)
        command_bar_layout = QHBoxLayout(self.command_bar)
        command_bar_layout.setContentsMargins(8, 5, 8, 5)
        command_bar_layout.setSpacing(8)

        self.command_icon = ToolButton(FIF.BROOM, self.command_bar)
        self.history = ToolButton(FIF.HISTORY, self.command_bar)
        # Add bash wrap toggle button
        # Add bash wrap toggle button
        self.bash_wrap_button = ToolButton(
            self.command_bar)  # Icon will be set manually
        self.bash_wrap_button.setCheckable(True)
        self.bash_wrap_button.setToolTip(
            self.tr("Toggle `bash -c` wrapper for commands"))
        self.bash_wrap_enabled = False

        # Create and cache icons
        self.icon_bash_disabled = self._create_bash_wrap_icon(
            enabled=False)
        self.icon_bash_enabled = self._create_bash_wrap_icon(enabled=True)
        self.bash_wrap_button.setIcon(self.icon_bash_disabled)

        self.bash_wrap_button.toggled.connect(self._on_bash_wrap_toggled)

        self.command_input = CommandInput(font_name, use_ai, self.command_bar)

        self.command_input.setObjectName("command_input")
        self.command_input.setPlaceholderText(
            self.tr("Shift+Enter for new line. Enter Alt to show history command. Ctrl+O to get AI suggestion (if open)"))
        # self.command_input.setFixedHeight(32) # Remove fixed height
        self.command_input.setVerticalScrollBarPolicy(
            Qt.ScrollBarAlwaysOff)
        self.command_input.textChanged.connect(self.adjust_input_height)
        self.command_input.executeCommand.connect(self.send_command_to_ssh)
        self.command_input.clear_history_.connect(self._clear_history)
        self.command_input.setStyleSheet("""
            CommandInput#command_input {
                background-color: transparent;
                border: none;
                color: %s;
                font-size: 14px;
                padding-left: 5px;
            }
        """ % config["ssh_widget_text_color"])
        self.command_input.add_history(
            session_manager.get_session_by_name(self.parentkey).history)
        self.command_icon.clicked.connect(self.ssh_widget.clear_screen)
        self.history.clicked.connect(self.command_input.toggle_history)
        command_bar_layout.addWidget(self.command_icon)
        command_bar_layout.addWidget(self.bash_wrap_button)
        command_bar_layout.addWidget(self.history)
        command_bar_layout.addWidget(self.command_input)

        top_container_layout.addWidget(self.ssh_widget)
        top_container_layout.addWidget(self.command_bar)
        self.adjust_input_height()

        # file_manage
        self.file_manage = QWidget(self.rsplitter)
        self.file_manage.setObjectName("file_manage")
        self.file_manage.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Expanding
        )

        file_manage_layout = QVBoxLayout(self.file_manage)
        file_manage_layout.setContentsMargins(0, 0, 0, 0)
        file_manage_layout.setSpacing(0)

        # file_bar
        self.file_bar = File_Navigation_Bar(self.file_manage)
        self.file_bar.bar_path_changed.connect(self._set_file_bar)
        self.file_bar.setObjectName("file_bar")
        self.file_bar.setFixedHeight(45)
        self.file_bar.setStyleSheet("""
            QFrame#file_bar {
                background-color: rgba(240, 240, 240, 0.8);
                border-bottom: 1px solid rgba(0,0,0,0.1);
                border-radius: 6px 6px 0 0;
            }
        """)
        self.file_splitter = QSplitter(Qt.Horizontal, self.file_manage)
        # disk_storage
        self.disk_storage = FileTreeWidget(self.file_splitter)
        self.disk_storage.directory_selected.connect(self._set_file_bar)
        self.disk_storage.setObjectName("disk_storage")
        self.disk_storage.setMinimumHeight(80)
        self.disk_storage.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Preferred)
        # self.disk_storage.directory_selected.connect(self._set_file_bar)
        self.disk_storage.setStyleSheet("""
            QFrame#disk_storage {
                background-color: rgba(220, 220, 220, 0.06);
                border: 1px solid rgba(0,0,0,0.06);
                border-radius: 6px;
            }
        """)

        # file_explorer
        self.file_explorer = FileExplorer(
            self.file_splitter)
        self.file_splitter.setSizes([200, 800])

        def connect_file_explorer():
            # self.file_explorer.upload_file.connect(
            #     lambda source_path, _: self.show_file_action("upload", source_path))
            default_view = config.get("default_view", "icon")
            self.file_explorer.switch_view(default_view)
            self.file_explorer.selected.connect(self._process_selected_path)
            self.file_explorer.refresh_action.connect(
                self._update_file_explorer)
            self.file_bar.refresh_clicked.connect(self._update_file_explorer)
            self.file_bar.new_folder_clicked.connect(
                self.file_explorer._handle_mkdir)
            self.file_bar.view_switch_clicked.connect(self._switch_view_mode)
            self.file_bar.internal_editor_toggled.connect(
                self._on_internal_editor_toggled)

            self.file_bar.upload_mode_toggled.connect(
                self._on_upload_mode_toggled)
            self.file_explorer.upload_mode_switch.toggled.connect(
                self.file_bar.update_upload_mode_button)
            # init button state
            is_compress_upload = CONFIGER.read_config()["compress_upload"]
            self.file_bar.update_upload_mode_button(is_compress_upload)
            self.file_explorer.upload_mode_switch.setChecked(
                is_compress_upload)

            self.file_bar.update_view_switch_button(
                self.file_explorer.view_mode)
            self.file_bar.pivot.currentItemChanged.connect(
                self._change_file_or_net)

        connect_file_explorer()
        self.task_detaile = ProcessMonitor()
        self.net_monitor = NetProcessMonitor()
        file_manage_layout.addWidget(self.file_bar)
        self.net_monitor.hide()
        file_manage_layout.addWidget(self.net_monitor)
        self.task_detaile.hide()
        file_manage_layout.addWidget(self.task_detaile)

        self.now_ui = "file_explorer"
        file_manage_layout.addWidget(self.file_splitter, 1)

        rightLayout.addWidget(self.rsplitter)

        # Left Right splitter
        self.splitter_lr = QSplitter(Qt.Horizontal, self)
        self.splitter_lr.setObjectName("splitter_lr_ratio")
        self.splitter_lr.addWidget(leftContainer)
        self.splitter_lr.addWidget(rightContainer)
        self.mainLayout.addWidget(self.splitter_lr)

        self.rsplitter.setStretchFactor(0, 3)   # top_container
        self.rsplitter.setStretchFactor(1, 2)   # file_manage

        self.splitter_lr.setStretchFactor(0, 25)  # 左侧面板
        self.splitter_lr.setStretchFactor(1, 75)  # 右侧主区
        self.splitter_lr.splitterMoved.connect(self.on_splitter_moved)
        # ---- Debounce terminal resize on splitter move ----
        self.resize_timer = QTimer(self)
        self.resize_timer.setSingleShot(True)
        self.resize_timer.setInterval(50)  # 150ms delay
        self.resize_timer.timeout.connect(self.ssh_widget.fit_terminal)
        self.rsplitter.splitterMoved.connect(self.on_splitter_moved)
        self.rsplitter.splitterMoved.connect(self.resize_timer.start)

        QTimer.singleShot(50, self.force_set_left_panel_width)

        splitter_tb_ratio = config.get("splitter_tb_ratio", [0.7, 0.3])
        if len(splitter_tb_ratio) == 2:
            QTimer.singleShot(100, lambda: self._restore_splitter_sizes(self.rsplitter, splitter_tb_ratio))

        if use_ai:
            self.handle_concent()

        # Apply theme color to splitter on initialization
        theme_color_info = config.get("bg_theme_color")
        if theme_color_info:
            initial_color = theme_color_info
        else:
            initial_color = '#cccccc'
        self.update_splitter_color(initial_color)

    def update_splitter_color(self, color_hex: str):
        """Updates the color of all splitter handles."""
        try:
            # Create a slightly darker color for hover effect
            base_color = QColor(color_hex)
            hover_color = base_color.darker(120).name()

            vertical_stylesheet = f"""
                QSplitter::handle:vertical {{
                    background-color: {color_hex};
                    height: 1px;
                    margin: 0px;
                }}
                QSplitter::handle:vertical:hover {{
                    background-color: {hover_color};
                }}
            """
            
            horizontal_stylesheet = f"""
                QSplitter::handle:horizontal {{
                    background-color: {color_hex};
                    width: 1px;
                    margin: 0px;
                }}
                QSplitter::handle:horizontal:hover {{
                    background-color: {hover_color};
                }}
            """
            self.leftSplitter.setStyleSheet(vertical_stylesheet)
            self.rsplitter.setStyleSheet(vertical_stylesheet)
            self.file_splitter.setStyleSheet(horizontal_stylesheet)
        except Exception as e:
            print(f"Failed to update splitter color: {e}")
            # Fallback to default if color is invalid
            default_v_style = '''
                QSplitter::handle:vertical { background-color: #cccccc; height: 1px; margin: 0px; }
                QSplitter::handle:vertical:hover { background-color: #999999; }
            '''
            default_h_style = '''
                QSplitter::handle:horizontal { background-color: #cccccc; width: 1px; margin: 0px; }
                QSplitter::handle:horizontal:hover { background-color: #999999; }
            '''
            self.leftSplitter.setStyleSheet(default_v_style)
            self.rsplitter.setStyleSheet(default_v_style)
            self.file_splitter.setStyleSheet(default_h_style)

    def _on_transfer_expansion_changed(self, expanded, left_layout, left_splitter):
        if expanded:
            left_layout.setStretch(0, 2)
            left_layout.setStretch(1, 1) 
        else:
            left_layout.setStretch(0, 1) 
            left_layout.setStretch(1, 0)

    def on_splitter_moved(self, pos, index):
        splitter = self.sender()
        obj_name = splitter.objectName()
        sizes = splitter.sizes()

        # For the left-right splitter, save fixed width of the left panel
        if obj_name == "splitter_lr_ratio":
            if sizes and len(sizes) > 1 and sizes[0] > 10:  # Ensure width is valid
                CONFIGER.revise_config("splitter_lr_left_width", sizes[0])
        # For other splitters, save ratios as before
        else:
            total = sum(sizes)
            if total > 0:
                ratios = [s/total for s in sizes]
                # print(f"移动: {obj_name}, 比例: {ratios}")
                CONFIGER.revise_config(f"{obj_name}", ratios)

    def _change_file_or_net(self, router):
        self.net_monitor.hide()
        self.task_detaile.hide()
        self.file_splitter.hide()
        if router == "file_explorer" and self.now_ui != "file_explorer":
            # self.net_monitor.hide()
            # self.task_detaile.hide()
            self.file_splitter.show()
            self.now_ui = "file_explorer"
        elif router == "net" and self.now_ui != "net":
            # self.file_explorer.hide()
            # self.task_detaile.hide()
            self.net_monitor.show()
            self.now_ui = "net"
        elif router == "task" and self.now_ui != "task":
            # self.file_explorer.hide()
            # self.net_monitor.hide()
            self.task_detaile.show()
            self.now_ui = "task"

    def _clear_history(self):
        session_manager.clear_history(self.parentkey)

    def _on_upload_mode_toggled(self, checked):
        CONFIGER.revise_config("compress_upload", checked)
        self.file_explorer.upload_mode_switch.setChecked(checked)

    def adjust_input_height(self):
        doc = self.command_input.document()
        # Get the required height from the document's layout
        content_height = int(doc.size().height())

        # The document margin is the internal padding of the TextEdit
        margin = int(self.command_input.document().documentMargin()) * 2

        # Calculate the total required height
        required_height = content_height + margin

        # Define min/max heights
        font_metrics = self.command_input.fontMetrics()
        line_height = font_metrics.lineSpacing()
        # Min height for at least one line
        min_height = line_height + margin
        # Max height for 5 lines
        max_height = (line_height * 5) + margin + \
            5  # A bit of extra padding for max

        # Clamp the final height
        final_height = min(max(required_height, min_height), max_height)

        # Update the heights of the input and its container
        self.command_input.setFixedHeight(final_height)
        self.command_bar.setFixedHeight(
            final_height + 10)  # 10 for container's padding

    def send_command_to_ssh(self, command):
        if self.ssh_widget and command:
            if self.bash_wrap_enabled:
                # Escape double quotes in the command
                escaped_command = command.replace('"', '\\"')
                final_command = f'bash -c "{escaped_command}"\n'
            else:
                final_command = command + '\n'
            self.ssh_widget.send_command(final_command)
            session_manager.add_command_to_session(
                self.parentkey, final_command)

    def _on_bash_wrap_toggled(self, checked):
        self.bash_wrap_enabled = checked
        if checked:
            self.bash_wrap_button.setIcon(self.icon_bash_enabled)
        else:
            self.bash_wrap_button.setIcon(self.icon_bash_disabled)

    def _create_bash_wrap_icon(self, enabled: bool) -> QIcon:
        """Draws a custom icon with a checkmark overlay if enabled."""
        # Use a fixed size for consistency
        size = QSize(20, 20)

        # Create base icon from FluentIcon
        base_icon = Action(FIF.COMMAND_PROMPT, '', self.command_bar).icon()
        pixmap = QPixmap(size)
        pixmap.fill(Qt.transparent)

        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)

        # Draw base icon centered
        base_pixmap = base_icon.pixmap(size)
        painter.drawPixmap(0, 0, base_pixmap)

        if enabled:
            # Draw checkmark in the bottom-right corner
            pen = QPen(QColor("#00E676"), 2.5)  # A vibrant green, thicker
            pen.setCapStyle(Qt.RoundCap)
            pen.setJoinStyle(Qt.RoundJoin)
            painter.setPen(pen)

            w, h = size.width(), size.height()
            path = QPainterPath()
            path.moveTo(w * 0.50, h * 0.65)
            path.lineTo(w * 0.70, h * 0.85)
            path.lineTo(w * 1.0, h * 0.55)
            painter.drawPath(path)

        painter.end()
        return QIcon(pixmap)

    def _switch_view_mode(self):
        if self.file_explorer.view_mode == "icon":
            new_mode = "details"
        else:
            new_mode = "icon"
        self.file_explorer.switch_view(new_mode)
        self.file_bar.update_view_switch_button(new_mode)

    def _on_internal_editor_toggled(self, checked: bool):
        # This is where the logic to enable/disable the internal editor will go.
        # For now, we can just print a message.
        print(f"Internal editor mode toggled: {'On' if checked else 'Off'}")

    def _process_selected_path(self, path_dict: dict):
        # print(f"选中了: {path_dict}")
        name = next(iter(path_dict.keys()))
        is_dir = next(iter(path_dict.values()))
        if name == '..':
            #
            current_path = self.file_explorer.path
            if current_path and current_path != '/':
                new_path = '/'.join(current_path.split('/')[:-1])
                if not new_path:
                    new_path = '/'
                self._set_file_bar(new_path)
            return

        new_path = self.file_explorer.path + "/" + name
        if is_dir:
            self._set_file_bar(new_path)
        else:
            if self.file_manager:
                print(f"get file type for: {new_path}")
                self.file_manager.get_file_type(new_path)

    def _update_file_explorer(self, path: str = None):
        if path:
            self.file_explorer.path = path
        else:
            path = self.file_explorer.path  # Refresh the original directory

        if not self.file_manager:
            parent = self.parent()
            while parent:
                if hasattr(parent, 'file_tree_object'):
                    # Pass the correct parameter: route_key, not parent
                    self.file_manager = parent.file_tree_object[self.router]
                    break
                parent = parent.parent()
            self.file_manager.list_dir_finished.connect(
                self._on_list_dir_finished, type=Qt.QueuedConnection)
        if self.file_manager:
            # print(f"添加：{path} 到任务")
            self.file_manager.list_dir_async(path)

    def _on_list_dir_finished(self, path: str, file_dict: dict):
        # if path != self.file_explorer.path:
        #     return

        try:
            self.file_explorer.add_files(file_dict)
        # self.file_manager._add_path_to_tree(path, False)
        # file_tree = self.file_manager.get_file_tree()
        # self.disk_storage.refresh_tree(file_tree)
        except Exception as e:
            print(f"_on_list_dir_finished error: {e}")

    def _set_file_bar(self, path: str):
        def parse_linux_path(path: str) -> list:
            if not path:
                return []
            path_list = []
            if path.startswith('/'):
                path_list.append('/')
            parts = [p for p in path.strip('/').split('/') if p]
            path_list.extend(parts)
            return path_list

        path_list = parse_linux_path(path)

        # BLOCK signals while rebuilding breadcrumb to avoid multiple refreshes
        try:
            self.file_bar.breadcrumbBar.blockSignals(True)
        except Exception:
            pass

        self.file_bar.set_path(path)
        self.file_bar.breadcrumbBar.clear()
        for p in path_list:
            self.file_bar.breadcrumbBar.addItem(p, p)

        try:
            self.file_bar.breadcrumbBar.blockSignals(False)
        except Exception:
            pass

        self.file_bar._hide_path_edit()

        # ensure explorer.path updated and only refresh once
        self.file_explorer.path = path
        # explicitly request one refresh
        self._update_file_explorer(path)

    def on_main_window_resized(self):
        # A simple way to trigger the debounced resize
        self.resize_timer.start()

    def _sys_info_dialog(self):
        print("Show system info dialog")
        # print(self.sys_info_msg)
        if self.sys_info_msg:
            w = Dialog(self.tr("System Info"), self.sys_info_msg, self)
            w.cancelButton.setText(self.tr("Copy all"))
            w.yesButton.setText(self.tr("Got it"))
            if w.exec():
                return
            else:
                clipboard = QApplication.clipboard()
                clipboard.setText(self.sys_info_msg)

    def cleanup(self):
        self.ssh_widget.cleanup()
        try:
            self.ssh_widget.directoryChanged.disconnect()
            self.disk_storage.directory_selected.disconnect()
        except Exception:
            pass
        try:
            self.command_input.textChanged.disconnect()
            self.command_input.executeCommand.disconnect()
        except Exception:
            pass

        for container in [getattr(self, 'ssh_widget', None),
                          getattr(self, 'command_bar', None),
                          getattr(self, 'sys_resources', None),
                          getattr(self, 'task', None),
                          getattr(self, 'disk_storage', None),
                          getattr(self, 'transfer_progress', None),
                          getattr(self, 'file_manage', None),
                          getattr(self, 'file_bar', None),
                          getattr(self, 'file_explorer', None)]:
            if container:
                container.setParent(None)
                container.deleteLater()

        if hasattr(self, 'mainLayout'):
            while self.mainLayout.count():
                item = self.mainLayout.takeAt(0)
                widget = item.widget()
                if widget:
                    widget.setParent(None)
                    widget.deleteLater()

        parent_layout = self.parentWidget().layout() if self.parentWidget() else None
        if parent_layout:
            parent_layout.removeWidget(self)
        self.setParent(None)
        self.deleteLater()

    def _restore_splitter_sizes(self, splitter, ratios):
        if splitter.orientation() == Qt.Horizontal:
            total_size = splitter.width()
        else:
            total_size = splitter.height()
        
        if total_size > 0:
            sizes = [int(r * total_size) for r in ratios]
            splitter.setSizes(sizes)

    def force_set_left_panel_width(self):
        """
        Reads the absolute width for the left panel from config and applies it.
        This ensures the left panel width is maintained during parent resizes.
        """
        config = CONFIGER.read_config()
        # Use a reasonable default width if not set
        left_width = config.get("splitter_lr_left_width", 280)

        total_width = self.splitter_lr.width()

        # Only apply if the total width is larger than the desired fixed width
        if total_width > left_width:
            right_width = total_width - left_width
            # Temporarily block signals to avoid a feedback loop with on_splitter_moved
            self.splitter_lr.blockSignals(True)
            self.splitter_lr.setSizes([left_width, right_width])
            self.splitter_lr.blockSignals(False)

    def handle_concent(self):
        self.llm = LLMHelper()
        self.llm.result_signal.connect(self.command_input._on_partial_result)
        self.llm.error_signal.connect(self.command_input.suggestion_error)
        self.llm.finished_signal.connect(self.command_input.clear_out)

    def execute_command_and_capture(self, command: str):
        if self.ssh_widget:
            self.ssh_widget.execute_command_and_capture(command)
</file>

<file path="widgets/editor_widget.py">
import os
import sys
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QMessageBox, QFileDialog,
                             QHBoxLayout, QLabel, QStatusBar, QScrollBar, QSizePolicy)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QFont, QColor, QFocusEvent, QTextCursor
from tools.setting_config import SCM
from qfluentwidgets import BodyLabel, LineEdit, ScrollBar, FluentIcon, TransparentToolButton

from PyQt5.QtGui import QSyntaxHighlighter, QTextCharFormat, QTextDocument
from PyQt5.QtWidgets import QPlainTextEdit
import re

try:
    from PyQt5.Qsci import QsciScintilla, QsciLexerPython, QsciLexerCPP, QsciLexerJava, \
        QsciLexerJavaScript, QsciLexerHTML, QsciLexerCSS, QsciLexerXML, QsciLexerSQL, \
        QsciLexerBash, QsciLexerBatch, QsciLexerJSON, QsciLexerYAML, QsciLexerMarkdown, \
        QsciLexerCSharp, QsciLexerRuby, QsciLexerPerl, QsciLexerLua, QsciLexerPascal, \
        QsciLexerFortran, QsciLexerMakefile, QsciLexerCMake, QsciLexerDiff
    QSCINTILLA_AVAILABLE = True
except ImportError:
    QSCINTILLA_AVAILABLE = False

from qfluentwidgets import isDarkTheme


class PythonHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlighting_rules = []
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(86, 156, 214))
        keyword_format.setFontWeight(QFont.Bold)
        keywords = [
            'and', 'as', 'assert', 'break', 'class', 'continue', 'def',
            'del', 'elif', 'else', 'except', 'False', 'finally', 'for',
            'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'None',
            'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'True',
            'try', 'while', 'with', 'yield'
        ]
        for word in keywords:
            pattern = r'\b' + word + r'\b'
            self.highlighting_rules.append(
                (re.compile(pattern), keyword_format))
        string_format = QTextCharFormat()
        string_format.setForeground(QColor(214, 157, 133))
        self.highlighting_rules.append(
            (re.compile(r'"[^"\\]*(\\.[^"\\]*)*"'), string_format))
        self.highlighting_rules.append(
            (re.compile(r"'[^'\\]*(\\.[^'\\]*)*'"), string_format))
        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(106, 153, 85))
        self.highlighting_rules.append(
            (re.compile(r'#[^\n]*'), comment_format))
        number_format = QTextCharFormat()
        number_format.setForeground(QColor(181, 206, 168))
        self.highlighting_rules.append(
            (re.compile(r'\b[0-9]+\b'), number_format))
        function_format = QTextCharFormat()
        function_format.setForeground(QColor(220, 220, 170))
        self.highlighting_rules.append(
            (re.compile(r'\b[A-Za-z0-9_]+(?=\()'), function_format))

    def highlightBlock(self, text):
        for pattern, format in self.highlighting_rules:
            for match in pattern.finditer(text):
                self.setFormat(match.start(), match.end() -
                               match.start(), format)


class EditorWidget(QWidget):
    file_modified = pyqtSignal(bool)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setStyleSheet("""
    QWidget {
        background: transparent;
        border: none;
    }
""")
        self.tab_id = None
        self._side_panel = None
        self.file_path = None
        self.original_content = ""
        self.is_modified = False
        self.scm = SCM()
        self.last_search_text = ""
        self.search_bar_visible = False
        self.layout_ = QVBoxLayout(self)
        self.layout_.setContentsMargins(0, 0, 0, 0)
        self.layout_.setSpacing(0)
        self.setLayout(self.layout_)
        self._setup_search_bar()
        if QSCINTILLA_AVAILABLE:
            self.editor = QsciScintilla()
            self._setup_qscintilla()
        else:
            self.editor = QPlainTextEdit()
            self._setup_plain_text_edit()

        self.editor.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.editor.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        v_scroll = ScrollBar(Qt.Vertical, self.editor)
        # h_scroll = ScrollBar(Qt.Horizontal, self.editor)

        self.layout_.addWidget(self.editor)
        self._setup_status_bar()
        self._setup_shortcuts()
        self._apply_theme()

    def _setup_shortcuts(self):
        from PyQt5.QtWidgets import QShortcut
        from PyQt5.QtGui import QKeySequence
        save_shortcut = QShortcut(QKeySequence("Ctrl+S"), self.editor)
        save_shortcut.activated.connect(self.save_file)
        reload_shortcut = QShortcut(QKeySequence("F5"), self.editor)
        reload_shortcut.activated.connect(self.reload_file)
        find_shortcut = QShortcut(QKeySequence("Ctrl+F"), self.editor)
        find_shortcut.activated.connect(self.toggle_search_bar)
        replace_shortcut = QShortcut(QKeySequence("Ctrl+H"), self.editor)
        replace_shortcut.activated.connect(
            lambda: self.toggle_search_bar(show_replace=True))
        esc_shortcut = QShortcut(QKeySequence("Escape"), self)
        esc_shortcut.activated.connect(self.hide_search_bar)
        find_next_shortcut = QShortcut(QKeySequence("F3"), self.editor)
        find_next_shortcut.activated.connect(self.find_next)
        find_prev_shortcut = QShortcut(QKeySequence("Shift+F3"), self.editor)
        find_prev_shortcut.activated.connect(self.find_previous)
        undo_shortcut = QShortcut(QKeySequence("Ctrl+Z"), self.editor)
        undo_shortcut.activated.connect(self.undo)
        redo_shortcut = QShortcut(QKeySequence("Ctrl+Y"), self.editor)
        redo_shortcut.activated.connect(self.redo)
        select_all_shortcut = QShortcut(QKeySequence("Ctrl+A"), self.editor)
        select_all_shortcut.activated.connect(self.select_all)
        copy_shortcut = QShortcut(QKeySequence("Ctrl+C"), self.editor)
        copy_shortcut.activated.connect(self.copy)
        cut_shortcut = QShortcut(QKeySequence("Ctrl+X"), self.editor)
        cut_shortcut.activated.connect(self.cut)
        paste_shortcut = QShortcut(QKeySequence("Ctrl+V"), self.editor)
        paste_shortcut.activated.connect(self.paste)

    def _setup_qscintilla(self):
        font = QFont('Consolas' if sys.platform ==
                     'win32' else 'Monaco' if sys.platform == 'darwin' else 'Monospace')
        font.setPointSize(10)
        self.editor.setFont(font)
        self.editor.setMarginType(0, QsciScintilla.NumberMargin)
        self.editor.setMarginWidth(0, "0000")
        self.editor.setMarginLineNumbers(0, True)
        self.editor.linesChanged.connect(self._update_line_number_width)
        self.editor.setBraceMatching(QsciScintilla.SloppyBraceMatch)
        self.editor.setCaretLineVisible(True)
        self.editor.setCaretLineBackgroundColor(QColor("#3c3c3c"))
        self.editor.setIndentationsUseTabs(False)
        self.editor.setIndentationWidth(4)
        self.editor.setAutoIndent(True)
        self.editor.setSelectionBackgroundColor(QColor("#264f78"))
        self.editor.setSelectionForegroundColor(QColor("#ffffff"))
        self.editor.setWrapMode(QsciScintilla.WrapWord)
        self.editor.setWrapVisualFlags(QsciScintilla.WrapFlagByText)
        self.editor.setWrapIndentMode(QsciScintilla.WrapIndentIndented)
        self.editor.setAutoCompletionSource(QsciScintilla.AcsAll)
        self.editor.setAutoCompletionThreshold(2)
        self.editor.setAutoCompletionCaseSensitivity(False)
        self.editor.textChanged.connect(self._on_text_changed)
        self.editor.modificationChanged.connect(self._on_modification_changed)
        self.editor.cursorPositionChanged.connect(self._update_cursor_position)
        self.editor.selectionChanged.connect(self._update_cursor_position)
        self._setup_focus_handler()

    def _update_line_number_width(self):
        if not QSCINTILLA_AVAILABLE:
            return
        lines = self.editor.lines()
        if lines == 0:
            lines = 1
        width = self.editor.fontMetrics().width(str(lines)) + 15
        self.editor.setMarginWidth(0, width)

    def _setup_plain_text_edit(self):
        font = QFont('Consolas' if sys.platform ==
                     'win32' else 'Monaco' if sys.platform == 'darwin' else 'Monospace')
        font.setPointSize(10)
        self.editor.setFont(font)
        self.editor.setTabStopWidth(40)
        self.editor.textChanged.connect(self._on_text_changed)
        self.editor.cursorPositionChanged.connect(self._update_cursor_position)
        self.editor.setLineWrapMode(QPlainTextEdit.WidgetWidth)
        self._setup_focus_handler()

    def _apply_theme(self):
        if QSCINTILLA_AVAILABLE:
            if isDarkTheme():
                self.editor.setCaretForegroundColor(QColor("#ffffff"))
                self.editor.setMarginsBackgroundColor(QColor("#1e1e1e"))
                self.editor.setMarginsForegroundColor(QColor("#858585"))
                self.editor.setFoldMarginColors(
                    QColor("#1e1e1e"), QColor("#1e1e1e"))
                self.editor.setPaper(QColor("#1e1e1e"))
                if hasattr(self.editor, 'lexer') and self.editor.lexer():
                    self._apply_dark_theme_to_lexer(self.editor.lexer())
            else:
                self.editor.setCaretForegroundColor(QColor("#000000"))
                self.editor.setMarginsBackgroundColor(QColor("#ffffff"))
                self.editor.setMarginsForegroundColor(QColor("#666666"))
                self.editor.setFoldMarginColors(
                    QColor("#f0f0f0"), QColor("#f0f0f0"))
                self.editor.setPaper(QColor("#ffffff"))
                if hasattr(self.editor, 'lexer') and self.editor.lexer():
                    self._apply_light_theme_to_lexer(self.editor.lexer())
        else:
            if isDarkTheme():
                self.editor.setStyleSheet("""
                    QPlainTextEdit {
                        background-color: #1e1e1e;
                        color: #d4d4d4;
                        border: none;
                        selection-background-color: #264f78;
                        selection-color: #ffffff;
                    }
                """)
            else:
                self.editor.setStyleSheet("""
                    QPlainTextEdit {
                        background-color: #ffffff;
                        color: #000000;
                        border: none;
                        selection-background-color: #3399ff;
                        selection-color: #ffffff;
                    }
                """)

    def _apply_dark_theme_to_lexer(self, lexer):
        lexer.setDefaultPaper(QColor("#1e1e1e"))
        lexer.setDefaultColor(QColor("#d4d4d4"))
        lexer.setColor(QColor("#608b4e"), lexer.Comment)
        lexer.setColor(QColor("#ce9178"), lexer.DoubleQuotedString)
        lexer.setColor(QColor("#ce9178"), lexer.SingleQuotedString)
        lexer.setColor(QColor("#569cd6"), lexer.Keyword)
        lexer.setColor(QColor("#b5cea8"), lexer.Number)
        if hasattr(lexer, 'ClassName'):
            lexer.setColor(QColor("#dcdcaa"), lexer.ClassName)
        if hasattr(lexer, 'FunctionMethodName'):
            lexer.setColor(QColor("#dcdcaa"), lexer.FunctionMethodName)
        lexer.setColor(QColor("#9cdcfe"), lexer.Identifier)
        lexer.setColor(QColor("#c586c0"), lexer.Operator)

    def _apply_light_theme_to_lexer(self, lexer):
        lexer.setDefaultPaper(QColor("#ffffff"))
        lexer.setDefaultColor(QColor("#000000"))
        lexer.setColor(QColor("#008000"), lexer.Comment)
        lexer.setColor(QColor("#a31515"), lexer.DoubleQuotedString)
        lexer.setColor(QColor("#a31515"), lexer.SingleQuotedString)
        lexer.setColor(QColor("#0000ff"), lexer.Keyword)
        lexer.setColor(QColor("#098658"), lexer.Number)
        if hasattr(lexer, 'ClassName'):
            lexer.setColor(QColor("#267f99"), lexer.ClassName)
        if hasattr(lexer, 'FunctionMethodName'):
            lexer.setColor(QColor("#795e26"), lexer.FunctionMethodName)
        lexer.setColor(QColor("#001080"), lexer.Identifier)
        lexer.setColor(QColor("#000000"), lexer.Operator)

    def set_tab_id(self, tab_id):
        self.tab_id = tab_id
        print(f"Editor initialized with tab ID: {self.tab_id}")
        QTimer.singleShot(100, self.load_file_from_tab_data)

    def _find_side_panel(self):
        if self._side_panel:
            return self._side_panel
        parent = self.parent()
        while parent is not None:
            if parent.metaObject().className() == "SidePanelWidget":
                print("Found and cached SidePanelWidget.")
                self._side_panel = parent
                return self._side_panel
            parent = parent.parent()
        return None

    def get_tab_data(self):
        side_panel = self._find_side_panel()
        if side_panel:
            tab_data = side_panel.get_tab_data_by_uuid(self.tab_id)
            print(f"Retrieved tab data: {tab_data}")
            return tab_data
        return None

    def load_file_from_tab_data(self):
        tab_data = self.get_tab_data()
        if tab_data and isinstance(tab_data, dict):
            file_path = tab_data.get('file_path') or tab_data.get(
                'path') or tab_data.get('filepath')
            if file_path:
                self.load_file(file_path)
            else:
                print(f"No file path found in tab data: {tab_data}")

    def load_file(self, file_path):
        try:
            self.file_path = file_path
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            self.original_content = content
            self.editor.setText(content)
            self.is_modified = False
            self._set_syntax_highlighter(file_path)
            self._update_file_type(file_path)
            self._update_cursor_position()
            self._update_tab_title()
        except Exception as e:
            print(f"Failed to load file: {str(e)}")

    def reload_file(self):
        if self.file_path:
            if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
                vertical_pos = self.editor.firstVisibleLine()
                horizontal_pos = self.editor.horizontalScrollBar().value()
            else:
                vertical_pos = self.editor.verticalScrollBar().value()
                horizontal_pos = self.editor.horizontalScrollBar().value()
            self.load_file(self.file_path)
            if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
                self.editor.setFirstVisibleLine(vertical_pos)
                self.editor.horizontalScrollBar().setValue(horizontal_pos)
            else:
                self.editor.verticalScrollBar().setValue(vertical_pos)
                self.editor.horizontalScrollBar().setValue(horizontal_pos)

    def _set_syntax_highlighter(self, file_path):
        if not QSCINTILLA_AVAILABLE:
            if file_path.endswith('.py'):
                self.highlighter = PythonHighlighter(self.editor.document())
            return
        ext = os.path.splitext(file_path)[1].lower()
        lexer_map = {
            '.py': QsciLexerPython,
            '.pyw': QsciLexerPython,
            '.c': QsciLexerCPP,
            '.cpp': QsciLexerCPP,
            '.cc': QsciLexerCPP,
            '.cxx': QsciLexerCPP,
            '.h': QsciLexerCPP,
            '.hpp': QsciLexerCPP,
            '.java': QsciLexerJava,
            '.js': QsciLexerJavaScript,
            '.jsx': QsciLexerJavaScript,
            '.ts': QsciLexerJavaScript,
            '.tsx': QsciLexerJavaScript,
            '.html': QsciLexerHTML,
            '.htm': QsciLexerHTML,
            '.css': QsciLexerCSS,
            '.xml': QsciLexerXML,
            '.sql': QsciLexerSQL,
            '.sh': QsciLexerBash,
            '.bash': QsciLexerBash,
            '.bat': QsciLexerBatch,
            '.cmd': QsciLexerBatch,
            '.json': QsciLexerJSON,
            '.yaml': QsciLexerYAML,
            '.yml': QsciLexerYAML,
            '.md': QsciLexerMarkdown,
            '.markdown': QsciLexerMarkdown,
            '.cs': QsciLexerCSharp,
            '.rb': QsciLexerRuby,
            '.pl': QsciLexerPerl,
            '.lua': QsciLexerLua,
            '.pas': QsciLexerPascal,
            '.f': QsciLexerFortran,
            '.f90': QsciLexerFortran,
            '.makefile': QsciLexerMakefile,
            '.mk': QsciLexerMakefile,
            '.cmake': QsciLexerCMake,
            '.diff': QsciLexerDiff,
            '.patch': QsciLexerDiff,
        }
        lexer_class = lexer_map.get(ext)
        if lexer_class:
            lexer = lexer_class()
            font = QFont('Consolas' if sys.platform ==
                         'win32' else 'Monaco' if sys.platform == 'darwin' else 'Monospace')
            font.setPointSize(10)
            lexer.setDefaultFont(font)
            if isDarkTheme():
                self._apply_dark_theme_to_lexer(lexer)
            else:
                self._apply_light_theme_to_lexer(lexer)
            self.editor.setLexer(lexer)
            self._apply_theme()

    def save_file(self):
        if not self.file_path:
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save File",
                "",
                "All Files (*.*)"
            )
            if not file_path:
                return False
            self.file_path = file_path
        try:
            content = self.editor.text()
            with open(self.file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            self.original_content = content
            self.is_modified = False
            self.file_modified.emit(False)
            self._update_tab_title()
            print(f"File saved: {self.file_path}")
            return True
        except Exception as e:
            QMessageBox.critical(
                self, "Error", f"Failed to save file: {str(e)}")
            return False

    def _on_text_changed(self):
        if self.file_path:
            current_content = self.editor.text()
            self.is_modified = (current_content != self.original_content)
            self.file_modified.emit(self.is_modified)
            self._update_tab_title()

    def _on_modification_changed(self, modified):
        self.is_modified = modified
        self.file_modified.emit(modified)
        self._update_tab_title()

    def _update_tab_title(self):
        if self.file_path:
            side_panel = self._find_side_panel()
            if side_panel and self.tab_id in side_panel.tabs:
                file_name = os.path.basename(self.file_path)
                title = f"{'*' if self.is_modified else ''}{file_name}"
                side_panel.tabs[self.tab_id]['button'].setText(title)

    def closeEvent(self, event):
        if self.is_modified:
            reply = QMessageBox.question(
                self, 'Save Changes',
                'The file has been modified. Do you want to save changes?',
                QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel,
                QMessageBox.Save
            )
            if reply == QMessageBox.Save:
                if not self.save_file():
                    event.ignore()
                    return
            elif reply == QMessageBox.Cancel:
                event.ignore()
                return
        event.accept()

    def _setup_focus_handler(self):
        self._original_focus_out = self.editor.focusOutEvent

        def focus_out_handler(event):
            if self.scm.read_config().get("editor_auto_save_on_focus_lost", False):
                if self.is_modified and self.file_path:
                    self.save_file()
                    print(f"Auto-saved on focus out: {self.file_path}")
            self._original_focus_out(event)
        self.editor.focusOutEvent = focus_out_handler

    def _setup_search_bar(self):
        self.search_widget = QWidget()
        self.search_widget.setMaximumHeight(40)
        self.search_widget.setVisible(False)
        search_layout = QHBoxLayout(self.search_widget)
        search_layout.setContentsMargins(10, 5, 10, 5)
        search_layout.setSpacing(5)
        self.search_input = LineEdit()
        self.search_input.setPlaceholderText("查找...")
        self.search_input.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.search_input.returnPressed.connect(self.find_next)
        self.replace_input = LineEdit()
        self.replace_input.setPlaceholderText("替换为...")
        self.replace_input.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.replace_input.setVisible(False)
        self.find_prev_btn = TransparentToolButton(FluentIcon.UP)
        self.find_prev_btn.setToolTip("查找上一个 (Shift+F3)")
        self.find_prev_btn.setFixedSize(30, 30)
        self.find_prev_btn.clicked.connect(self.find_previous)
        self.find_next_btn = TransparentToolButton(FluentIcon.DOWN)
        self.find_next_btn.setToolTip("查找下一个 (F3)")
        self.find_next_btn.setFixedSize(30, 30)
        self.find_next_btn.clicked.connect(self.find_next)
        self.replace_btn = TransparentToolButton(FluentIcon.SYNC)
        self.replace_btn.setToolTip("替换")
        self.replace_btn.setFixedSize(30, 30)
        self.replace_btn.clicked.connect(self.replace_current)
        self.replace_btn.setVisible(False)
        self.replace_all_btn = TransparentToolButton(FluentIcon.ACCEPT)
        self.replace_all_btn.setToolTip("全部替换")
        self.replace_all_btn.setFixedSize(30, 30)
        self.replace_all_btn.clicked.connect(self.replace_all)
        self.replace_all_btn.setVisible(False)
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.replace_input)
        search_layout.addStretch()
        search_layout.addWidget(self.find_prev_btn)
        search_layout.addWidget(self.find_next_btn)
        search_layout.addWidget(self.replace_btn)
        search_layout.addWidget(self.replace_all_btn)
        self.layout_.addWidget(self.search_widget)

    def toggle_search_bar(self, show_replace=False):
        if not self.search_bar_visible:
            self.show_search_bar(show_replace)
        else:
            if show_replace and not self.replace_input.isVisible():
                self.show_replace_options(True)
            else:
                self.hide_search_bar()

    def show_search_bar(self, show_replace=False):
        self.search_widget.setVisible(True)
        self.search_bar_visible = True
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            if self.editor.hasSelectedText():
                self.search_input.setText(self.editor.selectedText())
        else:
            cursor = self.editor.textCursor()
            if cursor.hasSelection():
                self.search_input.setText(cursor.selectedText())
        self.show_replace_options(show_replace)
        self.search_input.setFocus()
        self.search_input.selectAll()

    def hide_search_bar(self):
        self.search_widget.setVisible(False)
        self.search_bar_visible = False
        self.editor.setFocus()

    def show_replace_options(self, show):
        self.replace_input.setVisible(show)
        self.replace_btn.setVisible(show)
        self.replace_all_btn.setVisible(show)

    def find_next(self):
        text = self.search_input.text()
        if text:
            self.last_search_text = text
            self._do_find(text, False)

    def find_previous(self):
        text = self.search_input.text()
        if text:
            self.last_search_text = text
            self._do_find(text, True)

    def replace_current(self):
        find_text = self.search_input.text()
        replace_text = self.replace_input.text()
        if find_text:
            self._do_replace_one(find_text, replace_text)

    def replace_all(self):
        find_text = self.search_input.text()
        replace_text = self.replace_input.text()
        if find_text:
            self._do_replace_all(find_text, replace_text)

    def _do_find(self, text, backward=False):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            if backward:
                line, index = self.editor.getCursorPosition()
                if self.editor.hasSelectedText():
                    line_from, index_from, line_to, index_to = self.editor.getSelection()
                    line, index = line_from, index_from
                found = self.editor.findFirst(text, False, False, False,
                                              False, False, line, index, False)
                if not found:
                    last_line = self.editor.lines() - 1
                    last_index = self.editor.lineLength(last_line)
                    found = self.editor.findFirst(text, False, False, False,
                                                  False, False, last_line, last_index, False)
            else:
                line, index = self.editor.getCursorPosition()
                if self.editor.hasSelectedText():
                    _, _, line_to, index_to = self.editor.getSelection()
                    line, index = line_to, index_to
                found = self.editor.findFirst(
                    text, False, False, False, True, True, line, index)
        else:
            cursor = self.editor.textCursor()
            options = QTextDocument.FindFlags()
            if backward:
                options |= QTextDocument.FindBackward
            cursor = self.editor.document().find(text, cursor, options)
            if cursor.isNull():
                if backward:
                    cursor = self.editor.textCursor()
                    cursor.movePosition(QTextCursor.End)
                else:
                    cursor = self.editor.textCursor()
                    cursor.movePosition(QTextCursor.Start)
                cursor = self.editor.document().find(text, cursor, options)
            if not cursor.isNull():
                self.editor.setTextCursor(cursor)

    def _do_replace_one(self, find_text, replace_text):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            if self.editor.hasSelectedText():
                selected = self.editor.selectedText()
                if selected == find_text:
                    self.editor.replaceSelectedText(replace_text)
                    self._do_find(find_text, False)
                else:
                    self._do_find(find_text, False)
            else:
                self._do_find(find_text, False)
        else:
            cursor = self.editor.textCursor()
            if cursor.hasSelection():
                selected = cursor.selectedText()
                if selected == find_text:
                    cursor.insertText(replace_text)
                    self._do_find(find_text, False)
                else:
                    self._do_find(find_text, False)
            else:
                self._do_find(find_text, False)

    def _do_replace_all(self, find_text, replace_text):
        count = 0
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            self.editor.setCursorPosition(0, 0)
            while self.editor.findFirst(find_text, False, False, False,
                                        False, True, -1, -1, False):
                self.editor.replaceSelectedText(replace_text)
                count += 1
        else:
            cursor = self.editor.textCursor()
            cursor.movePosition(QTextCursor.Start)
            cursor.beginEditBlock()
            while True:
                cursor = self.editor.document().find(find_text, cursor)
                if cursor.isNull():
                    break
                cursor.insertText(replace_text)
                count += 1
            cursor.endEditBlock()

    def undo(self):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            self.editor.undo()
        else:
            self.editor.undo()

    def redo(self):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            self.editor.redo()
        else:
            self.editor.redo()

    def select_all(self):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            self.editor.selectAll()
        else:
            self.editor.selectAll()

    def copy(self):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            self.editor.copy()
        else:
            self.editor.copy()

    def cut(self):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            self.editor.cut()
        else:
            self.editor.cut()

    def paste(self):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            self.editor.paste()
        else:
            self.editor.paste()

    def _setup_status_bar(self):
        status_layout = QHBoxLayout()
        status_layout.setContentsMargins(5, 2, 5, 2)
        self.encoding_label = BodyLabel("UTF-8")
        self.encoding_label.setStyleSheet("QLabel { color: #888; }")
        sep1 = BodyLabel("|")
        sep1.setStyleSheet("QLabel { color: #888; }")
        self.position_label = BodyLabel(self.tr("Row 1, Column 1"))
        self.position_label.setStyleSheet("QLabel { color: #888; }")
        sep2 = BodyLabel("|")
        sep2.setStyleSheet("QLabel { color: #888; }")
        self.file_type_label = BodyLabel(self.tr("Plain text"))
        self.file_type_label.setStyleSheet("QLabel { color: #888; }")
        status_layout.addWidget(self.encoding_label)
        status_layout.addWidget(sep1)
        status_layout.addWidget(self.position_label)
        status_layout.addWidget(sep2)
        status_layout.addWidget(self.file_type_label)
        status_layout.addStretch()
        sep3 = BodyLabel("|")
        sep3.setStyleSheet("QLabel { color: #888; }")
        self.selection_label = BodyLabel("")
        self.selection_label.setStyleSheet("QLabel { color: #888; }")
        status_layout.addWidget(sep3)
        status_layout.addWidget(self.selection_label)
        status_widget = QWidget()
        status_widget.setLayout(status_layout)
        status_widget.setMaximumHeight(25)
        status_widget.setStyleSheet("""
            QWidget {
                background-color: rgba(0, 0, 0, 0.05);
                border-top: 1px solid rgba(0, 0, 0, 0.1);
            }
        """)
        self.layout_.addWidget(status_widget)

    def _update_cursor_position(self):
        if QSCINTILLA_AVAILABLE and isinstance(self.editor, QsciScintilla):
            line, col = self.editor.getCursorPosition()
            self.position_label.setText(
                self.tr(f"row {line + 1}, column {col + 1}"))
            if self.editor.hasSelectedText():
                selected_text = self.editor.selectedText()
                lines = selected_text.count('\n') + 1
                chars = len(selected_text)
                self.selection_label.setText(
                    self.tr(f"{chars} characters selected"))
                if lines > 1:
                    self.selection_label.setText(
                        self.tr(f"{lines} lines, {chars} characters selected"))
            else:
                self.selection_label.setText("")
        else:
            cursor = self.editor.textCursor()
            line = cursor.blockNumber() + 1
            col = cursor.columnNumber() + 1
            self.position_label.setText(self.tr(f"row {line}, column {col}"))
            if cursor.hasSelection():
                selected_text = cursor.selectedText()
                chars = len(selected_text)
                self.selection_label.setText(
                    self.tr(f"{chars} characters selected"))
            else:
                self.selection_label.setText("")

    def _update_file_type(self, file_path):
        if not file_path:
            self.file_type_label.setText(self.tr("Plain text"))
            return
        ext = os.path.splitext(file_path)[1].lower()
        file_types = {
            '.py': 'Python',
            '.pyw': 'Python',
            '.js': 'JavaScript',
            '.jsx': 'JavaScript React',
            '.ts': 'TypeScript',
            '.tsx': 'TypeScript React',
            '.java': 'Java',
            '.c': 'C',
            '.cpp': 'C++',
            '.cc': 'C++',
            '.cxx': 'C++',
            '.h': 'C/C++ Header',
            '.hpp': 'C++ Header',
            '.cs': 'C#',
            '.html': 'HTML',
            '.htm': 'HTML',
            '.css': 'CSS',
            '.scss': 'SCSS',
            '.sass': 'Sass',
            '.less': 'Less',
            '.xml': 'XML',
            '.json': 'JSON',
            '.yaml': 'YAML',
            '.yml': 'YAML',
            '.md': 'Markdown',
            '.markdown': 'Markdown',
            '.sql': 'SQL',
            '.sh': 'Shell Script',
            '.bash': 'Bash Script',
            '.bat': 'Batch',
            '.cmd': 'Command',
            '.ps1': 'PowerShell',
            '.rb': 'Ruby',
            '.pl': 'Perl',
            '.lua': 'Lua',
            '.go': 'Go',
            '.rs': 'Rust',
            '.php': 'PHP',
            '.swift': 'Swift',
            '.kt': 'Kotlin',
            '.r': 'R',
            '.m': 'MATLAB/Objective-C',
            '.vb': 'Visual Basic',
            '.pas': 'Pascal',
            '.f': 'Fortran',
            '.f90': 'Fortran 90',
            '.asm': 'Assembly',
            '.s': 'Assembly',
            '.makefile': 'Makefile',
            '.mk': 'Makefile',
            '.cmake': 'CMake',
            '.dockerfile': 'Dockerfile',
            '.gitignore': 'Git Ignore',
            '.env': 'Environment',
            '.ini': 'INI',
            '.cfg': 'Configuration',
            '.conf': 'Configuration',
            '.toml': 'TOML',
            '.properties': 'Properties',
            '.diff': 'Diff',
            '.patch': 'Patch',
        }
        file_type = file_types.get(ext, '纯文本')
        self.file_type_label.setText(file_type)
</file>

<file path="widgets/side_panel.py">
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QStackedWidget, QLabel,
                             QPushButton, QScrollArea, QHBoxLayout)
from PyQt5.QtCore import Qt, QEvent, pyqtSignal
from qfluentwidgets import RoundMenu, CheckableMenu, Action, FluentIcon as FIF
from tools.atool import resource_path
from tools.setting_config import SCM
from widgets.ai_chat_widget import AiChatWidget
from widgets.editor_widget import EditorWidget
import uuid


class TabButton(QPushButton):
    def __init__(self, text, parent=None):
        super().__init__(text, parent)
        self.setCheckable(True)
        self.setMinimumHeight(30)
        self.setContextMenuPolicy(Qt.CustomContextMenu)

class CustomTabBar(QScrollArea):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setFrameShape(self.NoFrame)
        self.scroll_widget = QWidget()
        self.setWidget(self.scroll_widget)
        self.layout = QHBoxLayout(self.scroll_widget)
        self.layout.setContentsMargins(5, 0, 5, 0)
        self.layout.setSpacing(5)
        self.layout.setAlignment(Qt.AlignLeft)

    def wheelEvent(self, event):
        delta = event.angleDelta().y()
        self.horizontalScrollBar().setValue(
            self.horizontalScrollBar().value() - delta)
        event.accept()

class SidePanelWidget(QWidget):
    tabActivity = pyqtSignal()

    def __init__(self, parent=None, main_window=None):
        super().__init__(parent=parent)
        self.main_window = main_window
        self.setObjectName("SidePanelWidget")
        self.setMinimumWidth(150)
        self.tabs = {}
        self.tab_order = []
        self.scm = SCM()
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)
        self.tab_bar_container = QWidget()
        self.tab_bar_container.setObjectName("TabBarContainer")
        container_layout = QHBoxLayout(self.tab_bar_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)
        self.tab_bar = CustomTabBar(self)
        container_layout.addWidget(self.tab_bar)
        self.main_layout.addWidget(self.tab_bar_container)
        self.page_stack = QStackedWidget(self)
        self.main_layout.addWidget(self.page_stack)
        self.add_new_tab(AiChatWidget(main_window=self.main_window), "AI Chat", {})
        self._update_tab_bar_visibility()
        self.setStyleSheet(self._get_style_sheet())

    def add_new_tab(self, widget, title: str, extra_data: dict = None):
        tab_id = str(uuid.uuid4())
        widget.set_tab_id(tab_id)
        button = TabButton(title)
        button.clicked.connect(lambda _, tid=tab_id: self._on_tab_clicked(tid))
        button.customContextMenuRequested.connect(lambda pos, tid=tab_id: self._show_tab_context_menu(pos, tid))
        button.installEventFilter(self)
        self.tab_bar.layout.addWidget(button)
        self.page_stack.addWidget(widget)
        self.tabs[tab_id] = {
            "button": button,
            "page": widget,
            "data": extra_data
        }
        self.tab_order.append(tab_id)
        button.click()
        self._update_tab_bar_visibility()
        self.tabActivity.emit()
        return tab_id

    def _on_tab_clicked(self, clicked_tab_id: str):
        if clicked_tab_id not in self.tabs:
            return
        page_to_show = self.tabs[clicked_tab_id]['page']
        for tab_id, tab_info in self.tabs.items():
            is_checked = (tab_id == clicked_tab_id)
            tab_info['button'].setChecked(is_checked)
        self.page_stack.setCurrentWidget(page_to_show)
        self.tabActivity.emit()

    def eventFilter(self, obj, event):
        if event.type() == QEvent.MouseButtonDblClick and isinstance(obj, TabButton):
            self._close_tab(obj)
            return True
        return super().eventFilter(obj, event)

    def _close_tab(self, button_to_close: TabButton):
        tab_id_to_close = None
        for tab_id, tab_info in self.tabs.items():
            if tab_info['button'] == button_to_close:
                tab_id_to_close = tab_id
                break
        if not tab_id_to_close:
            return
        try:
            index = self.tab_order.index(tab_id_to_close)
        except ValueError:
            return
        if index == 0:
            return
        was_checked = button_to_close.isChecked()
        self.tab_order.pop(index)
        tab_info = self.tabs.pop(tab_id_to_close)
        page = tab_info['page']
        self.tab_bar.layout.removeWidget(button_to_close)
        button_to_close.deleteLater()
        self.page_stack.removeWidget(page)
        page.deleteLater()
        if was_checked and self.tab_order:
            new_index = max(0, index - 1)
            new_tab_id_to_select = self.tab_order[new_index]
            self.tabs[new_tab_id_to_select]['button'].click()
        self._update_tab_bar_visibility()

    def _update_tab_bar_visibility(self):
        is_visible = len(self.tabs) > 1
        self.tab_bar_container.setVisible(is_visible)

    def switch_to_tab(self, tab_id: str):
        if tab_id in self.tabs:
            self.tabs[tab_id]['button'].click()
            return True
        return False

    def get_tab_data_by_uuid(self, tab_id: str):
        if tab_id in self.tabs:
            return self.tabs[tab_id]['data']
        return None

    def set_tab_data_by_uuid(self, tab_id: str, data: dict):
        if tab_id in self.tabs:
            self.tabs[tab_id]['data'] = data

    def find_tab_by_remote_path(self, remote_path: str):
        """根据远程路径查找已打开的标签页"""
        for tab_id, tab_info in self.tabs.items():
            if tab_info.get('data', {}).get('remote_path') == remote_path:
                return tab_id
        return None

    def _show_tab_context_menu(self, pos, tab_id):
        if tab_id not in self.tabs:
            return
        widget = self.tabs[tab_id]['page']
        button = self.tabs[tab_id]['button']
        if isinstance(widget, EditorWidget):
            menu = CheckableMenu(parent=self)
            auto_save_action = Action(FIF.SAVE, self.tr("Auto-save on focus lost (Global)"))
            auto_save_action.setCheckable(True)
            auto_save_action.setChecked(self.scm.read_config().get("editor_auto_save_on_focus_lost", False))
            auto_save_action.triggered.connect(self._toggle_global_auto_save)
            menu.addAction(auto_save_action)
            menu.addSeparator()
            close_action = Action(FIF.CLOSE, self.tr("Close Tab"))
            close_action.triggered.connect(lambda: self._close_tab(button))
            menu.addAction(close_action)
        elif isinstance(widget, AiChatWidget):
            menu = RoundMenu(parent=self)
            close_action = Action(FIF.CLOSE, self.tr("Close Tab"))
            close_action.triggered.connect(lambda: self._close_tab(button))
            menu.addAction(close_action)
        else:
            return
        menu.exec_(button.mapToGlobal(pos))

    def _toggle_global_auto_save(self, enabled):
        self.scm.revise_config("editor_auto_save_on_focus_lost", enabled)

    def _get_style_sheet(self):
        return """
            #TabBarContainer {
                background-color: #2d2d2d;
                border-bottom: 1px solid #3c3c3c;
                max-height: 40px;
            }
            CustomTabBar, CustomTabBar QWidget {
                background-color: transparent;
                border: none;
            }
            QStackedWidget {
                border: none;
                background: #252526;
            }
            TabButton {
                background: #2d2d2d;
                color: #aaaaaa;
                border: none;
                padding: 6px 10px;
                margin-right: 2px;
            }
            TabButton:hover {
                background: #3c3c3c;
                color: #ffffff;
            }
            TabButton:checked {
                background-color: #252526;
                color: #ffffff;
            }
        """
</file>

<file path="main_window.py">
# coding:utf-8
import sys
import ctypes
import time
from PyQt5.QtCore import Qt, QTranslator, QTimer, QLocale, QUrl, QEvent, pyqtSignal
from PyQt5.QtGui import QPixmap, QPainter, QDesktopServices, QIcon
from PyQt5.QtWidgets import QApplication, QStackedWidget, QHBoxLayout, QWidget, QMessageBox, QSplitter
from widgets.editor_widget import EditorWidget
from qfluentwidgets import (NavigationInterface, NavigationItemPosition, InfoBar,
                            isDarkTheme, setTheme, Theme, InfoBarPosition, FluentIcon as FIF, FluentTranslator, NavigationAvatarWidget, Dialog)
from qframelesswindow import FramelessWindow, StandardTitleBar
from widgets.setting_page import SettingPage
from widgets.home_interface import MainInterface
from tools.font_config import font_config
from tools.session_manager import SessionManager
from tools.logger import setup_global_logging, main_logger
from tools.ssh import SSHWorker
from tools.remote_file_manage import RemoteFileManager, FileManagerHandler
from widgets.sync_widget import SycnWidget
import os
import shutil
import subprocess
from tools.atool import resource_path
from tools.setting_config import SCM
from widgets.ssh_widget import SSHPage, SSHWidget
from tools.icons import My_Icons
from functools import partial
from tools.watching_saved import FileWatchThread
from widgets.side_panel import SidePanelWidget
import magic
import traceback
font_ = font_config()
setting_ = SCM()
mime_types = [
    "text/plain",
    "text/html",
    "text/css",
    "text/javascript",
    "application/json",
    "application/xml",
    "application/x-empty"
]


def isDebugMode():
    """Check if the application is running under a debugger."""
    return sys.gettrace() is not None


class Window(FramelessWindow):
    windowResized = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent=parent)
        if isDebugMode():
            os.environ['QTWEBENGINE_REMOTE_DEBUGGING'] = '3354'
            print('Debug mode enabled: http://localhost:'+os.environ['QTWEBENGINE_REMOTE_DEBUGGING'])
        self.icons = My_Icons()
        self.active_transfers = {}
        self.watching_dogs = {}
        self.file_id_to_path = {}
        self._download_debounce_timer = QTimer(self)
        self._download_debounce_timer.setSingleShot(True)
        self._download_debounce_timer.setInterval(500)
        self._download_debounce_timer.timeout.connect(
            self._process_pending_downloads)
        self._pending_download_paths = {}

        self._resize_timer = QTimer(self)
        self._resize_timer.setSingleShot(True)
        self._resize_timer.timeout.connect(self.apply_locked_ratio)

        self.setMinimumSize(800, 600)
        self.setTitleBar(StandardTitleBar(self))
        self._bg_ratio = None
        self.setWindowTitle("AuraShell Beta")
        icon = QIcon(resource_path("resource/icons/icon.ico"))
        self.setWindowIcon(icon)
        QApplication.setWindowIcon(icon)
        self.titleBar.raise_()
        self.connect_status_dict = {}
        self.ssh_session = {}
        self.sessionmanager = SessionManager()
        self.session_widgets = {}
        self.file_tree_object = {}
        self._bg_opacity = 1.0
        # self.unprocessed_tasks = ["systemd","kthreadd","pool_workqueue_release","kworker/R-rcu_g"]
        self._bg_pixmap = None
        self.hBoxLayout = QHBoxLayout(self)
        self.navigationInterface = NavigationInterface(
            self, showMenuButton=True)
        self.stackWidget = QStackedWidget(self)
        self.sidePanel = SidePanelWidget(self, main_window=self)
        self.sidePanel.tabActivity.connect(self._ensure_side_panel_visible)

        # create sub interface
        self.MainInterface = MainInterface(self)
        self.MainInterface.sessionClicked.connect(self._on_session_selected)

        self.sycn_widget = SycnWidget(self)
        self.sycn_widget.sync_finished.connect(
            lambda status, msg: InfoBar.success(
                title=msg if status == "success" else self.tr("Error"),
                content="",
                orient=Qt.Vertical,
                isClosable=True,
                position=InfoBarPosition.TOP_RIGHT,
                duration=5000 if status == "success" else -1,
                parent=self
            ) if status == "success" else InfoBar.error(
                title=self.tr("Error"),
                content=msg,
                orient=Qt.Vertical,
                isClosable=True,
                position=InfoBarPosition.TOP_RIGHT,
                duration=-1,
                parent=self
            )
        )
        self.sycn_widget.hide()
        # self.sessions = Widget(
        #     self.tr('No conversation selected yet'), True, self)
        self.ssh_page = SSHPage()
        self.ssh_page.menuActionTriggered.connect(self._handle_action)

        self.navigationInterface.setStyleSheet("background: transparent;")
        self.navigationInterface.setCollapsible(True)
        self.stackWidget.setStyleSheet("background: transparent;")

        self.settingInterface = SettingPage(self,)
        self.settingInterface.themeChanged.connect(self._on_theme_changed)
        self.settingInterface.lock_ratio_card.checkedChanged.connect(
            self.apply_locked_ratio)
        self.settingInterface.opacityEdit.valueChanged.connect(
            self.set_background_opacity)
        self.settingInterface.themeColorChanged.connect(
            self.on_theme_color_changed)
        # Connect transparency setting signal
        # self.settingInterface.bgOpacityChanged.connect(
        #     self.set_background_opacity)
        self._on_theme_changed(
            self.settingInterface.cfg.background_color.value)

        self.initLayout()
        self.initNavigation()

        self.initWindow()

        if setting_.read_config()["maximized"]:
            self.showMaximized()

    def set_background_opacity(self, opacity: float):
        if not self._bg_pixmap:
            return

        # In the case of int, only setting is passed in
        if isinstance(opacity, int):
            opacity = opacity / 100

        self._bg_opacity = max(0.0, min(1.0, opacity))
        self.update()

    def _on_ssh_connected(self, success: bool, msg: str):
        if success:
            InfoBar.success(
                title=msg,
                content="",
                orient=Qt.Vertical,
                isClosable=True,
                position=InfoBarPosition.TOP_RIGHT,
                duration=2000,
                parent=self
            )

    def _on_ssh_error(self, msg: str):
        InfoBar.error(
            title=self.tr("Connection failed"),
            content=self.tr(f"Error:\n{msg}\nPlease close this session"),
            orient=Qt.Vertical,
            isClosable=True,
            position=InfoBarPosition.TOP_RIGHT,
            duration=-1,
            parent=self
        )

    def _set_usage(self, widget_key, usage):
        try:
            result = dict(usage)
            parent_key = widget_key.split("-", 1)[0].strip()
            # print(self.session_widgets)
            # print(parent_key)
            widget = self.session_widgets[widget_key]
            if widget:
                if result["type"] == "info":
                    connections = result["connections"]
                    cpu_percent = result["cpu_percent"]
                    mem_percent = result["mem_percent"]
                    net_usage = result["net_usage"]
                    top_processes = result["top_processes"]
                    all_processes = result["all_processes"]
                    disk_usage = result["disk_usage"]

                    # 先用第一个切出来的网卡测试 后面加切换网卡
                    if net_usage:
                        upload, download = net_usage[1]["tx_kbps"], net_usage[1]["rx_kbps"]
                        widget.task.netmonitor.update_speed(
                            upload, download)
                    widget.sys_resources.set_progress("cpu", cpu_percent)
                    widget.sys_resources.set_progress("ram", mem_percent)
                    for processes in top_processes:
                        processes_cpu_percent = processes["cpu"]
                        processes_name = processes["name"]
                        processes_mem = processes["mem"]
                        widget.task.add_row(
                            f"{processes_mem:.1f}",
                            f"{processes_cpu_percent:.1f}",
                            processes_name
                        )
                    if connections:
                        widget.net_monitor.updateProcessData(connections)
                        # print(processes_cpu_percent, processes_name, processes_mem)
                    if all_processes:
                        widget.task_detaile.updateProcessData(all_processes)
                    if disk_usage:
                        for disk in disk_usage:
                            device = disk.get("device", "")
                            mount = disk.get("mount", "")
                            # 唯一ID
                            disk_id = f"{device}:{mount}"

                            widget.disk_usage.update_disk_item(disk_id, {
                                "device": device,
                                "mount": mount,
                                "used_percent": disk.get("used_percent"),
                                "size_kb": disk.get("size_kb"),
                                "used_kb": disk.get("used_kb"),
                                "avail_kb": disk.get("avail_kb"),
                                "read_kbps": disk.get("read_kbps"),
                                "write_kbps": disk.get("write_kbps"),
                            })

                elif result["type"] == "sysinfo":
                    print("Got SysInfo:", result)
                    sys_info = f'''
                    System : {result["system"]} kernel {result["kernel"]}
                    Arch : {result["arch"]}
                    Host name : {result["hostname"]}
                    CPU : {result["cpu_model"]} with {result["cpu_cores"]} cores
                    Freq : {result["cpu_freq"]} Cache : {result["cpu_cache"]}
                    Memory : {result["mem_total"]}
                    Host IP : {result["ip"]}
                    '''
                    widget.sys_info_msg = sys_info
            else:
                print("Failed to obtain the SSH Widget")
        except Exception as e:
            print(e)

    def _show_info(self, path: str = None, status: bool = None, msg: str = None, type_: str = None, widget_key: str = None, local_path: str = None, open_it: bool = False):
        no_refresh_types = ["download",
                            "start_upload", "start_download", "info"]
       #  print(f"showinfo : {type_} {widget_key}")
        duration = 3000
        session_widget = self.session_widgets[widget_key]
        if not session_widget:
            return
        title = ""
        if type_ == "upload":
            paths = path if isinstance(path, list) else [path]
            for p in paths:
                # The 'path' from the finished signal is the unique identifier
                file_id = self.active_transfers.get(p, {}).get("id")
                if not file_id:
                    # Fallback for safety, though it should exist
                    file_id = f"{widget_key}_{p}_{time.time()}"

                if status:
                    if p not in self.active_transfers:
                        # This can happen if the file is very small and finishes
                        # before any progress signal is emitted.
                        self._add_transfer_item_if_not_exists(
                            widget_key, p, "upload")
                        file_id = self.active_transfers[p]["id"]

                    if p in self.active_transfers:
                        self.active_transfers[p]['type'] = 'completed'
                        self.active_transfers[p]['progress'] = 100

                    data = {"type": "completed", "progress": 100}
                    session_widget.transfer_progress.update_transfer_item(
                        file_id, data)
                    title = self.tr(f"Upload {p} completed")
                    duration = 2000
                else:
                    title = f"Uoload {p} failure"
                    duration = -1
                    if p in self.active_transfers:
                        session_widget.transfer_progress.remove_transfer_item(
                            self.active_transfers[p]["id"])
                        del self.active_transfers[p]

        elif type_ == "start_upload":
            # This is now handled by _add_transfer_item_if_not_exists
            # It will be called from _handle_files for single files/compressed,
            # or dynamically from progress/finished signals for expanded dirs.
            pass

        elif type_ == "start_download":
            paths = path if isinstance(path, list) else [path]
            for p in paths:
                file_id = f"{widget_key}_{os.path.basename(p)}_{time.time()}"
                data = {
                    "type": "download",
                    "filename": os.path.basename(p),
                    "progress": 0
                }
                self.active_transfers[file_id] = data
                session_widget.transfer_progress.add_transfer_item(
                    file_id, data)

        elif type_ == "download":
            # 'path' is the unique remote path identifier
            if path in self.active_transfers:
                file_id = self.active_transfers[path]["id"]
                if status:
                    self.active_transfers[path]['type'] = 'completed'
                    self.active_transfers[path]['progress'] = 100
                    data = {"type": "completed", "progress": 100}
                    session_widget.transfer_progress.update_transfer_item(
                        file_id, data)

                    if open_it and local_path:
                        try:
                            print(f"From Remote Path : {path}")
                            self._open_downloaded_file(
                                local_path, widget_key, path)
                        except Exception as e:
                            print(f"Error opening file/folder: {e}")
                else:
                    session_widget.transfer_progress.remove_transfer_item(
                        file_id)
                    del self.active_transfers[path]
            elif status:  # Finished signal for a small file that sent no progress
                self._add_transfer_item_if_not_exists(
                    widget_key, path, "download", open_it=open_it)
                if path in self.active_transfers:
                    file_id = self.active_transfers[path]["id"]
                    self.active_transfers[path]['type'] = 'completed'
                    self.active_transfers[path]['progress'] = 100
                    data = {"type": "completed", "progress": 100}
                    session_widget.transfer_progress.update_transfer_item(
                        file_id, data)

        else:
            duration = 5000
            title = ""
            if type_ in ("compression", "uncompression"):
                title = self.tr(f"Start to {type_} : {path}")
                msg = ""
            elif type_ == "delete":
                print("delete showinfo")
                if status:
                    title = self.tr(f"Deleted {path} successfully")
                else:
                    title = self.tr(f"Failed to delete {path}\n{msg}")
                    duration = -1
            elif type_ == "paste":
                if status:
                    title = self.tr("Paste Successful")
                    msg = self.tr(f"Pasted {path} to {local_path}")
                else:
                    title = self.tr("Paste Failed")
                    duration = -1
            elif type_ == "rename":
                if status:
                    title = self.tr("Rename Successful")
                    msg = self.tr(f"Renamed {path} to {local_path}")
                else:
                    title = self.tr("Rename Failed")
                    duration = -1
            elif type_ == "mkdir":
                if status:
                    title = self.tr(f"Created directory {path} successfully")
                else:
                    title = self.tr(
                        f"Failed to create directory {path}\n{msg}")
                    duration = -1

        if title:
            InfoBar.info(
                title=title,
                content=msg,
                orient=Qt.Horizontal,
                isClosable=True,
                position=InfoBarPosition.BOTTOM_RIGHT,
                duration=duration,
                parent=self.window()
            )

        if type_ not in no_refresh_types and widget_key:
            self._refresh_paths(widget_key)
            print(f"刷新路径: {widget_key}")

    def _show_progresses(self, path, percentage, bytes_so_far, total_bytes, widget_key, transfer_type):
        """Handles progress updates for both uploads and downloads."""
        session_widget = self.session_widgets[widget_key]
        if not session_widget:
            return

        # 'path' is the unique identifier (local for upload, remote for download)
        if path not in self.active_transfers:
            self._add_transfer_item_if_not_exists(
                widget_key, path, transfer_type)

        if path in self.active_transfers:
            file_id = self.active_transfers[path]["id"]
            data = self.active_transfers[path]
            data["progress"] = percentage
            data["bytes_so_far"] = bytes_so_far
            data["total_bytes"] = total_bytes
            if percentage >= 100:
                data["type"] = "completed"
            session_widget.transfer_progress.update_transfer_item(
                file_id, data)

    def _open_downloaded_file(self, local_path: str, widget_key: str, remote_path: str):
        """打开下载的文件"""
        config = setting_.read_config()
        external_editor = config.get("external_editor", "")
        open_mode = config.get("open_mode", False)
        is_text = False
        mime = None
        try:
            with open(local_path, "rb") as f:
                content = f.read(2048)
                mime = magic.from_buffer(content, mime=True)
            if mime in mime_types or mime.startswith("text/"):
                is_text = True
            elif mime == "application/octet-stream":
                try:
                    content.decode('utf-8')
                    is_text = True
                except UnicodeDecodeError:
                    try:
                        content.decode('gbk')
                        is_text = True
                    except UnicodeDecodeError:
                        is_text = False
        except Exception as e:
            print(f"Error checking file type: {e}")
        if (external_editor and os.path.isfile(external_editor)) and open_mode:
            try:
                subprocess.Popen([external_editor, local_path])
            except Exception as editor_error:
                print(
                    f"Error opening with external editor: {editor_error}, fallback to internal editor")
                if is_text:
                    self._open_in_internal_editor(
                        local_path, widget_key, remote_path)
        else:
            if is_text:
                self._open_in_internal_editor(
                    local_path, widget_key, remote_path)
            else:
                print(
                    f"File {local_path} is not a text file (MIME: {mime}), cannot open in editor")
        self._start_file_watching_if_text(local_path, widget_key, remote_path)

    def _open_in_internal_editor(self, local_path: str, widget_key: str, remote_path: str):
        """在内置编辑器中打开文件"""
        try:
            existing_tab_id = self.sidePanel.find_tab_by_remote_path(
                remote_path)
            if existing_tab_id:
                self.sidePanel.switch_to_tab(existing_tab_id)
                tab_info = self.sidePanel.tabs[existing_tab_id]
                editor_widget = tab_info['page']
                if isinstance(editor_widget, EditorWidget):
                    editor_widget.load_file(local_path)
            else:
                tab_title = os.path.basename(remote_path)
                tab_id = self.sidePanel.add_new_tab(EditorWidget(), tab_title, {
                                                    "path": local_path, "remote_path": remote_path, "widget_key": widget_key})
        except Exception as e:
            print(f"Error opening in internal editor: {e}")
            import traceback
            traceback.print_exc()

    def _start_file_watching_if_text(self, local_path: str, widget_key: str, remote_path: str):
        """如果是文本文件，启动文件监视以便自动重新上传"""
        try:
            with open(local_path, "rb") as f:
                content = f.read(2048)
                mime = magic.from_buffer(content, mime=True)
            is_text = False
            if mime in mime_types or mime.startswith("text/"):
                is_text = True
            elif mime == "application/octet-stream":
                try:
                    content.decode('utf-8')
                    is_text = True
                    print(
                        f"File detected as text by content analysis (MIME: {mime})")
                except UnicodeDecodeError:
                    try:
                        content.decode('gbk')
                        is_text = True
                        print(
                            f"File detected as text (GBK encoding) by content analysis (MIME: {mime})")
                    except UnicodeDecodeError:
                        is_text = False

            if is_text:
                if widget_key in self.watching_dogs:
                    for watcher in self.watching_dogs[widget_key]:
                        if os.path.abspath(watcher.file_path) == os.path.abspath(local_path):
                            print(
                                f"Watcher for {local_path} already exists. Skipping.")
                            return
                print(
                    f"Text file detected (MIME: {mime}), starting file watching: {local_path}")
                file_thread = FileWatchThread(local_path)
                file_thread.file_saved.connect(
                    lambda local: self.reupload_when_saved(widget_key, local, remote_path))
                file_thread.start()

                if widget_key not in self.watching_dogs:
                    self.watching_dogs[widget_key] = []
                self.watching_dogs[widget_key].append(file_thread)
            else:
                print(
                    f"File type {mime} is not text file, won't start watching")
        except Exception as e:
            print(f"Error checking file type: {e}")

    def reupload_when_saved(self, widget_name, local_path, remote_path,):
        remote_path = os.path.dirname(remote_path)
        # print(f"将上传 {local_path} 到 {widget_name}的 {remote_path}")
        file_manager: RemoteFileManager = self.file_tree_object[widget_name]

        if file_manager:
            self._handle_upload_request(widget_key=widget_name, local_path=local_path,
                                        remote_path=remote_path, compression=False, file_manager=file_manager)

    def _start_ssh_connect(self, widget_key):
        parent_key = widget_key.split("-")[0].strip()
        session = self.sessionmanager.get_session_by_name(parent_key)

        def key_verification(file_md5, host_key):
            msg = ''
            session_file_md5 = session.processes_md5
            session_host_key = session.host_key

            if session_file_md5 != file_md5:
                msg += self.tr(
                    f"The MD5 file fingerprint of the Processes file does not match the record.\nMD5:{file_md5}\n")
            if session_host_key != host_key:
                msg += self.tr(
                    f"The host key does not match the recorded one.\n{host_key}\n")

            if msg:
                msg += self.tr("Are you sure to continue?")
                w = Dialog(self.tr("Warning!!!!!"), msg, self)
                if w.exec():
                    self.sessionmanager.update_session_processes_md5(
                        parent_key, file_md5)
                    self.sessionmanager.update_session_host_key(
                        parent_key, host_key)
                    start_real_connection()
                else:
                    return
            else:
                start_real_connection()

        def start_real_connection():
            session_widget = self.session_widgets[widget_key]
            # processes = SSHWorker(session, for_resources=True)
            # processes.key_verification.connect(key_verification)
            self.ssh_session[f'{widget_key}-processes'] = processes
            processes.sys_resource.connect(
                lambda usage, key=widget_key: self._set_usage(key, usage))
            processes.start()

            file_manager = RemoteFileManager(session)
            handler = FileManagerHandler(
                file_manager, session_widget, widget_key, self)

            def on_sftp_ready():
                global home_path
                home_path = file_manager.get_default_path()
                path_list = self.parse_linux_path(home_path)

                session_widget.file_bar.send_signal = False
                for i, path in enumerate(path_list):
                    if i == len(path_list) - 1:
                        session_widget.file_bar.send_signal = True
                    session_widget.file_bar.breadcrumbBar.addItem(path, path)

                session_widget.file_explorer.path = home_path
                file_manager.add_path(home_path)

                def _on_path_check_result(widget_key, path, result):
                    self._update_file_tree_branch_when_cd(path, widget_key)

                file_manager.path_check_result.connect(
                    partial(_on_path_check_result,
                            widget_key), Qt.QueuedConnection
                )

            file_manager.sftp_ready.connect(on_sftp_ready)
            file_manager.start()

            self.file_tree_object[widget_key] = file_manager
            self.file_tree_object[f"{widget_key}-handler"] = handler

            worker = SSHWorker(session, for_resources=False)
            self.ssh_session[widget_key] = worker
            worker.connected.connect(
                lambda success, msg: self._on_ssh_connected(success, msg))
            worker.error_occurred.connect(lambda e: self._on_ssh_error(e))

            try:
                child_widget = self.session_widgets[widget_key]
                if hasattr(child_widget, 'ssh_widget'):
                    child_widget.ssh_widget.set_worker(worker)
                else:
                    print("child_widget does not have an ssh_widget attribute")
            except Exception as e:
                print("Injecting worker failed:", e)

            worker.start()
            session_widget.ssh_widget.directoryChanged.connect(
                lambda path: file_manager.check_path_async(path)
            )
            session_widget.disk_storage.refresh.triggered.connect(
                lambda checked, ck=widget_key: self._refresh_paths(ck)
            )

        processes = SSHWorker(session, for_resources=True)
        processes.key_verification.connect(key_verification)
        processes.start()

    def _open_server_files(self, path: str, type_: str, widget_key: str):
        config = setting_.read_config()
        file_manager: RemoteFileManager = self.file_tree_object[widget_key]

        # 停止此文件的现有观察者，以防止在重新下载时触发
        session_id = file_manager.session_info.id
        # 构建预期的本地路径以查找观察者
        expected_local_path = os.path.abspath(os.path.join(
            "tmp", "edit", session_id, path.lstrip('/')))

        if widget_key in self.watching_dogs:
            # 遍历列表的副本以安全地删除项目
            for watcher in self.watching_dogs[widget_key][:]:
                if os.path.abspath(watcher.file_path) == expected_local_path:
                    print(
                        f"Stopping existing watcher for {expected_local_path}")
                    watcher.stop()
                    self.watching_dogs[widget_key].remove(watcher)

        duration = 2000

        # 检查是否配置了外置编辑器
        external_editor = config.get("external_editor", "")
        # True for external, False for internal
        open_mode = config.get("open_mode", False)

        if (external_editor and os.path.isfile(external_editor)) and open_mode:
            title = self.tr(f"File: {path} Type: {type_}\n")
            msg = self.tr(f"Start to download and open with external editor")
        else:
            title = self.tr(f"File: {path} Type: {type_}\n")
            msg = self.tr(f"Start to download and open with internal editor")

        if type_ == "executable":
            title = self.tr(f"{path} is an executable won't start downloading")
            msg = ""

        InfoBar.info(
            title=title,
            content=msg,
            orient=Qt.Horizontal,
            isClosable=True,
            position=InfoBarPosition.BOTTOM_RIGHT,
            duration=duration,
            parent=self.window()
        )
        if type_ != "executable":
            # 获取稳定的会话ID
            session_id = file_manager.session_info.id
            file_manager.download_path_async(
                path, open_it=True, session_id=session_id)

    def _handle_files(self, action_type, full_path, copy_to, cut, widget_key):
        file_manager: RemoteFileManager = self.file_tree_object[widget_key]
        if action_type == "delete":
            file_manager.delete_path(full_path)
        elif action_type == "copy_path":
            paths_to_copy = full_path if isinstance(
                full_path, list) else [full_path]
            clipboard.setText('\n'.join(paths_to_copy))
        elif action_type == "download":
            # Debounce download requests
            if widget_key not in self._pending_download_paths:
                self._pending_download_paths[widget_key] = {
                    "paths": [], "compression": cut}

            # Since _handle_files is called for each item, full_path is a single path string
            self._pending_download_paths[widget_key]["paths"].append(full_path)
            self._pending_download_paths[widget_key]["compression"] = cut
            self._download_debounce_timer.start()

        elif action_type == "paste":
            source_paths = full_path if isinstance(
                full_path, list) else [full_path]
            for source_path in source_paths:
                if source_path and copy_to:
                    print(
                        f"Copy {source_path} to {copy_to} Cut status : {cut}")
                    file_manager.copy_to(source_path, copy_to, cut)
        elif action_type == "rename":
            if copy_to:
                print(f"Rename {full_path} to {copy_to}")
                file_manager.rename(path=full_path, new_name=copy_to)
        elif action_type == "info":
            paths_to_info = full_path if isinstance(
                full_path, list) else [full_path]
            for path in paths_to_info:
                file_manager.get_file_info(path)
        elif action_type == "mkdir":
            if full_path:
                file_manager.mkdir(full_path)

    def _process_pending_downloads(self):
        """Process the accumulated download paths after the debounce delay."""
        if not self._pending_download_paths:
            return

        # Atomically take ownership of the pending paths and reset the shared collection
        paths_to_process_now = self._pending_download_paths
        self._pending_download_paths = {}

        for widget_key, download_info in paths_to_process_now.items():
            paths_to_download = download_info["paths"]
            compression = download_info["compression"]

            if not paths_to_download:
                continue

            file_manager: RemoteFileManager = self.file_tree_object.get(
                widget_key)
            if not file_manager:
                continue

            if not compression:  # Non-compressed download
                path_types = file_manager.check_path_type_list(
                    paths_to_download)
                files_to_add_ui = [
                    p for p, t in path_types.items() if t == "file"]
                for path in files_to_add_ui:
                    self._add_transfer_item_if_not_exists(
                        widget_key, path, "download", open_it=False)
                file_manager.download_path_async(
                    paths_to_download, open_it=False, compression=compression)

            else:  # Compressed download
                print(f"{type(paths_to_download)} {paths_to_download}")
                self._add_transfer_item_if_not_exists(
                    widget_key, paths_to_download[0], "download", open_it=False)
                file_manager.download_path_async(
                    paths_to_download[0], open_it=False, compression=compression)

    def _refresh_paths(self, widget_key: str):
        print("Refresh the page")
        session_widget: SSHWidget = self.session_widgets[widget_key]
        session_widget._update_file_explorer()

    def parse_linux_path(self, path: str) -> list:
        """
        Parse a Linux path into a list of path elements, with each level as an element.

        Example:
            '/home/bee' -> ['/', 'home', 'bee']
            '/' -> ['/']

        Parameters:
            path: str, Linux-style path

        Returns:
            list[str], list from root to deepest directory
        """
        if not path:
            return []

        path_list = []
        if path.startswith('/'):
            path_list.append('/')
        parts = [p for p in path.strip('/').split('/') if p]

        path_list.extend(parts)

        return path_list

    def _update_file_tree_branch_when_cd(self, path: str, widget_key: str):
        file_manager: RemoteFileManager = self.file_tree_object[widget_key]
        file_manager.add_path(path, update_tree_sign=True)
        # path_status = file_manager.check_path_type(path)
        # # print(f"更新目录：{path}")
        # if path_status:
        #     file_manager._add_path_to_tree(path)
        # else:
        #     print(f"{path}不存在")

    def on_file_tree_updated(self, file_tree, sw, path=None):
        """Handling file tree updates"""
        sw.disk_storage.refresh_tree(file_tree)
        if path:
            sw.disk_storage.switch_to(path)

    def on_file_manager_error(self, error_msg):
        InfoBar.error(
            title=self.tr('File management errors'),
            content=self.tr(f'''Error details:\n{error_msg}'''),
            orient=Qt.Vertical,
            isClosable=True,
            position=InfoBarPosition.TOP_RIGHT,
            duration=-1,
            parent=self
        )

    def _count_sessions_starting_with(self, session_id_prefix):
        """Count the number of sessions starting with the specified prefix"""
        count = 0
        for key in self.session_widgets.keys():
            if key.startswith(session_id_prefix):
                count += 1
        return count

    def _on_session_selected(self, session_id=None, session_name=None):
        """Handling session selection"""

        def _connect_file_explorer_signals(self, widget, widget_key):
            # 文件操作
            widget.file_explorer.file_action.connect(
                partial(self._handle_files, widget_key=widget_key)
            )

            # 目录选择
            widget.disk_storage.directory_selected.connect(
                partial(self._update_file_tree_branch_when_cd,
                        widget_key=widget_key)
            )

            # 取消传输
            widget.transfer_progress.cancelRequested.connect(
                partial(self._handle_transfer_cancellation,
                        widget_key=widget_key)
            )

            widget.transfer_progress.open_file.connect(
                self.open_in_explorer
            )
            self.windowResized.connect(widget.on_main_window_resized)
        if session_name:
            name = session_name.rsplit(" - ", 1)[0]
            session = self.sessionmanager.get_session_by_name(name)

        if session_id:
            session = self.sessionmanager.get_session(session_id=session_id)

        name = session.name

        child_number = 1
        for key in self.session_widgets.keys():
            if key.startswith(f"{name} - "):
                try:
                    existing_num = int(key.split(" - ")[-1])
                    child_number = max(child_number, existing_num + 1)
                except ValueError:
                    continue
        widget_key = f"{name} - {child_number}"
        print(widget_key)
        font_name, font_size = font_.read_font()
        widget = SSHWidget(widget_key, font_name=font_name)
        self.ssh_page.add_session(widget_key, widget_key, widget=widget)
        _connect_file_explorer_signals(self, widget, widget_key)

        self.session_widgets[widget_key] = widget

        self._start_ssh_connect(widget_key)
        self.switchTo(self.ssh_page, widget_key)

    def apply_locked_ratio(self, event=None):
        new_width, new_height = 0, 0
        if not self.isMaximized():
            """Apply background image proportionally to window size"""
            if self.settingInterface._lock_ratio and self._bg_pixmap and self._bg_ratio:
                if event is not None and not isinstance(event, bool):
                    new_width = event.size().width()
                    new_height = event.size().height()
                else:
                    new_width = self.width()
                    new_height = self.height()

                target_ratio = self._bg_ratio

                if abs(new_width / new_height - target_ratio) > 0.01:
                    new_height = int(new_width / target_ratio)
                    self.resize(new_width, new_height)
            if self.settingInterface.init_window_size and new_width and new_height:
                self.settingInterface.save_window_size((new_width, new_height))

    def resizeEvent(self, event):
        self.windowResized.emit()
        self._resize_timer.start(50)
        if not self.isActiveWindow() or not self.underMouse():
            self.apply_locked_ratio(event)
        super().resizeEvent(event)

    def initLayout(self):
        self.hBoxLayout.setSpacing(0)
        self.hBoxLayout.setContentsMargins(0, self.titleBar.height(), 0, 0)
        self.hBoxLayout.addWidget(self.navigationInterface)

        # Create a splitter to hold the main content and the side panel
        self.mainSplitter = QSplitter(Qt.Horizontal, self)
        self.mainSplitter.addWidget(self.stackWidget)
        self.mainSplitter.addWidget(self.sidePanel)

        # Restore splitter sizes
        splitter_sizes = setting_.read_config().get(
            "splitter_sizes", [self.width() * 0.7, self.width() * 0.3])
        self.mainSplitter.setSizes([int(s) for s in splitter_sizes])

        # Connect signal to save sizes
        self.mainSplitter.splitterMoved.connect(self._on_main_splitter_moved)

        # Style the splitter handle to be thin and subtle
        self.mainSplitter.setStyleSheet("""
            QSplitter::handle {
                background-color: transparent;
                width: 1px;
                margin: 0px;
                padding: 0px;
            }
            QSplitter::handle:hover {
                background-color: #555555;
            }
        """)

        self.hBoxLayout.addWidget(self.mainSplitter)
        self.hBoxLayout.setStretchFactor(self.mainSplitter, 1)

    def initNavigation(self):
        # self.navigationInterface.setAcrylicEnabled(True)

        self.addSubInterface(self.MainInterface, FIF.HOME, self.tr("Home"))

        self.navigationInterface.addSeparator()

        # self.addSubInterface(self.sessions, FIF.ALBUM,
        #                      self.tr("SSH session"), NavigationItemPosition.SCROLL)

        self.addSubInterface(self.ssh_page, FIF.ALBUM, self.tr("SSH Session"))

        self.navigationInterface.addWidget(
            routeKey='sync',
            widget=NavigationAvatarWidget(
                'Sync', resource_path('resource/icons/sync.svg')),
            onClick=lambda: self.sycn_widget.exec_(),
            position=NavigationItemPosition.BOTTOM,
        )

        self.navigationInterface.addWidget(
            routeKey='about',
            widget=NavigationAvatarWidget(
                'Github', resource_path('resource/icons/github.svg')),
            onClick=self._open_github,
            position=NavigationItemPosition.BOTTOM,
        )

        self.addSubInterface(self.settingInterface, FIF.SETTING,
                             self.tr("Setting"), NavigationItemPosition.BOTTOM)
        self.stackWidget.currentChanged.connect(self.onCurrentInterfaceChanged)
        self.stackWidget.setCurrentIndex(0)
        self.onCurrentInterfaceChanged(0)  # Set initial visibility

    def _open_github(self):
        github_url = QUrl("https://github.com/Heartestrella/P-SSH")
        QDesktopServices.openUrl(github_url)

    def initWindow(self):
        self.titleBar.setAttribute(Qt.WA_StyledBackground)

        desktop = QApplication.desktop().availableGeometry()
        w, h = desktop.width(), desktop.height()
        self.move(w//2 - self.width()//2, h//2 - self.height()//2)

        self.setQss()

    def _handle_action(self, action, name):
        if action == "close":
            self.remove_interface(name)
        elif action == "copy":
            self._on_session_selected(session_name=name)

    def remove_interface(self, widget_name):
        try:
            self.ssh_page.remove_session(widget_name)
            widget = self.session_widgets[widget_name]
            widget.cleanup()
            self.session_widgets.pop(widget_name, None)
            widget.deleteLater()
            worker = self.ssh_session.pop(widget_name, None)
            worker_processes = self.ssh_session.pop(
                f'{widget_name}-processes', None)
            watching_dogs = self.watching_dogs.pop(widget_name, None)
            if worker:
                worker.close()
            if worker_processes:
                worker_processes.close()
            file_manager = self.file_tree_object.pop(widget_name, None)
            if file_manager:
                file_manager._cleanup()
            file_manager_handler = self.file_tree_object.pop(
                f"{widget_name}-handler", None)
            if file_manager_handler:
                file_manager_handler.cleanup()
            if watching_dogs:
                for dog in watching_dogs:
                    dog.stop()
        except Exception as e:
            InfoBar.error(
                title=self.tr('Error closing session!'),
                content=self.tr(f'''Error details:\n{e}'''),
                orient=Qt.Vertical,
                isClosable=True,
                position=InfoBarPosition.TOP_RIGHT,
                duration=-1,
                parent=self
            )

    def addSubInterface(self, interface, icon, text: str, position=NavigationItemPosition.TOP, parent=None):
        """ Add a page """
        self.stackWidget.addWidget(interface)
        self.navigationInterface.addItem(
            routeKey=interface.objectName(),
            icon=icon,
            text=text,
            onClick=lambda: self.switchTo(interface),
            position=position,
            tooltip=text,
            parentRouteKey=parent.objectName() if parent else None
        )

    def setQss(self):
        color = 'dark' if isDarkTheme() else 'light'
        with open(resource_path(f'resource/{color}/demo.qss'), encoding='utf-8') as f:
            self.setStyleSheet(f.read())

    def switchTo(self, widget, window_tittle=None):
        self.stackWidget.setCurrentWidget(widget)
        if window_tittle:
            self.setWindowTitle(window_tittle)
        elif widget.objectName():
            self.setWindowTitle(widget.objectName())

    def onCurrentInterfaceChanged(self, index):
        widget = self.stackWidget.widget(index)
        self.navigationInterface.setCurrentItem(widget.objectName())

        # Show side panel only for SSH page
        if widget == self.ssh_page:
            self.sidePanel.show()
        else:
            self.sidePanel.hide()

    def _handle_upload_request(self, widget_key, local_path, remote_path, compression, file_manager):
        """Pre-handles upload requests to determine if UI items should be pre-created."""
        # If compression is on and we have a list, create a single UI item for the batch.
        if compression and isinstance(local_path, list):
            task_id = f"compress_upload_{time.time()}"
            self._add_transfer_item_if_not_exists(
                widget_key, local_path, 'upload', task_id=task_id)
            file_manager.upload_file(
                local_path, remote_path, compression, task_id=task_id)
            return

        # Original logic for other cases (single files, non-compressed lists/dirs)
        paths = local_path if isinstance(local_path, list) else [local_path]
        print(f"Paths Len : {len(paths)}")
        for p in paths:
            # For non-compressed dirs, we don't create items here.
            # They will be created dynamically on first progress/finished signal.
            if not (os.path.isdir(p) and not compression):
                self._add_transfer_item_if_not_exists(
                    widget_key, p, 'upload')
            file_manager.upload_file(p, remote_path, compression)

    def _add_transfer_item_if_not_exists(self, widget_key, path, transfer_type, task_id=None, open_it=False):
        """Helper to add a transfer item to the UI if it doesn't exist."""
        print(f"{type(path)} {path}")
        session_widget = self.session_widgets[widget_key]
        if not session_widget:
            return

        # The unique identifier for a task is now the full path for single files,
        # or the string representation of the list for compressed batches.
        task_identifier = task_id if task_id else (
            str(path) if isinstance(path, list) else path)

        if task_identifier in self.active_transfers:
            return  # Avoid creating duplicate entries

        # Create a truly unique ID for the UI widget
        file_id = f"{widget_key}_{task_identifier}_{time.time()}"

        # 根据 transfer_type 和 open_it 决定本地路径
        if transfer_type == 'download' and open_it:
            # 双击编辑模式：使用会话隔离的编辑目录，并镜像远程路径
            file_manager = self.file_tree_object.get(widget_key)
            if file_manager:
                session_id = file_manager.session_info.id
                if type(path) == list:
                    for i in path:
                        remote_path_normalized = i.lstrip('/')
                        self.file_id_to_path[file_id] = os.path.join(
                            "tmp", "edit", session_id, remote_path_normalized)
                else:
                    remote_path_normalized = path.lstrip('/')
                    self.file_id_to_path[file_id] = os.path.join(
                        "tmp", "edit", session_id, remote_path_normalized)
            else:
                # 降级到常规下载路径
                if type(path) == list:
                    for i in path:
                        self.file_id_to_path[file_id] = os.path.join(
                            "_ssh_download", os.path.basename(i))
                else:
                    self.file_id_to_path[file_id] = os.path.join(
                        "_ssh_download", os.path.basename(path))
        else:
            # 常规下载或上传：使用原有逻辑
            if type(path) == list:
                for i in path:
                    self.file_id_to_path[file_id] = os.path.join(
                        "_ssh_download", os.path.basename(i))
            else:
                self.file_id_to_path[file_id] = os.path.join(
                    "_ssh_download", os.path.basename(path))
        if isinstance(path, list) and transfer_type == 'upload':
            # Special handling for compressed list uploads
            file_name = "Compressing..."
        elif isinstance(path, list):
            count = len(path)
            if count == 0:
                return
            file_name = f"{os.path.basename(path[0][0])}"
            if count > 1:
                file_name += f" and {count - 1} others"
        else:
            file_name = os.path.basename(path)

        data = {
            "id": file_id,  # The unique ID for the widget
            "type": transfer_type,
            "filename": file_name,
            "progress": 0
        }

        # Use the task_identifier as the key in our tracking dictionary
        self.active_transfers[task_identifier] = data
        session_widget.transfer_progress.add_transfer_item(file_id, data)

    def open_in_explorer(self, file_id: str):
        filepath = self.file_id_to_path.get(file_id, None)

        if filepath and os.path.exists(filepath):  # maybe its remote path

            print("Open : ", filepath)
            if sys.platform == "win32":
                subprocess.Popen(
                    ["explorer", "/select,", os.path.normpath(filepath)])
            elif sys.platform == "darwin":
                subprocess.Popen(["open", "-R", filepath])
            else:
                subprocess.Popen(["xdg-open", os.path.dirname(filepath)])

    def _handle_transfer_cancellation(self, file_id, widget_key):
        # import inspect
        # caller_frame = inspect.stack()[1]
        # caller_filename = caller_frame.filename
        # caller_line_no = caller_frame.lineno
        # caller_func_name = caller_frame.function
        # print(
        #     f"Called from {caller_func_name} in {caller_filename}:{caller_line_no}")

        file_manager = self.file_tree_object.get(widget_key)
        if not file_manager:
            return

        # Find the original identifier for the task
        task_identifier = None
        for identifier, data in self.active_transfers.items():
            if data.get("id") == file_id:
                task_identifier = identifier
                break

        if task_identifier:
            # Tell the file manager to cancel the backend worker
            file_manager.cancel_transfer(task_identifier)

            # Remove from UI and tracking dictionary
            session_widget = self.session_widgets[widget_key]
            if session_widget:
                session_widget.transfer_progress.remove_transfer_item(file_id)

            self.active_transfers.pop(task_identifier, None)

    def remove_nav_edge(self):
        self.navigationInterface.setStyleSheet("""
            NavigationInterface {
                background-color: transparent;
                border: none;
            }
            NavigationInterface > QWidget {
                background-color: transparent;
            }
        """)

    def _update_transfer_item_name(self, identifier, new_name, widget_key):
        session_widget = self.session_widgets[widget_key]
        if not session_widget:
            return

        if identifier in self.active_transfers:
            file_id = self.active_transfers[identifier]["id"]
            self.active_transfers[identifier]["filename"] = new_name
            data = self.active_transfers[identifier]
            session_widget.transfer_progress.update_transfer_item(
                file_id, data)

    def set_ssh_session_text_color(self, color: str):
        try:
            for _, value_ in self.session_widgets.items():
                for key, value_1 in value_.items():
                    if key != "widget":
                        print(value_1)
                        if not value_1.parent_state:
                            value_1.ssh_widget.set_colors(text_color=color)
                            value_1.task.set_text_color(color)
        except Exception as e:
            print(f"Setting font color failed:{e}")

    def _on_theme_changed(self, value):
        if value == "Light":
            setTheme(Theme.LIGHT)
        elif value == "Dark":
            setTheme(Theme.DARK)
        else:
            setTheme(Theme.AUTO)

        self.setQss()

        for i in range(self.stackWidget.count()):
            w = self.stackWidget.widget(i)
            if hasattr(w, 'widget') and isinstance(w.widget, QWidget):
                w.widget.update()
            else:
                w.update()

    def clear_global_background(self):
        self._bg_pixmap = None
        self._bg_opacity = 1.0
        self.update()

        self.navigationInterface.setStyleSheet("")

    def set_global_background(self, image_path: str):
        pixmap = QPixmap(image_path)
        if pixmap.isNull():
            print(f"Invalid image path: {image_path}")
            return
        self._bg_pixmap = pixmap
        self._bg_ratio = pixmap.width() / pixmap.height()
        self._bg_opacity = 1.0
        self.update()
        self.remove_nav_edge()

    def paintEvent(self, event):
        if self._bg_pixmap:
            painter = QPainter(self)
            painter.setOpacity(self._bg_opacity)
            painter.drawPixmap(self.rect(), self._bg_pixmap)
        super().paintEvent(event)

    def on_theme_color_changed(self, color_hex: str):
        """
        Applies the new theme color to all relevant widgets.
        """
        for widget_key, session_widget in self.session_widgets.items():
            try:
                if hasattr(session_widget, 'update_splitter_color'):
                    session_widget.update_splitter_color(color_hex)
            except Exception as e:
                print(f"Error updating splitter color for {widget_key}: {e}")

    def _on_main_splitter_moved(self):
        """
        When the main splitter is moved, this function saves the new sizes and
        also forces the active SSH widget to update its internal layout to
        maintain the fixed width of its left panel.
        """
        setting_.revise_config("splitter_sizes", self.mainSplitter.sizes())
        current_widget = self.ssh_page.sshStack.currentWidget()
        if isinstance(current_widget, SSHWidget):
            QTimer.singleShot(10, current_widget.force_set_left_panel_width)

    def _ensure_side_panel_visible(self):
        """
        Ensures the side panel is visible and preserves the active SSH widget's
        internal splitter position, avoiding race conditions by blocking signals.
        """
        sizes = self.mainSplitter.sizes()
        if len(sizes) == 2 and sizes[1] == 0:
            self.mainSplitter.blockSignals(True)
            saved_sizes = setting_.read_config().get("splitter_sizes")
            if saved_sizes and len(saved_sizes) == 2 and saved_sizes[1] != 0:
                self.mainSplitter.setSizes([int(s) for s in saved_sizes])
            else:
                default_sizes = [self.width() * 0.7, self.width() * 0.3]
                self.mainSplitter.setSizes([int(s) for s in default_sizes])
            self.mainSplitter.blockSignals(False)
            current_widget = self.ssh_page.sshStack.currentWidget()
            if isinstance(current_widget, SSHWidget):
                QTimer.singleShot(
                    10, current_widget.force_set_left_panel_width)

    def _set_language(self, lang_code: str):
        translator = QTranslator()
        if lang_code == "system":
            system_locale = QLocale.system().name()
            if translator.load(f"resource/i18n/pssh_{system_locale}.qm"):
                QApplication.instance().installTranslator(translator)
            else:
                print("Translation file loading failed")
        else:
            if translator.load(f"resource/i18n/pssh_{lang_code}.qm"):
                QApplication.instance().installTranslator(translator)
            else:
                print("Translation file loading failed")
        self.settingInterface.retranslateUi()
        self.MainInterface.retranslateUi()
        for _, value_ in self.session_widgets.items():
            for key, value_1 in value_.items():
                if key != "widget":
                    value_1.retranslateUi()

    def changeEvent(self, event):
        # Get the maximized and minimized state
        if event.type() == QEvent.WindowStateChange:
            if self.isMaximized():
                setting_.revise_config("maximized", True)
            else:
                setting_.revise_config("maximized", False)
        super().changeEvent(event)

    def get_active_ssh_widget(self):
        if self.stackWidget.currentWidget() == self.ssh_page:
            current_ssh_widget = self.ssh_page.sshStack.currentWidget()
            if isinstance(current_ssh_widget, SSHWidget):
                return current_ssh_widget
        return None


def language_code_to_locale(code: str) -> str:
    """
    EN -> en_US
    CN -> zh_CN
    JP -> ja_JP
    RU -> ru_RU
    system -> 
    """
    mapping = {
        "EN": "en_US",
        "CN": "zh_CN",
        "JP": "ja_JP",
        "RU": "ru_RU",
    }

    code = code.upper().strip()

    if code == "SYSTEM":
        return QLocale.system().name()

    return mapping.get(code, "en_US")


def excepthook(exc_type, exc_value, exc_traceback):
    print("Uncaught exception:", exc_type, exc_value)
    traceback.print_tb(exc_traceback)
    error_msg = "".join(traceback.format_exception(
        exc_type, exc_value, exc_traceback))
    QMessageBox.critical(None, "程序出错", error_msg)


# sys.excepthook = excepthook

if __name__ == '__main__':
    try:
        configer = SCM()
        setup_global_logging()
        main_logger.info("Application Startup with Hardware Acceleration")
        QApplication.setHighDpiScaleFactorRoundingPolicy(
            Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)

        QApplication.setAttribute(Qt.AA_UseOpenGLES, False)
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        QApplication.setAttribute(Qt.AA_UseDesktopOpenGL, True)

        QApplication.setAttribute(
            Qt.AA_DontCreateNativeWidgetSiblings, True)

        app = QApplication(sys.argv)

        try:
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(
                "su8aru.remmotessh.1.0.0")
            main_logger.info("✅ Windows 应用 ID 设置成功")
        except Exception as icon_error:
            main_logger.warning(f"⚠️  应用 ID 设置失败: {icon_error}")

        config = configer.read_config()
        lang = language_code_to_locale(config.get("language", "system"))
        main_logger.info(f"🌐  语言设置: {lang}")

        translator = QTranslator()
        translator_1 = FluentTranslator()

        if lang == "en_US":
            main_logger.info("使用英语界面")
        elif translator.load(resource_path(f"resource/i18n/pssh_{lang}.qm")):
            app.installTranslator(translator)
            main_logger.info(f"✅ 翻译文件加载成功: {lang}")
        else:
            main_logger.warning(f"⚠️  翻译文件加载失败: {lang}")
            print("Translation file loading failed")

        app.installTranslator(translator_1)

        clipboard = app.clipboard()
        main_logger.info("📋 剪贴板初始化完成")

        w = Window()
        w.show()
        main_logger.info("🖥️  主窗口显示成功")

        main_logger.info("🎯 应用启动成功，进入事件循环")
        app.exec_()

        # Clean up the edit directory on exit
        main_logger.info(" cleaning up tmp/edit directory...")
        edit_tmp_dir = "tmp/edit"
        if os.path.exists(edit_tmp_dir):
            try:
                shutil.rmtree(edit_tmp_dir)
                main_logger.info(f"Successfully cleaned up {edit_tmp_dir}.")
            except Exception as e:
                main_logger.error(f"Error cleaning up {edit_tmp_dir}: {e}")

    except Exception as e:
        main_logger.critical("Application startup failure", exc_info=True)
</file>

</files>
